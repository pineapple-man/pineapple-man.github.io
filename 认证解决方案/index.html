<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>认证解决方案 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="用户认证"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n¶概述\n❓什么是认证\n认证就是证明真身的过程\n\n有下面这样一个场景：在平时使用某宝或者某东时，如果尼想要下单，首先需要注册一个账号，拥有了账号之后，需要输入用户名和密码完成登录过程，这里用户输入用户名和密码请求登录系统的过程就是用户认证的过程\n\n¶常见的认证机制\n有五种常见的认证机制：HTTP Basic Auth、Cookie Auth、OAuth、Token Auth 和 JWT，其中目前最常用的就是 JWT，本文也将详细阐述 JWT 的相关概念\n¶传统 Cookie Auth\n早期互联网以 web 为主，客户端是浏览器 ，所以 Cookie-Session 方式是早期最常用的认证方式，直到现在，一些 web 网站依然用这种方式做认证\n¶认证详述\nCookie 认证机制是：每当服务器收到一个请求认证时，就创建一个 Session 对象，同时在客户端的浏览器端创建一个 Cookie 对象；通过客户端带上来 Cookie 对象来与服务器端的 Session 对象匹配来实现状态管理的。默认当关闭浏览器的时候，cookie 会被删除，可以通过修改 cookie 的 expire time 使 cookie 永不失效\n\n用户输入用户名、密码或者用短信验证码方式登录系统\n服务端验证后，创建一个 Session 信息，并且将 SessionID 存到 cookie，发送回浏览器\n下次客户端再发起请求，自动带上 cookie 信息，服务端通过 cookie 获取 Session 信息进行校验\n\n\n对于处于移动互联网，这样的方式不太适合，主要存在以下几个问题：\n\nCookie-Session 只能在 web 场景下使用，APP 不能存储 cookie，所以造成，现在的产品基本上都同时提供 web 端和 APP 两种使用方式，有点产品甚至只有 APP\n就是单独的 web 客户端使用 cookie 认证，也存在问题：请求跨域十分常见，但是 Cookie 是不能跨域的\n如今的系统大部分都是分布式系统，一旦使用 Cookie 就需要考虑 Session 的同步问题，相同的请求有可能被负载均衡器将请求分发到不同的主机，如果 Session 没有同步，用户会登录失败\n使用 Cookie 就会存在 CSRF（跨域请求伪造） 的风险\n\n❓cookie 删除后，服务端的 session 如何处理？\n根据 Session 机制，如果长时间没有访问，服务器端的 Session 会自动删除（Session 钝化）\n\n¶Cookie-Session 改进\n对于上述存在诸多问题的认证进行改进，得到了另一种基于 Cookie-Session 认证方式。\n\n由于移动应用不能存储 cookie 所以就不存储 cookie 作为用户认证过的标准，web 中可以使用 local storage，APP 中使用客户端数据库，这样既能这样就实现了跨域，并且避免了 CSRF。\n服务端也不存 Session 了，把 Session 信息拿出来存到 Redis 等内存数据库中，这样即提高了速度，又避免了 Session 同步问题\n\n改造之后变成了如下的认证过程：\n\n用户输入用户名、密码或者用短信验证码方式登录系统；\n服务端经过验证，将认证信息构造好的数据结构存储到 Redis 中，并将 key 值返回给客户端；\n客户端拿到返回的 key，存储到 local storage 或本地数据库；\n下次客户端再次请求，把 key 值附加到 header 或者 请求体中；\n服务端根据获取的 key，到 Redis 中获取认证信息\n📖这种改进之后的 Cookie-Session 认证方式是一种思想，JWT 就是这种思想的一种具体实现，在下文会详细讲解 JWT\n\n¶HTTP Basic Auth\nHTTP Basic Auth 就是每次请求 API 时都提供用户的 username 和 password。Basic Auth 是配合 RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于存在用户名密码暴露给第三方客户端的风险（仅使用 Base64 编码），在生产环境下被使用的越来越少。因此，在开发对外开放的 RESTful API 时，尽量避免采用 HTTP Basic Auth\n¶OAuth\nOAuth（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一 web 服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。\nOAuth 允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的 2 小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth 让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容这种基于 OAuth 的认证机制适用于个人消费者类的互联网产品，如社交类 APP 等应用，但是不太适合拥有自有认证权限管理的企业应用\n¶Token Auth\n基于 token 的鉴权机制类似于 http 协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于 token 认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利\n\n⛵大概的流程是这样的：\n\n客户端使用用户名和密码请求登录\n服务端收到请求，验证用户名与密码\n验证成功后，服务端会签发一个 Token，再把此 Token 发送给客户端\n客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里\n客户端每次向服务端请求资源的时候需要带着服务端签发的 Token\n服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据\n\n👍Token Auth 的优点\n\n支持跨域访问：Cookie 是不允许垮域访问的，这一点对 Token 机制不存在。前提是传输的用户认证信息通过 HTTP 头传输\n无状态(也称：服务端可扩展行)：Token 机制在服务端不需要存储 session 信息，因为 Token 自身包含了所有登录用户的信息，只需要在客户端的 cookie 或本地介质存储状态信息\n更适用 CDN: 可以通过内容分发网络请求服务端的所有资料（如：javascript，HTML,图片等），而服务端只要提供 API 即可\n去耦: 不需要绑定到一个特定的身份验证方案，Token 可以在任何地方生成，只要在 API 被调用的时候，可以进行 Token 生成调用即可\n更适用于移动应用: 当客户端是一个原生平台（iOS, Android，Windows 8 等）时，Cookie 是不被支持的（需要通过 Cookie 容器进行处理），这时采用 Token 认证机制就会简单得多\nCSRF：因为不再依赖于 Cookie，所以就不需要考虑对 CSRF（跨站请求伪造）的防范\n性能: 一次网络往返时间（通过数据库查询 session 信息）总比做一次 HMACSHA256 计算的 Token 验证和解析要费时得多\n不需要为登录页面做特殊处理: 如果使用 Protractor 做功能测试的时候，不再需要为登录页面做特殊处理\n基于标准化：你的 API 可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby,Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）\n\n\ntoken 必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *\n¶JWT\nJWT 全称是 JSON Web Token，是目前非常流行的跨域认证解决方案，在单点登录场景中经常使用到，然而使用者对 JWT 的评价褒贬不一。JWT 就是一种 Cookie-Session 改造版的具体实现，JWT 还有个好处，可以不用在服务端存储认证信息，完全由客户端提供，服务端只要根据 JWT 自身提供的解密算法就可以验证用户合法性，而且这个过程是安全的\n✨JWT 有如下特点\n\nJWT 脱离了 session 的束缚，服务端不需要再维持 session 状态，但也无法控制 token 的状态，JWT 一旦签发，在到期之前始终有效，除非服务器有额外的验证逻辑\nJWT 可以很方便的支持跨域\nJWT 本身包含了验证信息，如果发生泄漏，任何人都可以使用令牌的权限进行请求\nJWT 本身不加密，需要通过更安全的 HTTPS 协议传输\n\n¶JWT 数据结构\nJWT 最后的形式就是个字符串，它由头部、负载与签名这三部分组成，中间以.分隔。像下面这样：\n\n¶头部\n头部以 JSON 格式表示，用于指明令牌类型和加密算法\n\n例如下面的这个例子，表示使用 JWT 格式，加密算法采用 HS256，对应上图的红色 header 部分，需要 Base64 编码\n1234&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;\n¶负载\n用来存储服务器需要的数据，比如用户信息，例如姓名、性别、年龄等，要注意的是重要的机密信息最好不要放到这里，比如密码等\n1234&#123;  &quot;name&quot;: &quot;pineapple-man&quot;,  &quot;age&quot;: &quot;23&quot;&#125;\n另外，JWT 还规定了 7 个字段供开发者选用，这部分信息也是需要用 Base64 进行编码的\n\n\n\n规定字段\n含义\n\n\n\n\niss (issuer)\n签发人\n\n\nexp (expiration time)\n过期时间\n\n\nsub (subject)\n主题\n\n\naud (audience)\n受众\n\n\nnbf (Not Before)\n生效时间\n\n\niat (Issued At)\n签发时间\n\n\njti (JWT ID)\n编号\n\n\n\n¶签名\n签名使用HMACSHA256算法计算得出，这个方法有两个参数，前一个参数是 （base64 编码的头部 + base64 编码的负载）用点号相连，后一个参数是自定义的字符串密钥（密钥不要暴露给客户端，应该只有服务器知道）\n12345HMACSHA256(  base64UrlEncode(header) + &quot;.&quot; +  base64UrlEncode(payload),  Secret)\n¶使用方式\n⛵JWT 使用步骤如下\n\n\n在用户登录网站的时候，需要输入用户名、密码或者短信验证的方式登录，登录请求到达服务端的时候，服务端对账号、密码进行验证，然后计算出 JWT 字符串，返回给客户端\n\n\n客户端拿到这个 JWT 字符串后，存储到 cookie 或者 浏览器的 LocalStorage 中\n\n\n再次发送请求，比如请求用户设置页面的时候，在 HTTP 请求头中加入 JWT 字符串，或者直接放到请求主体中\n\n\n服务端拿到这串 JWT 字符串后，解密 base64 的头部和 base64 的负载部分，随后根据头部提到的哈希算法，计算出头部和负载部分的摘要。比较计算结果和传来的签名部分是否一致，如果一致，说明此次请求没有问题，如果不一致，说明请求过期或者是非法请求\n\n\n使用 JWT 方式进行初次登录的流程如下：\n\n用户登录过一次之后，再次登录的过程如下：\n\n¶FAQ\n❓JWT 为什么可以完全依靠客户端就能实现认证功能，认证信息全部存在客户端，怎么保证安全性？\n¶为什么 JWT 是安全的？\n保证安全性的关键就是 HMACSHA256 或者与它同类型的哈希算法，因为哈希过程是不可逆的，所以不能根据传到前端的 JWT 字符串反解到密钥信息；另一方面，不同的头部和负载加密之后得到的签名是不同的，所以，如果有人改了负载部分的信息，那最后加密出的结果肯定就和改之前的不一样的，所以，最后验证的结果就是不合法的请求\n¶JWT 如何抵御中间人等攻击？\n假设载荷部分存储了权限级别相关的字段，攻击者拿到了 JWT 后修改为更高权限的级别，这种情况肯定是不会得逞的，因为之前说的哈希特性能够保证\n但是如果攻击拿到了 JWT 后，不进行修改直接使用，仍然会出现安全问题，所以为了避免 JWT 信息泄露，应当使用 HTTPS 协议而不是 HTTP 协议，这样可以有效的防止中间劫持攻击\n¶弊端\nJWT 有个问题，导致很多开发团队放弃使用它，那就是一旦颁发一个 JWT 令牌，服务端就没办法废弃掉它，除非等到它自身过期。有很多应用默认只允许最新登录的一个客户端正常使用，不允许多端登录，JWT 就没办法做到，因为颁发了新令牌，但是老的令牌在过期前仍然可用。这种情况下，就需要服务端增加相应的逻辑\n¶附录\n『JWT』，你必须了解的认证登录方案\nJWT 认证方案学习\n什么是 JWT – JSON WEB TOKEN\nRFC7519\n","dateCreated":"2021-11-25T12:27:32+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2021-11-25T12:27:32+00:00","description":"用户认证","headline":"认证解决方案","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/%E8%AE%A4%E8%AF%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/%E8%AE%A4%E8%AF%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","keywords":"安全"}</script><meta name="description" content="用户认证"><meta property="og:type" content="blog"><meta property="og:title" content="认证解决方案"><meta property="og:url" content="https://pineapple-man.github.io/%E8%AE%A4%E8%AF%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="用户认证"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/cookie%E8%AE%A4%E8%AF%81.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/advanceCookie%E8%AE%A4%E8%AF%81.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/jwt.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/jwt%E5%88%9D%E6%AC%A1%E7%99%BB%E5%BD%95.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/jwt%E5%86%8D%E6%AC%A1%E7%99%BB%E5%BD%95.png"><meta property="article:published_time" content="2021-11-25T12:27:32.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.003Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="安全"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/cookie%E8%AE%A4%E8%AF%81.jpg"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">认证解决方案</h1><div class="post-meta"><time datetime="2021-11-25T12:27:32+00:00">11月 25, 2021 </time><span>发布在 </span><a class="category-link" href="/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">解决方案</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 3.5k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 32 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6"><span class="toc-text">常见的认证机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F-Cookie-Auth"><span class="toc-text">传统 Cookie Auth</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%81%E8%AF%A6%E8%BF%B0"><span class="toc-text">认证详述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-Session-%E6%94%B9%E8%BF%9B"><span class="toc-text">Cookie-Session 改进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-Basic-Auth"><span class="toc-text">HTTP Basic Auth</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OAuth"><span class="toc-text">OAuth</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Token-Auth"><span class="toc-text">Token Auth</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JWT"><span class="toc-text">JWT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">JWT 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E9%83%A8"><span class="toc-text">头部</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD"><span class="toc-text">负载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%BE%E5%90%8D"><span class="toc-text">签名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FAQ"><span class="toc-text">FAQ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-JWT-%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">为什么 JWT 是安全的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT-%E5%A6%82%E4%BD%95%E6%8A%B5%E5%BE%A1%E4%B8%AD%E9%97%B4%E4%BA%BA%E7%AD%89%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">JWT 如何抵御中间人等攻击？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%8A%E7%AB%AF"><span class="toc-text">弊端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol><h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><p>❓什么是认证</p><div class="alert success no-icon"><p>认证就是证明真身的过程</p></div><div class="alert warning no-icon"><p>有下面这样一个场景：在平时使用某宝或者某东时，如果尼想要下单，首先需要注册一个账号，拥有了账号之后，需要输入用户名和密码完成登录过程，这里用户输入用户名和密码请求登录系统的过程就是用户认证的过程</p></div><h2 id="常见的认证机制"><a class="header-anchor" href="#常见的认证机制">¶</a>常见的认证机制</h2><p>有五种常见的认证机制：HTTP Basic Auth、Cookie Auth、OAuth、Token Auth 和 JWT，其中目前最常用的就是 JWT，本文也将详细阐述 JWT 的相关概念</p><h2 id="传统-Cookie-Auth"><a class="header-anchor" href="#传统-Cookie-Auth">¶</a>传统 Cookie Auth</h2><p>早期互联网以 web 为主，客户端是浏览器 ，所以 Cookie-Session 方式是早期最常用的认证方式，直到现在，一些 web 网站依然用这种方式做认证</p><h3 id="认证详述"><a class="header-anchor" href="#认证详述">¶</a>认证详述</h3><p>Cookie 认证机制是：每当服务器收到一个请求认证时，就创建一个 Session 对象，同时在客户端的浏览器端创建一个 Cookie 对象；通过客户端带上来 Cookie 对象来与服务器端的 Session 对象匹配来实现<strong>状态管理</strong>的。默认当关闭浏览器的时候，cookie 会被删除，可以通过修改 cookie 的 expire time 使 cookie 永不失效</p><ol><li>用户输入用户名、密码或者用短信验证码方式登录系统</li><li>服务端验证后，创建一个 Session 信息，并且将 SessionID 存到 cookie，发送回浏览器</li><li>下次客户端再发起请求，自动带上 cookie 信息，服务端通过 cookie 获取 Session 信息进行校验<div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/cookie认证.jpg" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/cookie认证.jpg" alt=""></a></div></li></ol><p>对于处于移动互联网，这样的方式不太适合，主要存在以下几个问题：</p><ol><li>Cookie-Session 只能在 web 场景下使用，APP 不能存储 cookie，所以造成，现在的产品基本上都同时提供 web 端和 APP 两种使用方式，有点产品甚至只有 APP</li><li>就是单独的 web 客户端使用 cookie 认证，也存在问题：请求跨域十分常见，但是 Cookie 是不能跨域的</li><li>如今的系统大部分都是分布式系统，一旦使用 Cookie 就需要考虑 Session 的同步问题，相同的请求有可能被负载均衡器将请求分发到不同的主机，如果 Session 没有同步，用户会登录失败</li><li>使用 Cookie 就会存在 CSRF（跨域请求伪造） 的风险</li></ol><p>❓cookie 删除后，服务端的 session 如何处理？</p><div class="alert success no-icon"><p>根据 Session 机制，如果长时间没有访问，服务器端的 Session 会自动删除（Session 钝化）</p></div><h3 id="Cookie-Session-改进"><a class="header-anchor" href="#Cookie-Session-改进">¶</a>Cookie-Session 改进</h3><p>对于上述存在诸多问题的认证进行改进，得到了另一种基于 Cookie-Session 认证方式。</p><ul><li>由于移动应用不能存储 cookie 所以就不存储 cookie 作为用户认证过的标准，web 中可以使用 local storage，APP 中使用客户端数据库，这样既能这样就实现了跨域，并且避免了 CSRF。</li><li>服务端也不存 Session 了，把 Session 信息拿出来存到 Redis 等内存数据库中，这样即提高了速度，又避免了 Session 同步问题</li></ul><p>改造之后变成了如下的认证过程：</p><ol><li>用户输入用户名、密码或者用短信验证码方式登录系统；</li><li>服务端经过验证，将认证信息构造好的数据结构存储到 Redis 中，并将 key 值返回给客户端；</li><li>客户端拿到返回的 key，存储到 local storage 或本地数据库；</li><li>下次客户端再次请求，把 key 值附加到 header 或者 请求体中；</li><li>服务端根据获取的 key，到 Redis 中获取认证信息<div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/advanceCookie认证.jpg" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/advanceCookie认证.jpg" alt=""></a></div>📖这种改进之后的 Cookie-Session 认证方式是一种思想，JWT 就是这种思想的一种具体实现，在下文会详细讲解 JWT</li></ol><h2 id="HTTP-Basic-Auth"><a class="header-anchor" href="#HTTP-Basic-Auth">¶</a>HTTP Basic Auth</h2><p>HTTP Basic Auth 就是每次请求 API 时都提供用户的 username 和 password。Basic Auth 是配合 RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于存在用户名密码暴露给第三方客户端的风险（仅使用 Base64 编码），在生产环境下被使用的越来越少。因此，在开发对外开放的 RESTful API 时，尽量避免采用 HTTP Basic Auth</p><h2 id="OAuth"><a class="header-anchor" href="#OAuth">¶</a>OAuth</h2><p>OAuth（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一 web 服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。</p><p>OAuth 允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的 2 小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth 让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容这种基于 OAuth 的认证机制适用于个人消费者类的互联网产品，如社交类 APP 等应用，但是不太适合拥有自有认证权限管理的企业应用</p><h2 id="Token-Auth"><a class="header-anchor" href="#Token-Auth">¶</a>Token Auth</h2><div class="alert success no-icon"><p>基于 token 的鉴权机制类似于 http 协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于 token 认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利</p></div><p>⛵大概的流程是这样的：</p><ol><li>客户端使用用户名和密码请求登录</li><li>服务端收到请求，验证用户名与密码</li><li>验证成功后，服务端会签发一个 Token，再把此 Token 发送给客户端</li><li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li></ol><p>👍Token Auth 的优点</p><div class="alert success no-icon"><ul><li>支持跨域访问：Cookie 是不允许垮域访问的，这一点对 Token 机制不存在。前提是传输的用户认证信息通过 HTTP 头传输</li><li>无状态(也称：服务端可扩展行)：Token 机制在服务端不需要存储 session 信息，因为 Token 自身包含了所有登录用户的信息，只需要在客户端的 cookie 或本地介质存储状态信息</li><li>更适用 CDN: 可以通过内容分发网络请求服务端的所有资料（如：javascript，HTML,图片等），而服务端只要提供 API 即可</li><li>去耦: 不需要绑定到一个特定的身份验证方案，Token 可以在任何地方生成，只要在 API 被调用的时候，可以进行 Token 生成调用即可</li><li>更适用于移动应用: 当客户端是一个原生平台（iOS, Android，Windows 8 等）时，Cookie 是不被支持的（需要通过 Cookie 容器进行处理），这时采用 Token 认证机制就会简单得多</li><li>CSRF：因为不再依赖于 Cookie，所以就不需要考虑对 CSRF（跨站请求伪造）的防范</li><li>性能: 一次网络往返时间（通过数据库查询 session 信息）总比做一次 HMACSHA256 计算的 Token 验证和解析要费时得多</li><li>不需要为登录页面做特殊处理: 如果使用 Protractor 做功能测试的时候，不再需要为登录页面做特殊处理</li><li>基于标准化：你的 API 可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby,Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）</li></ul></div><p>token 必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持<code>CORS(跨来源资源共享)</code>策略，一般我们在服务端这么做就可以了<code>Access-Control-Allow-Origin: *</code></p><h2 id="JWT"><a class="header-anchor" href="#JWT">¶</a>JWT</h2><p>JWT 全称是 JSON Web Token，是目前非常流行的跨域认证解决方案，在单点登录场景中经常使用到，然而使用者对 JWT 的评价褒贬不一。JWT 就是一种 Cookie-Session 改造版的具体实现，JWT 还有个好处，<strong>可以不用在服务端存储认证信息</strong>，完全由客户端提供，服务端只要根据 JWT 自身提供的解密算法就可以验证用户合法性，而且这个过程是安全的</p><p>✨JWT 有如下特点</p><ul><li>JWT 脱离了 session 的束缚，服务端不需要再维持 session 状态，但也无法控制 token 的状态，JWT 一旦签发，在到期之前始终有效，除非服务器有额外的验证逻辑</li><li>JWT 可以很方便的支持跨域</li><li>JWT 本身包含了验证信息，如果发生泄漏，任何人都可以使用令牌的权限进行请求</li><li>JWT 本身不加密，需要通过更安全的 HTTPS 协议传输</li></ul><h3 id="JWT-数据结构"><a class="header-anchor" href="#JWT-数据结构">¶</a>JWT 数据结构</h3><p>JWT 最后的形式就是个字符串，它由<strong>头部</strong>、<strong>负载</strong>与<strong>签名</strong>这三部分组成，中间以<code>.</code>分隔。像下面这样：</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/jwt.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/jwt.png" alt=""></a></div><h4 id="头部"><a class="header-anchor" href="#头部">¶</a>头部</h4><div class="alert success no-icon"><p>头部以 JSON 格式表示，用于指明令牌类型和加密算法</p></div><p>例如下面的这个例子，表示使用 JWT 格式，加密算法采用 HS256，对应上图的红色 header 部分，需要 Base64 编码</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="负载"><a class="header-anchor" href="#负载">¶</a>负载</h4><p>用来存储服务器需要的数据，比如用户信息，例如姓名、性别、年龄等，要注意的是重要的机密信息最好不要放到这里，比如密码等</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pineapple-man&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="string">&quot;23&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>另外，JWT 还规定了 7 个字段供开发者选用，这部分信息也是需要用 Base64 进行编码的</p><table><thead><tr><th style="text-align:center">规定字段</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>iss (issuer)</code></td><td style="text-align:center">签发人</td></tr><tr><td style="text-align:center"><code>exp (expiration time)</code></td><td style="text-align:center">过期时间</td></tr><tr><td style="text-align:center"><code>sub (subject)</code></td><td style="text-align:center">主题</td></tr><tr><td style="text-align:center"><code>aud (audience)</code></td><td style="text-align:center">受众</td></tr><tr><td style="text-align:center"><code>nbf (Not Before)</code></td><td style="text-align:center">生效时间</td></tr><tr><td style="text-align:center"><code>iat (Issued At)</code></td><td style="text-align:center">签发时间</td></tr><tr><td style="text-align:center"><code>jti (JWT ID)</code></td><td style="text-align:center">编号</td></tr></tbody></table><h4 id="签名"><a class="header-anchor" href="#签名">¶</a>签名</h4><p>签名使用<code>HMACSHA256</code>算法计算得出，这个方法有两个参数，前一个参数是 （base64 编码的头部 + base64 编码的负载）用点号相连，后一个参数是自定义的字符串密钥（密钥不要暴露给客户端，应该只有服务器知道）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  Secret</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="使用方式"><a class="header-anchor" href="#使用方式">¶</a>使用方式</h3><p>⛵JWT 使用步骤如下</p><ol><li><p>在用户登录网站的时候，需要输入用户名、密码或者短信验证的方式登录，登录请求到达服务端的时候，服务端对账号、密码进行验证，然后计算出 JWT 字符串，返回给客户端</p></li><li><p>客户端拿到这个 JWT 字符串后，存储到 cookie 或者 浏览器的 LocalStorage 中</p></li><li><p>再次发送请求，比如请求用户设置页面的时候，在 HTTP 请求头中加入 JWT 字符串，或者直接放到请求主体中</p></li><li><p>服务端拿到这串 JWT 字符串后，解密 base64 的头部和 base64 的负载部分，随后根据头部提到的哈希算法，计算出头部和负载部分的摘要。比较计算结果和传来的签名部分是否一致，如果一致，说明此次请求没有问题，如果不一致，说明请求过期或者是非法请求</p></li></ol><p>使用 JWT 方式进行初次登录的流程如下：</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/jwt初次登录.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/jwt初次登录.png" alt=""></a></div><p>用户登录过一次之后，再次登录的过程如下：</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/jwt再次登录.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/jwt再次登录.png" alt=""></a></div><h3 id="FAQ"><a class="header-anchor" href="#FAQ">¶</a>FAQ</h3><p>❓JWT 为什么可以完全依靠客户端就能实现认证功能，认证信息全部存在客户端，怎么保证安全性？</p><h4 id="为什么-JWT-是安全的？"><a class="header-anchor" href="#为什么-JWT-是安全的？">¶</a>为什么 JWT 是安全的？</h4><p>保证安全性的关键就是 <code>HMACSHA256</code> 或者与它同类型的哈希算法，因为哈希过程是不可逆的，所以不能根据传到前端的 JWT 字符串反解到密钥信息；另一方面，不同的头部和负载加密之后得到的签名是不同的，所以，如果有人改了负载部分的信息，那最后加密出的结果肯定就和改之前的不一样的，所以，最后验证的结果就是不合法的请求</p><h4 id="JWT-如何抵御中间人等攻击？"><a class="header-anchor" href="#JWT-如何抵御中间人等攻击？">¶</a>JWT 如何抵御中间人等攻击？</h4><p>假设载荷部分存储了权限级别相关的字段，攻击者拿到了 JWT 后修改为更高权限的级别，这种情况肯定是不会得逞的，因为之前说的哈希特性能够保证</p><p>但是如果攻击拿到了 JWT 后，不进行修改直接使用，仍然会出现安全问题，所以为了避免 JWT 信息泄露，应当使用 HTTPS 协议而不是 HTTP 协议，这样可以有效的防止中间劫持攻击</p><h4 id="弊端"><a class="header-anchor" href="#弊端">¶</a>弊端</h4><p>JWT 有个问题，导致很多开发团队放弃使用它，那就是一旦颁发一个 JWT 令牌，服务端就没办法废弃掉它，除非等到它自身过期。有很多应用默认只允许最新登录的一个客户端正常使用，不允许多端登录，JWT 就没办法做到，因为颁发了新令牌，但是老的令牌在过期前仍然可用。这种情况下，就需要服务端增加相应的逻辑</p><h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fengzheng/p/13527425.html">『JWT』，你必须了解的认证登录方案</a><br><a target="_blank" rel="noopener" href="https://www.helloworld.net/p/7249906346">JWT 认证方案学习</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/576dbf44b2ae">什么是 JWT – JSON WEB TOKEN</a><br><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7519">RFC7519</a></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/%E5%AE%89%E5%85%A8/" rel="tag">安全</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/aop%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/" data-tooltip="AOP——面向切面编程" aria-label="上一篇: AOP——面向切面编程"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/" data-tooltip="随机算法" aria-label="下一篇: 随机算法"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/aop%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/" data-tooltip="AOP——面向切面编程" aria-label="上一篇: AOP——面向切面编程"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/" data-tooltip="随机算法" aria-label="下一篇: 随机算法"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>