<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>Java TCP/IP Socket 编程（一）基本套接字 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="网络"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n¶网络基础\n✨ UDP(用户数据包协议)，明显的特点如下：\n\n将数据打包(最大不超过 64K)\n不建立连接\n速度快\n不可靠\n\n\n✨ TCP 协议，具有如下特点：\n\n建立连接通道\n数据无限制\n速度慢\n可靠\n\n\nsocket（套接字）是一种抽象层，应用程序通过它来发送和接受数据，就像应用程序打开一个文件句柄，将数据读写到稳定的存储器上一样。使用 socket 可以将应用程序添加到网络中，并与处于同一个网络中的其他应用程序进行通信。一台计算机上的应用程序向 socket 写入的信息能够被另一台计算机上的另一个应用程序读取，反之亦然。\n不同类型的 socket 与不同类型的底层协议族以及同一协议族中的不同协议栈相关联，目前 TCP/IP 协议族中的主要 socket 类型为 流套接字（stream socket）和数据包套接字（datagram socket）\n\n流套接字将 TCP 作为其端对端协议（底层使用 IP 协议），提供了一个可信赖的字节流服务。一个 TCP/IP 流套接字代表了 TCP 连接的一端\n数据报套接字使用 UDP 协议（底层同样适用 IP 协议），提供了一个 best-effort 的数据报服务，应用程序可以通过它发送最长 65500 字节的信息。\n\n\n一个 TCP/IP 套接字由一个互联网地址，一个端对端协议（TCP 协议或 UDP 协议）以及一个端口号唯一确定，下图描述了一个主机中，应用程序、套接字抽象层、协议、端口号之间的逻辑关系。一个套接字抽象层可以被多个应用程序引用。\n\nSocket 具有如下特点：\n\n通信的两端都有socket\n网络通信其实就是 Socket 间的通信\n数据在两个 Socket 间通过 IO 流传输数据\n\n\nJava Socket 常见操作\n\n¶InetAddress 类\nInetAddress 类代表了一个网络目标地址，包括主机名和数字类型的地址信息。该类有两个子类：Inet4Address和Inet6Address\n此类主要进行 IP 地址相关操作，此类没有可以访问的构造方法\n一个类没有可以访问的构造方法,可能是如下三种情况:\n\n成员全部都是静态的(Math,Arrays,Collections)\n单例模式(Runtime 类)\n类中有静态方法返回该类的对象(InetAddress)\n\n\n¶成员方法\n12345678//根据主机名或者IP地址的字符串得到IP地址对象,此对象包含主机名以及IP地址的信息public static InetAddress getByName(String host)throws UnknownHostException;//获取本机Hostname以及IPpublic static InetAddress getLocalHost()throws UnknownHostException;//获取本机主机名public String getHostName();//获取本机IPpublic String getHostAddress();\n不知道任何信息时，得到当前主机的主机名以及 IP 地址\n123456789101112131415public static void main(String[] args) &#123;  try &#123;    InetAddress inetAddress = InetAddress.getLocalHost();    //将显示运行当前程序的”主机名/IP地址“    System.out.println(inetAddress);    //获取主机地址    String IP = InetAddress.getLocalHost().getHostAddress();    System.out.println(IP);    //获取主机名    String name = InetAddress.getLocalHost().getHostName();    System.out.println(name);  &#125; catch (UnknownHostException e) &#123;    e.printStackTrace();  &#125;&#125;\n知道主机名或者 IP 地址得到另一个信息\n1234//由主机名或者IP获得当前InetAddress对象InetAddress address = InetAddress.getByName(&quot;Hostname&quot;);System.out.println(address.getHostName());System.out.println(address.getHostAddress());\n¶UDP 相关 API\n本小节主要记录与 UDP 相关的 API，不涉及数据质量要求时，UDP 使用的还是非常多的。Java 中与 UDP 相关的主要是如下两个类：DatagramSocket和DatagramPacket\n¶DatagramSocket\n是 UDPSocket 的主要类\n¶构造方法\n1234//常用无参构造方法DatagramSocket();DatagramSocket(int port);DatagramSocket(int port, InetAddress laddr);\n¶成员方法\n12345678910//将 UDPSocket 绑定到明确的 socket 对象上public void bind(SocketAddress addr)throws SocketException;public void disconnect();public boolean isBound();public boolean isConnected();public boolean isClosed();//采用 UDP 协议发送数据public void send(DatagramPacket p)throws IOException;//接受 UDP 协议发送来的数据，阻塞式public void receive(DatagramPacket p)throws IOException;\n¶DatagramPacket\nUDP 数据包对象，在 UDP 通信时，打包 UDP 发送的数据\n¶构造方法\n1234//接收方初始化DatagramPacket(byte[] buf,int length);//发送方初始化方式，指明接收方 Socket(IP,port),数据包以及数据长度DatagramPacket(byte[] buf, int length, InetAddress address, int port);\n¶成员方法\n123456//返回此数据包的IP地址来源public InetAddress getAddress();//接收方调用返回接受端接受数据的端口号；发送方调用返回发送方的发送端口public int getPort();//返回发生数据的长度或者接受到的数据的长度public int getLength();\n¶发送数据步骤\n主要步骤如下:\n\n创建发送端 Socket 对象\n创建数据,并把数据打包\n调用 Socket 对象的发送方法发送数据包\n释放资源\n\n\n1234567891011//创建一个UDPSocket对象DatagramSocket datagramSocket = new DatagramSocket();byte[] bytes = &quot;hello,udp,java&quot;.getBytes();//数据打包DatagramPacket datagramPacket =  //指定 localhost:10086 发送 udp 数据包\tnew DatagramPacket(bytes, bytes.length, InetAddress.getLocalHost(), 10086);//发送数据datagramSocket.send(datagramPacket);//关闭Socket对象，释放资源datagramSocket.close();\n¶接受数据步骤\nUDP 接受数据步骤：\n\n创建接收端 Socket 对象\n创建一个数据包(接受容器)\n调用 Socket 对象的接收方法接受数据\n解析数据包，并显示在控制台\n释放资源\n\n\n123456789101112131415public static void main(String[] args) throws IOException &#123;  // 创建接受端 Socket 对象  DatagramSocket datagramSocket = new DatagramSocket(10086);  // 创建接受端数据包  byte[] bytes = new byte[1024];  DatagramPacket datagramPacket = new DatagramPacket(bytes, bytes.length);  // 调用Socket对象的接受方法  datagramSocket.receive(datagramPacket);  // 解析数据  String address = datagramPacket.getAddress().getHostAddress();  String data = new String(datagramPacket.getData(), 0, datagramPacket.getLength());  System.out.println(address + &quot;data is :&quot; + data);  // 释放资源  datagramSocket.close();&#125;\n¶TCP 相关 API\nTCP 协议中的发送数据方称为客户端(Client)，接收数据方称为服务端(Server)\n¶Client 方 API\nTCP 协议 Client 端的 Socket 对象\n¶构造方法\n123Socket();//创建一个未建立连接的SocketSocket(InetAddress address, int port);//创建一个&lt;address,port&gt;建立连接的socket对象Socket(String host, int port);//host可以是ip地址的格式\n¶成员方法\n123456//获取当前TCP数据流,而后使用I/O流写数据public OutputStream getOutputStream()throws IOException;public InputStream getInputStream()throws IOException;public InetAddress getInetAddress();public void shutdownInput()throws IOException;public void shutdownOutput()throws IOException;\n¶TCP 报文接受数据步骤\n\n创建接受端的 Socket 对象\n监听客户端,返回一个对应的 Socket 对象\n获取输入流，读取数据显示在控制台\n释放资源\n\n\n123456789101112131415public static void main(String[] args) throws IOException &#123;  //创建接受端的Socket对象  ServerSocket serverSocket = new ServerSocket(10086);  //侦听并接受此套接字，此方法在连接建立之前一直阻塞\tSocket accept = serverSocket.accept();  //获取输入流  InputStream inputStream = accept.getInputStream();  byte[] bytes = new byte[1024];  //阻塞式方法  int len = inputStream.read(bytes);  System.out.println(\taccept.getInetAddress().getHostAddress() + &quot;-----&quot; + new String(bytes, 0, len));  //释放资源  accept.close();&#125;\n¶Server 方 API\nTCP 协议 Server 端 Socket 对象\n¶构造方法\n12345//创建一个没有绑定的服务端SocketServerSocket();//创建一个本机监听特定端口的服务器端SocketServerSocket(int port);\n¶成员方法\n1234//监听客户端，返回一个对应的Socket对象public Socket accept()throws IOException;//获取当前Socket对象的输入流数据public InputStream getInputStream()throws IOException;\n¶TCP 报文发送流程\n\n创建发送端的 Socket 对象，这一步如果成功，说明连接已经建立成功\n获取数据流，写数据\n释放资源\n\n\n🎶java.net.ConnectException：连接被拒绝，TCP 协议一定要先打开服务器，而后发送数据，否则连接建立失败\n12345678public static void main(String[] args) throws IOException &#123;  // 创建 TCPsocket 对象  Socket socket = new Socket(InetAddress.getLocalHost(), 10086);  // 获取输出数据流  OutputStream outputStream = socket.getOutputStream();  outputStream.write(&quot;hello tcp !&quot;.getBytes());  socket.close();&#125;\n","dateCreated":"2021-12-31T14:44:02+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2021-12-31T14:44:02+00:00","description":"Java 作为应用层程序，并不会与 C 一样，与协议接触的非常紧凑，并且本章主要是对 Java 中基本套接字的学习","headline":"Java TCP/IP Socket 编程（一）基本套接字","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/java-tcp-ip-socket-%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E5%A5%97%E6%8E%A5%E5%AD%97/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/java-tcp-ip-socket-%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E5%A5%97%E6%8E%A5%E5%AD%97/","keywords":"JDK"}</script><meta name="description" content="Java 作为应用层程序，并不会与 C 一样，与协议接触的非常紧凑，并且本章主要是对 Java 中基本套接字的学习"><meta property="og:type" content="blog"><meta property="og:title" content="Java TCP&#x2F;IP Socket 编程（一）基本套接字"><meta property="og:url" content="https://pineapple-man.github.io/java-tcp-ip-socket-%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E5%A5%97%E6%8E%A5%E5%AD%97/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="Java 作为应用层程序，并不会与 C 一样，与协议接触的非常紧凑，并且本章主要是对 Java 中基本套接字的学习"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/20220109001727.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/Java-io-socket.jpeg"><meta property="article:published_time" content="2021-12-31T14:44:02.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.015Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="JDK"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/20220109001727.png"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">Java TCP/IP Socket 编程（一）基本套接字</h1><div class="post-meta"><time datetime="2021-12-31T14:44:02+00:00">12月 31, 2021 </time><span>发布在 </span><a class="category-link" href="/categories/Java/">Java</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 1.9k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 19 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="toc-text">网络基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InetAddress-%E7%B1%BB"><span class="toc-text">InetAddress 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">成员方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP-%E7%9B%B8%E5%85%B3-API"><span class="toc-text">UDP 相关 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DatagramSocket"><span class="toc-text">DatagramSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-v2"><span class="toc-text">成员方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DatagramPacket"><span class="toc-text">DatagramPacket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-v2"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-v3"><span class="toc-text">成员方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E6%AD%A5%E9%AA%A4"><span class="toc-text">发送数据步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97%E6%95%B0%E6%8D%AE%E6%AD%A5%E9%AA%A4"><span class="toc-text">接受数据步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E7%9B%B8%E5%85%B3-API"><span class="toc-text">TCP 相关 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Client-%E6%96%B9-API"><span class="toc-text">Client 方 API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-v3"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-v4"><span class="toc-text">成员方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E6%8A%A5%E6%96%87%E6%8E%A5%E5%8F%97%E6%95%B0%E6%8D%AE%E6%AD%A5%E9%AA%A4"><span class="toc-text">TCP 报文接受数据步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Server-%E6%96%B9-API"><span class="toc-text">Server 方 API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-v4"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-v5"><span class="toc-text">成员方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E6%8A%A5%E6%96%87%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B"><span class="toc-text">TCP 报文发送流程</span></a></li></ol></li></ol></li></ol><h2 id="网络基础"><a class="header-anchor" href="#网络基础">¶</a>网络基础</h2><p>✨ UDP(用户数据包协议)，明显的特点如下：</p><div class="alert success no-icon"><ul><li>将数据打包(最大不超过 64K)</li><li>不建立连接</li><li>速度快</li><li>不可靠</li></ul></div><p>✨ TCP 协议，具有如下特点：</p><div class="alert success no-icon"><ul><li>建立连接通道</li><li>数据无限制</li><li>速度慢</li><li>可靠</li></ul></div><p>socket（套接字）是一种抽象层，应用程序通过它来发送和接受数据，就像应用程序打开一个文件句柄，将数据读写到稳定的存储器上一样。使用 socket 可以将应用程序添加到网络中，并与处于同一个网络中的其他应用程序进行通信。一台计算机上的应用程序向 socket 写入的信息能够被另一台计算机上的另一个应用程序读取，反之亦然。</p><p>不同类型的 socket 与不同类型的底层协议族以及同一协议族中的不同协议栈相关联，目前 TCP/IP 协议族中的主要 socket 类型为 流套接字（stream socket）和数据包套接字（datagram socket）</p><div class="alert info no-icon"><ul><li>流套接字将 TCP 作为其端对端协议（底层使用 IP 协议），提供了一个可信赖的字节流服务。一个 TCP/IP 流套接字代表了 TCP 连接的一端</li><li>数据报套接字使用 UDP 协议（底层同样适用 IP 协议），提供了一个 best-effort 的数据报服务，应用程序可以通过它发送最长 65500 字节的信息。</li></ul></div><p>一个 TCP/IP 套接字由一个互联网地址，一个端对端协议（TCP 协议或 UDP 协议）以及一个端口号唯一确定，下图描述了一个主机中，应用程序、套接字抽象层、协议、端口号之间的逻辑关系。<span class="highlight-text red">一个套接字抽象层可以被多个应用程序引用。</span></p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/20220109001727.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/20220109001727.png" alt=""></a></div><p>Socket 具有如下特点：</p><div class="alert success no-icon"><ul><li>通信的两端都有<code>socket</code></li><li>网络通信其实就是 Socket 间的通信</li><li>数据在两个 Socket 间通过 IO 流传输数据</li></ul></div><p>Java Socket 常见操作</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/Java-io-socket.jpeg" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/Java-io-socket.jpeg" alt=""></a></div><h2 id="InetAddress-类"><a class="header-anchor" href="#InetAddress-类">¶</a>InetAddress 类</h2><p>InetAddress 类代表了一个网络目标地址，包括主机名和数字类型的地址信息。该类有两个子类：<code>Inet4Address</code>和<code>Inet6Address</code><br>此类主要进行 IP 地址相关操作，<span class="highlight-text red">此类没有可以访问的构造方法</span></p><p>一个类没有可以访问的构造方法,可能是如下三种情况:</p><div class="alert info no-icon"><ul><li>成员全部都是静态的(Math,Arrays,Collections)</li><li>单例模式(Runtime 类)</li><li>类中有静态方法返回该类的对象(InetAddress)</li></ul></div><h3 id="成员方法"><a class="header-anchor" href="#成员方法">¶</a>成员方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据主机名或者IP地址的字符串得到IP地址对象,此对象包含主机名以及IP地址的信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InetAddress <span class="title function_">getByName</span><span class="params">(String host)</span><span class="keyword">throws</span> UnknownHostException;</span><br><span class="line"><span class="comment">//获取本机Hostname以及IP</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InetAddress <span class="title function_">getLocalHost</span><span class="params">()</span><span class="keyword">throws</span> UnknownHostException;</span><br><span class="line"><span class="comment">//获取本机主机名</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getHostName</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//获取本机IP</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getHostAddress</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>不知道任何信息时，得到当前主机的主机名以及 IP 地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">    <span class="comment">//将显示运行当前程序的”主机名/IP地址“</span></span><br><span class="line">    System.out.println(inetAddress);</span><br><span class="line">    <span class="comment">//获取主机地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">IP</span> <span class="operator">=</span> InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">    System.out.println(IP);</span><br><span class="line">    <span class="comment">//获取主机名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> InetAddress.getLocalHost().getHostName();</span><br><span class="line">    System.out.println(name);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道主机名或者 IP 地址得到另一个信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由主机名或者IP获得当前InetAddress对象</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;Hostname&quot;</span>);</span><br><span class="line">System.out.println(address.getHostName());</span><br><span class="line">System.out.println(address.getHostAddress());</span><br></pre></td></tr></table></figure><h2 id="UDP-相关-API"><a class="header-anchor" href="#UDP-相关-API">¶</a>UDP 相关 API</h2><p>本小节主要记录与 UDP 相关的 API，不涉及数据质量要求时，UDP 使用的还是非常多的。Java 中与 UDP 相关的主要是如下两个类：<code>DatagramSocket</code>和<code>DatagramPacket</code></p><h3 id="DatagramSocket"><a class="header-anchor" href="#DatagramSocket">¶</a>DatagramSocket</h3><p>是 UDPSocket 的主要类</p><h4 id="构造方法"><a class="header-anchor" href="#构造方法">¶</a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用无参构造方法</span></span><br><span class="line">DatagramSocket();</span><br><span class="line">DatagramSocket(<span class="type">int</span> port);</span><br><span class="line">DatagramSocket(<span class="type">int</span> port, InetAddress laddr);</span><br></pre></td></tr></table></figure><h4 id="成员方法-v2"><a class="header-anchor" href="#成员方法-v2">¶</a>成员方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将 UDPSocket 绑定到明确的 socket 对象上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(SocketAddress addr)</span><span class="keyword">throws</span> SocketException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">disconnect</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBound</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isClosed</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//采用 UDP 协议发送数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(DatagramPacket p)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="comment">//接受 UDP 协议发送来的数据，阻塞式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(DatagramPacket p)</span><span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><h3 id="DatagramPacket"><a class="header-anchor" href="#DatagramPacket">¶</a>DatagramPacket</h3><p>UDP 数据包对象，在 UDP 通信时，打包 UDP 发送的数据</p><h4 id="构造方法-v2"><a class="header-anchor" href="#构造方法-v2">¶</a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收方初始化</span></span><br><span class="line">DatagramPacket(<span class="type">byte</span>[] buf,<span class="type">int</span> length);</span><br><span class="line"><span class="comment">//发送方初始化方式，指明接收方 Socket(IP,port),数据包以及数据长度</span></span><br><span class="line">DatagramPacket(<span class="type">byte</span>[] buf, <span class="type">int</span> length, InetAddress address, <span class="type">int</span> port);</span><br></pre></td></tr></table></figure><h4 id="成员方法-v3"><a class="header-anchor" href="#成员方法-v3">¶</a>成员方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回此数据包的IP地址来源</span></span><br><span class="line"><span class="keyword">public</span> InetAddress <span class="title function_">getAddress</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//接收方调用返回接受端接受数据的端口号；发送方调用返回发送方的发送端口</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPort</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//返回发生数据的长度或者接受到的数据的长度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="发送数据步骤"><a class="header-anchor" href="#发送数据步骤">¶</a>发送数据步骤</h3><p>主要步骤如下:</p><div class="alert warning no-icon"><ol><li>创建发送端 Socket 对象</li><li>创建数据,并把数据打包</li><li>调用 Socket 对象的发送方法发送数据包</li><li>释放资源</li></ol></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个UDPSocket对象</span></span><br><span class="line"><span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="string">&quot;hello,udp,java&quot;</span>.getBytes();</span><br><span class="line"><span class="comment">//数据打包</span></span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">datagramPacket</span> <span class="operator">=</span></span><br><span class="line">  <span class="comment">//指定 localhost:10086 发送 udp 数据包</span></span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length, InetAddress.getLocalHost(), <span class="number">10086</span>);</span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">datagramSocket.send(datagramPacket);</span><br><span class="line"><span class="comment">//关闭Socket对象，释放资源</span></span><br><span class="line">datagramSocket.close();</span><br></pre></td></tr></table></figure><h3 id="接受数据步骤"><a class="header-anchor" href="#接受数据步骤">¶</a>接受数据步骤</h3><p>UDP 接受数据步骤：</p><div class="alert warning no-icon"><ol><li>创建接收端 Socket 对象</li><li>创建一个数据包(接受容器)</li><li>调用 Socket 对象的接收方法接受数据</li><li>解析数据包，并显示在控制台</li><li>释放资源</li></ol></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 创建接受端 Socket 对象</span></span><br><span class="line">  <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">10086</span>);</span><br><span class="line">  <span class="comment">// 创建接受端数据包</span></span><br><span class="line">  <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">  <span class="type">DatagramPacket</span> <span class="variable">datagramPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line">  <span class="comment">// 调用Socket对象的接受方法</span></span><br><span class="line">  datagramSocket.receive(datagramPacket);</span><br><span class="line">  <span class="comment">// 解析数据</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> datagramPacket.getAddress().getHostAddress();</span><br><span class="line">  <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(datagramPacket.getData(), <span class="number">0</span>, datagramPacket.getLength());</span><br><span class="line">  System.out.println(address + <span class="string">&quot;data is :&quot;</span> + data);</span><br><span class="line">  <span class="comment">// 释放资源</span></span><br><span class="line">  datagramSocket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP-相关-API"><a class="header-anchor" href="#TCP-相关-API">¶</a>TCP 相关 API</h2><p>TCP 协议中的发送数据方称为客户端(Client)，接收数据方称为服务端(Server)</p><h3 id="Client-方-API"><a class="header-anchor" href="#Client-方-API">¶</a>Client 方 API</h3><p>TCP 协议 Client 端的 Socket 对象</p><h4 id="构造方法-v3"><a class="header-anchor" href="#构造方法-v3">¶</a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Socket();<span class="comment">//创建一个未建立连接的Socket</span></span><br><span class="line">Socket(InetAddress address, <span class="type">int</span> port);<span class="comment">//创建一个&lt;address,port&gt;建立连接的socket对象</span></span><br><span class="line">Socket(String host, <span class="type">int</span> port);<span class="comment">//host可以是ip地址的格式</span></span><br></pre></td></tr></table></figure><h4 id="成员方法-v4"><a class="header-anchor" href="#成员方法-v4">¶</a>成员方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前TCP数据流,而后使用I/O流写数据</span></span><br><span class="line"><span class="keyword">public</span> OutputStream <span class="title function_">getOutputStream</span><span class="params">()</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> InputStream <span class="title function_">getInputStream</span><span class="params">()</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> InetAddress <span class="title function_">getInetAddress</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdownInput</span><span class="params">()</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdownOutput</span><span class="params">()</span><span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><h4 id="TCP-报文接受数据步骤"><a class="header-anchor" href="#TCP-报文接受数据步骤">¶</a>TCP 报文接受数据步骤</h4><div class="alert warning no-icon"><ol><li>创建接受端的 Socket 对象</li><li>监听客户端,返回一个对应的 Socket 对象</li><li>获取输入流，读取数据显示在控制台</li><li>释放资源</li></ol></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">//创建接受端的Socket对象</span></span><br><span class="line">  <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10086</span>);</span><br><span class="line">  <span class="comment">//侦听并接受此套接字，此方法在连接建立之前一直阻塞</span></span><br><span class="line">	<span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">  <span class="comment">//获取输入流</span></span><br><span class="line">  <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> accept.getInputStream();</span><br><span class="line">  <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">  <span class="comment">//阻塞式方法</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">  System.out.println(</span><br><span class="line">	accept.getInetAddress().getHostAddress() + <span class="string">&quot;-----&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line">  <span class="comment">//释放资源</span></span><br><span class="line">  accept.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Server-方-API"><a class="header-anchor" href="#Server-方-API">¶</a>Server 方 API</h3><p>TCP 协议 Server 端 Socket 对象</p><h4 id="构造方法-v4"><a class="header-anchor" href="#构造方法-v4">¶</a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个没有绑定的服务端Socket</span></span><br><span class="line">ServerSocket();</span><br><span class="line"><span class="comment">//创建一个本机监听特定端口的服务器端Socket</span></span><br><span class="line">ServerSocket(<span class="type">int</span> port);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="成员方法-v5"><a class="header-anchor" href="#成员方法-v5">¶</a>成员方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听客户端，返回一个对应的Socket对象</span></span><br><span class="line"><span class="keyword">public</span> Socket <span class="title function_">accept</span><span class="params">()</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="comment">//获取当前Socket对象的输入流数据</span></span><br><span class="line"><span class="keyword">public</span> InputStream <span class="title function_">getInputStream</span><span class="params">()</span><span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><h4 id="TCP-报文发送流程"><a class="header-anchor" href="#TCP-报文发送流程">¶</a>TCP 报文发送流程</h4><div class="alert success no-icon"><ol><li>创建发送端的 Socket 对象，这一步如果成功，说明连接已经建立成功</li><li>获取数据流，写数据</li><li>释放资源</li></ol></div><p>🎶<code>java.net.ConnectException：连接被拒绝</code>，TCP 协议一定要先打开服务器，而后发送数据，否则连接建立失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 创建 TCPsocket 对象</span></span><br><span class="line">  <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">10086</span>);</span><br><span class="line">  <span class="comment">// 获取输出数据流</span></span><br><span class="line">  <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">  outputStream.write(<span class="string">&quot;hello tcp !&quot;</span>.getBytes());</span><br><span class="line">  socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/JDK/" rel="tag">JDK</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/" data-tooltip="2021年度总结" aria-label="上一篇: 2021年度总结"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/shiro-%E6%A6%82%E8%BF%B0/" data-tooltip="Shiro 概述" aria-label="下一篇: Shiro 概述"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/" data-tooltip="2021年度总结" aria-label="上一篇: 2021年度总结"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/shiro-%E6%A6%82%E8%BF%B0/" data-tooltip="Shiro 概述" aria-label="下一篇: Shiro 概述"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>