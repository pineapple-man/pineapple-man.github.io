<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>HTTP（三）HTTP 基本认证 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="HTTP"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n移动互联网的发展，通过 Web 可以方便地访问许多信息。但仅仅方便用户访问是不够的，还需要做到细粒度的用户认证\n例如：某资源网站中，只有登录的用户才能够下载相关资源，没有登录的用户甚至看不到资源下载地址，这就是一种典型的细粒度用户认证案例。未授权用户无法查看其他用户的个人隐私数据，也不能在未经许可的情况下向 Web 站点发布文档。\n\n本章将阐述 HTTP 的认证机制，深入介绍最常见的 HTTP 认证的两种形式：基本认证（basic authentication）以及摘要认证（digest authentication）\n¶概述\n❓什么是认证？\n认证是一种验证身份的技术，通过这种技术服务器可以了解用户的身份，一旦服务器知道了用户身份，就可以判定用户可以访问的事务和资源了。通常是通过提供用户名和密码进行认证的。尽管可以在 HTTP 的认证形式和 cookie 基础之上运行自己的认证工具，但在很多情况下，HTTP 的原生认证功能就可以很好地满足要求\n\n¶HTTP 认证框架\nHTTP 提供了一个原生的质询 / 响应（challenge/response）框架，简化了对用户的认证过程\n\n⛵认证逻辑\n\nWeb 应用程序收到一条 HTTP 请求报文时，服务器没有按照请求执行动作，而是以一个认证质询进行响应，要求用户提供一些保密信息来说明他是谁，从而对其进行质询\n用户再次发起请求时，要附上保密证书（用户名和密码）。如果证书不匹配，服务器 可以再次质询客户端，或产生一条错误信息。如果证书匹配，就可以正常完成请求了。\n\n\n¶认证协议与首部\nHTTP 通过一组可定制的控制首部，为不同的认证协议提供了一个可扩展的认证框架，下图列出的首部格式和内容会随认证协议的不同而发生变化。认证协议也是在 HTTP 认证首部中指定的\n请求认证的四个步骤\n\n\n\n步骤\n首部\n描述\n方法/状态\n\n\n\n\n请求\n\n第一条请求没有认证信息，只是请求资源\nGET\n\n\n质询\nWWW-Authenticate\n服务器用 401 状态拒绝了请求，说明需要用 户提供用户名和密码。 服务器上可能会分为不同的区域，每个区 域都有自己的密码，所以服务器会在 WWW-Authenticate首部对保护区域进行描述。 同样，认证算法也是在 WWW-Authenticate 首部中指定的\n401 Unauthorized\n\n\n授权\nAuthorization\n客户端重新发出请求，但这一次会附加一个 Authorization 首部，用来说明认证算法、 用户名和密码\nGET\n\n\n成功\nAuthentication-Info\n如 果 授 权 证 书 是 正 确 的， 服 务 器 就 会 将 文 档 返 回。 有 些 授 权 算 法 会 在 可 选 的 Authentication-Info 首部返回一些与授 权会话相关的附加信息\n200 OK\n\n\n\n基本认证实例如下：\n\n\n服务器对用户进行质询时，会返回一条 401 Unauthorized 响应，并在 WWW-Authenticate 首部说明如何以及在哪里进行认证\n当客户端授权服务器继续处理时，会重新发送请求，但会在 Authorization 首部附上加密的密码和其他一些认证参数\n授权请求成功完成时，服务器会返回一个正常的状态码（比如，200 OK）；对高级认证算法来说，可能还会在 Authentication-Info 首部附加一些额外的信息\n\n\n¶安全域（Realm）\n❓ HTTP 是怎样允许服务器为不同的资源使用不同的访问权限的？\n上图中，WWW-Authenticate 质询中包含了一个 realm 指令。Web 服务器会将受保护的文档组织成一个安全域（security realm），每个安全域都可以有不同的授权用户集\n\n比如，假设 Web 服务器建立了两个安全域：一个用于公司的财务信息，另一个用于个人家庭文档。不同的用户对各个安全域的访问权限是不同的。 公司的 CEO 应该能够访问销售额预测资料，但不应该允许他访问员工和其家人度假的照片！\n\n下面是一个假想的基本认证质询，它指定了一个域\n12HTTP/1.0 401 UnauthorizedWWW-Authenticate: Basic realm=&quot;Corporate Financials&quot;\n域(realm)应该有一个描述性的字符名，比如 Corporate Financials（公司财务资料），以帮助用户了解应该使用哪个用户名和密码。在安全域的名称中列出服务器主机名也是很有帮助的,比如:\n12HTTP/1.0 401 UnauthorizedWWW-Authenticate: Basic realm=&quot;executive-committee@bigcompany.com&quot;\n¶基本认证\n基本认证是最流行的 HTTP 认证协议，几乎每个客户端和服务器都实现了基本认证机制。\n\n在基本认证中，Web 服务器可以拒绝一个事务，质询客户端，请用户提供有效的用户名和密码。此时服务器会返回 401 状态码，而不是 200 状态码来初始化认证质询，并用 WWW-Authenticate 响应首部指定要访问的安全域；\n浏览器收到质询时，会打开一个对话框，请求用户输入这个域的用户名和密码。然后将用户名和密码稍加扰码，再用 Authorization 请求首部回送给服务器\n\n\n¶基本认证实例\n下表总结了 HTTP 基本认证的 WWW-Authenticate 和 Authorization 首部\n\n\n\n质询/响应\n首部语法及描述\n\n\n\n\n质询（服务器发往客户端）\n网站的不同部分可能有不同的密码。realm 域就是一个引用字符串，用来命名所请求的文档集，这样用户就知道该使用哪个密码了WWW-Authenticate: Basic realm=quoted-realm\n\n\n响应（客户端发往服务器）\n用冒号（ :）将用户名和密码连接起来，然后转换成 Base-64 编码，这样能尽量避免攻击者通过观察网络流量并只进行一些粗略的检查就获取用户名和密码的情况发生： Authorization: Basic base64-username-and-password\n\n\n\n🎶 基本认证协议并没有使用 Authentication-Info 首部\n\n¶Base-64 编码\n❓什么是 base64 编码\n简单来说，Base-64 编码是一种编码格式，会将一个 8 位字节序列划分为一些 6 位的块。用每个 6 位的块在一个特殊的由 64 个字符组成的字母表中选择一个字符，这个字母表中包含了大部分字母和数字\n\nBase-64 编码可以接受二进制字符串、文本、国际字符表示的数据，将其暂时转换成一个易移植的字母表以便传输。然后，在远端就可以解码出原始字符串，而无需担心传输错误了。\n有些用户名和密码中会包含国际字符或其他在 HTTP 首部中非法的字符（比如引号、 冒号和回车换行符），对这些用户名和密码来说，Base-64 编码是非常有用的。而且，Base-64 编码扰乱了用户名和密码，这样也可以防止管理员在管理服务器和网络时，不小心看到用户名和密码\n¶基本认证的安全缺陷\n基本认证简单便捷，但并不安全。只能用它来防止非恶意用户无意间进行的访问，或将其与 SSL 这样的加密技术配合使用，总而言之，基本认证存在下列安全缺陷。\n基本认证会通过网络发送用户名和密码，这些用户名和密码都是以一种很容易解码的形式表示的。实际上，密码是以明文形式传输的，任何人都可以读取并将其捕获。虽然 Base-64 编码通过隐藏用户名和密码，致使一般用户不太可能在进行网络观测时无意中看到密码，但 Base-64 编码的用户名和密码可以很轻易地通过反向编码过程进行解码。所以经过 Base-64 编码的密码实际上就是明文传送的\n\n即使密码是以更难解码的方式（非 base-64 编码）加密的，第三方用户仍然可以捕获被修改过的用户名和密码，并将修改过的用户名和密码一次一次地重放给原始服务器，以获得对服务器的访问权。没有什么措施可用来防止这些重放攻击\n即使将基本认证用于一些不太重要的应用程序，比如公司内部网络的访问控制或个性化内容的访问，「 一些不良习惯 」也会让它变得很危险。很多用户由于受不了大量密码保护的服务，会在这些服务间使用相同的用户名和密码。比如说，某个狡猾的攻击者会从免费的因特网邮件网站捕获明文形式的用户名和密码，然后会发现用同样的用户名和密码还可以访问重要的在线银行网站！\n基本认证没有提供任何针对代理和作为中间人的中间节点的防护措施，它们没有修改认证首部，但却修改了报文的其余部分，这样就严重地改变了事务的本质\n\n假冒服务器很容易骗过基本认证，如果在用户实际连接到一台恶意服务器或网关的时候，能够让用户相信他连接的是一个受基本认证保护的合法主机，攻击者就可以请求用户输入密码，将其存储起来以备未来使用，然后捏造一条错误信息传送给用户。这就是典型的中间人攻击。\n这一切说明，在隐私保护严格的环境中，可以通过基本认证来提供便捷的文档个性化服务或访问控制保护，但是并不能真正的保证安全。通过这种方式，只能防止一些好奇的用户无意中或不小心对文档进行访问，对于专业的攻击者还是能够通过不正当的手段进行访问\n比如，在一个公司内部，产品管理可能要对未来的产品计划进行密码保护，以防止信息的过早发布。对一般用户而言，基本认证就足以让他们感到不便而不会再去访问这些数据了。同样，你可能会用密码来保护那些并非高度机密的，或者没什么信息价值的私人照片或私有站点，这些信息确实和其他人也没什么关系。将基本认证与加密数据传输（比如 SSL）配合使用，向恶意用户隐藏用户名和密码，会使基本认证变得更加安全，这是一种常用的技巧\n\n🎶 如果一个场景中有第三方会去拦截基本认证发送的用户名和密码，就要通过 SSL 加密信道发送所有的 HTTP 事务，或者使用更安全的认证协议，比如摘要认证\n\n¶代理认证\n中间的代理服务器也可以实现认证功能。有些组织会在用户访问服务器、LAN 或无线网络之前，用代理服务器对其进行认证。可以在代理服务器上对访问策略进行集中管理，因此，通过代理服务器提供对某组织内部资源的统一访问控制是一种很便捷的方式。这个过程的第一步就是通过代理认证（proxy authentication）来识别身份。\n代理认证的步骤与 Web 服务器身份验证的步骤相同。但首部和状态码都有所不同。 下表列出了 Web 服务器和代理在认证中使用的状态码和首部的差异\nWeb 服务器与代理认证的差异\n\n\n\n\nWeb 服务器\n代理服务器\n\n\n\n\nUnauthorized status code: 401\nUnauthorized status code: 407\n\n\nWWW-Authenticate\nProxy-Authenticate\n\n\nAuthorization\nProxy-Authorization\n\n\nAuthentication-Info\nProxy-Authentication-Info\n\n\n\n¶摘要认证\n基本认证便捷灵活，但极不安全，用户名和密码都是以明文形式传送的，用户名和密码用 Base-64 编码进行了加密，但很容易被解密。只能防止无意中的查看，没有任何防止恶意用户攻击的手段， 也没有采取任何措施防止对报文的篡改。安全使用基本认证的唯一方式就是将其与 SSL 配合使用\n\n摘要认证与基本认证兼容，但却更为安全，尽管摘要认证还没有得到广泛应用，但对实现安全事务来说，这些概念是非常重要的，摘要认证是另一种 HTTP 认证协议，它试图修复基本认证协议的严重缺陷。具体来说，摘要认证进行了如下改进：\n\n永远不会以明文方式在网络上发送密码\n可以防止恶意用户捕获并重放认证的握手过程\n可以有选择地防止对报文内容的篡改\n防范其他几种常见的攻击方式\n\n\n摘要认证并不是最安全的协议，与基于公有密钥的机制相比，摘要认证所提供的认证机制就不够强。同样，摘要认证除了能保护密码外，并没有提供保护其他内容的方式,请求和应答中的其余部分仍然可能被窃听；摘要认证并不能满足安全 HTTP 事务的很多需求，对这些需求来说，使用传输层安全（Transport Layer Security，TLS）和安全 HTTP （Secure HTTP，HTTPS）协议更为合适\n但摘要认证比它要取代的基本认证强大很多。与很多建议其他因特网服务使用的常用策略相比，（比如曾建议 LDAP、POP 和 IMAP 使用的 CRAM-MD5），摘要认证也要强大很多\n","dateCreated":"2022-01-15T08:12:17+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2022-01-15T08:12:17+00:00","description":"本文主要讲解 HTTP 中的基本认证技术，虽然 HTTP 能够做到认证，但是并没有普遍使用此技术，原因会在本文进行阐述","headline":"HTTP（三）HTTP 基本认证","image":["https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/http权威指南.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/http%EF%BC%88%E4%B8%89%EF%BC%89http-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/http%EF%BC%88%E4%B8%89%EF%BC%89http-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81/","keywords":"HTTP","thumbnailUrl":"https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/http权威指南.jpg"}</script><meta name="description" content="本文主要讲解 HTTP 中的基本认证技术，虽然 HTTP 能够做到认证，但是并没有普遍使用此技术，原因会在本文进行阐述"><meta property="og:type" content="blog"><meta property="og:title" content="HTTP（三）HTTP 基本认证"><meta property="og:url" content="https://pineapple-man.github.io/http%EF%BC%88%E4%B8%89%EF%BC%89http-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="本文主要讲解 HTTP 中的基本认证技术，虽然 HTTP 能够做到认证，但是并没有普遍使用此技术，原因会在本文进行阐述"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/http%E8%B4%A8%E8%AF%A2%E5%93%8D%E5%BA%94%E6%A1%86%E6%9E%B6.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81%E5%AE%9E%E4%BE%8B.png"><meta property="article:published_time" content="2022-01-15T08:12:17.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.007Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="HTTP"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/http%E8%B4%A8%E8%AF%A2%E5%93%8D%E5%BA%94%E6%A1%86%E6%9E%B6.png"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/http权威指南.jpg"><meta class="swiftype" name="image" data-type="enum" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/http权威指南.jpg"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">HTTP（三）HTTP 基本认证</h1><div class="post-meta"><time datetime="2022-01-15T08:12:17+00:00">1月 15, 2022 </time><span>发布在 </span><a class="category-link" href="/categories/Web/">Web</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 3.6k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 34 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E8%AE%A4%E8%AF%81%E6%A1%86%E6%9E%B6"><span class="toc-text">HTTP 认证框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%81%E5%8D%8F%E8%AE%AE%E4%B8%8E%E9%A6%96%E9%83%A8"><span class="toc-text">认证协议与首部</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%9F%9F%EF%BC%88Realm%EF%BC%89"><span class="toc-text">安全域（Realm）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81"><span class="toc-text">基本认证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81%E5%AE%9E%E4%BE%8B"><span class="toc-text">基本认证实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Base-64-%E7%BC%96%E7%A0%81"><span class="toc-text">Base-64 编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81%E7%9A%84%E5%AE%89%E5%85%A8%E7%BC%BA%E9%99%B7"><span class="toc-text">基本认证的安全缺陷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E8%AE%A4%E8%AF%81"><span class="toc-text">代理认证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%98%E8%A6%81%E8%AE%A4%E8%AF%81"><span class="toc-text">摘要认证</span></a></li></ol><p>移动互联网的发展，通过 Web 可以方便地访问许多信息。但仅仅方便用户访问是不够的，还需要做到细粒度的用户认证</p><div class="alert warning no-icon"><p>例如：某资源网站中，只有登录的用户才能够下载相关资源，没有登录的用户甚至看不到资源下载地址，这就是一种典型的细粒度用户认证案例。未授权用户无法查看其他用户的个人隐私数据，也不能在未经许可的情况下向 Web 站点发布文档。</p></div><p>本章将阐述 HTTP 的认证机制，深入介绍最常见的 HTTP 认证的两种形式：<strong>基本认证</strong>（basic authentication）以及<strong>摘要认证</strong>（digest authentication）</p><h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><p>❓什么是认证？</p><div class="alert success no-icon"><p>认证是一种验证身份的技术，通过这种技术服务器可以了解用户的身份，一旦服务器知道了用户身份，就可以判定用户可以访问的事务和资源了。通常是通过提供用户名和密码进行认证的。尽管可以在 HTTP 的认证形式和 cookie 基础之上运行自己的认证工具，但在很多情况下，HTTP 的原生认证功能就可以很好地满足要求</p></div><h2 id="HTTP-认证框架"><a class="header-anchor" href="#HTTP-认证框架">¶</a>HTTP 认证框架</h2><p>HTTP 提供了一个原生的质询 / 响应（challenge/response）框架，简化了对用户的认证过程</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/http质询响应框架.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/http质询响应框架.png" alt=""></a></div><p>⛵认证逻辑</p><div class="alert success no-icon"><ul><li>Web 应用程序收到一条 HTTP 请求报文时，服务器没有按照请求执行动作，而是以一个<strong>认证质询</strong>进行响应，要求用户提供一些保密信息来说明他是谁，从而对其进行质询</li><li>用户再次发起请求时，要附上保密证书（用户名和密码）。如果证书不匹配，服务器 可以再次质询客户端，或产生一条错误信息。如果证书匹配，就可以正常完成请求了。</li></ul></div><h2 id="认证协议与首部"><a class="header-anchor" href="#认证协议与首部">¶</a>认证协议与首部</h2><p>HTTP 通过一组可定制的控制首部，为不同的认证协议提供了一个可扩展的认证框架，下图列出的首部格式和内容会随认证协议的不同而发生变化。认证协议也是在 HTTP 认证首部中指定的</p><p>请求认证的四个步骤</p><table><thead><tr><th style="text-align:center">步骤</th><th style="text-align:center">首部</th><th style="text-align:center">描述</th><th style="text-align:center">方法/状态</th></tr></thead><tbody><tr><td style="text-align:center">请求</td><td style="text-align:center"></td><td style="text-align:center">第一条请求没有认证信息，只是请求资源</td><td style="text-align:center">GET</td></tr><tr><td style="text-align:center">质询</td><td style="text-align:center"><code>WWW-Authenticate</code></td><td style="text-align:center">服务器用 401 状态拒绝了请求，说明需要用 户提供用户名和密码。 服务器上可能会分为不同的区域，每个区 域都有自己的密码，所以服务器会在 <code>WWW-Authenticate</code>首部对保护区域进行描述。 同样，认证算法也是在 WWW-Authenticate 首部中指定的</td><td style="text-align:center">401 Unauthorized</td></tr><tr><td style="text-align:center">授权</td><td style="text-align:center"><code>Authorization</code></td><td style="text-align:center">客户端重新发出请求，但这一次会附加一个 Authorization 首部，用来说明认证算法、 用户名和密码</td><td style="text-align:center"><code>GET</code></td></tr><tr><td style="text-align:center">成功</td><td style="text-align:center"><code>Authentication-Info</code></td><td style="text-align:center">如 果 授 权 证 书 是 正 确 的， 服 务 器 就 会 将 文 档 返 回。 有 些 授 权 算 法 会 在 可 选 的 Authentication-Info 首部返回一些与授 权会话相关的附加信息</td><td style="text-align:center"><code>200 OK</code></td></tr></tbody></table><p>基本认证实例如下：</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/基本认证实例.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/基本认证实例.png" alt=""></a></div><div class="alert warning no-icon"><ol><li>服务器对用户进行质询时，会返回一条 401 Unauthorized 响应，并在 WWW-Authenticate 首部说明如何以及在哪里进行认证</li><li>当客户端授权服务器继续处理时，会重新发送请求，但会在 Authorization 首部附上加密的密码和其他一些认证参数</li><li>授权请求成功完成时，服务器会返回一个正常的状态码（比如，200 OK）；对高级认证算法来说，可能还会在 Authentication-Info 首部附加一些额外的信息</li></ol></div><h2 id="安全域（Realm）"><a class="header-anchor" href="#安全域（Realm）">¶</a>安全域（Realm）</h2><p>❓ HTTP 是怎样允许服务器为不同的资源使用不同的访问权限的？</p><div class="alert success no-icon"><p>上图中，WWW-Authenticate 质询中包含了一个 <code>realm</code> 指令。Web 服务器会将受保护的文档组织成一个安全域（<code>security realm</code>），每个安全域都可以有不同的授权用户集</p></div><div class="alert warning no-icon"><p>比如，假设 Web 服务器建立了两个安全域：一个用于公司的财务信息，另一个用于个人家庭文档。不同的用户对各个安全域的访问权限是不同的。 公司的 CEO 应该能够访问销售额预测资料，但不应该允许他访问员工和其家人度假的照片！</p></div><p>下面是一个假想的基本认证质询，它指定了一个域</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.0</span> <span class="number">401</span> Unauthorized</span><br><span class="line"><span class="attribute">WWW-Authenticate</span><span class="punctuation">: </span>Basic realm=&quot;Corporate Financials&quot;</span><br></pre></td></tr></table></figure><p>域(<code>realm</code>)应该有一个描述性的字符名，比如 Corporate Financials（公司财务资料），以帮助用户了解应该使用哪个用户名和密码。在安全域的名称中列出服务器主机名也是很有帮助的,比如:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.0</span> <span class="number">401</span> Unauthorized</span><br><span class="line"><span class="attribute">WWW-Authenticate</span><span class="punctuation">: </span>Basic realm=&quot;executive-committee@bigcompany.com&quot;</span><br></pre></td></tr></table></figure><h2 id="基本认证"><a class="header-anchor" href="#基本认证">¶</a>基本认证</h2><p>基本认证是最流行的 HTTP 认证协议，几乎每个客户端和服务器都实现了基本认证机制。</p><div class="alert warning no-icon"><ul><li>在基本认证中，Web 服务器可以拒绝一个事务，质询客户端，请用户提供有效的用户名和密码。此时<strong>服务器会返回 401 状态码，而不是 200 状态码来初始化认证质询</strong>，并用 WWW-Authenticate 响应首部指定要访问的安全域；</li><li>浏览器收到质询时，会打开一个对话框，请求用户输入这个域的用户名和密码。然后将用户名和密码稍加扰码，再用 Authorization 请求首部回送给服务器</li></ul></div><h3 id="基本认证实例"><a class="header-anchor" href="#基本认证实例">¶</a>基本认证实例</h3><p>下表总结了 HTTP 基本认证的 WWW-Authenticate 和 Authorization 首部</p><table><thead><tr><th style="text-align:center">质询/响应</th><th style="text-align:center">首部语法及描述</th></tr></thead><tbody><tr><td style="text-align:center">质询（服务器发往客户端）</td><td style="text-align:center">网站的不同部分可能有不同的密码。realm 域就是一个引用字符串，用来命名所请求的文档集，这样用户就知道该使用哪个密码了<code>WWW-Authenticate: Basic realm=quoted-realm</code></td></tr><tr><td style="text-align:center">响应（客户端发往服务器）</td><td style="text-align:center">用冒号（ <code>:</code>）将用户名和密码连接起来，然后转换成 Base-64 编码，这样能尽量避免攻击者通过观察网络流量并只进行一些粗略的检查就获取用户名和密码的情况发生： Authorization: Basic base64-username-and-password</td></tr></tbody></table><div class="alert info no-icon"><p>🎶 基本认证协议并没有使用 <code>Authentication-Info</code> 首部</p></div><h3 id="Base-64-编码"><a class="header-anchor" href="#Base-64-编码">¶</a>Base-64 编码</h3><p>❓什么是 base64 编码</p><div class="alert success no-icon"><p>简单来说，Base-64 编码是一种编码格式，会将一个 8 位字节序列划分为一些 6 位的块。用每个 6 位的块在一个特殊的由 64 个字符组成的字母表中选择一个字符，这个字母表中包含了大部分字母和数字</p></div><p>Base-64 编码可以接受二进制字符串、文本、国际字符表示的数据，将其暂时转换成一个易移植的字母表以便传输。然后，在远端就可以解码出原始字符串，而无需担心传输错误了。</p><p>有些用户名和密码中会包含国际字符或其他在 HTTP 首部中非法的字符（比如引号、 冒号和回车换行符），对这些用户名和密码来说，Base-64 编码是非常有用的。而且，Base-64 编码扰乱了用户名和密码，这样也可以防止管理员在管理服务器和网络时，不小心看到用户名和密码</p><h3 id="基本认证的安全缺陷"><a class="header-anchor" href="#基本认证的安全缺陷">¶</a>基本认证的安全缺陷</h3><p>基本认证简单便捷，但并不安全。只能用它来防止非恶意用户无意间进行的访问，或将其与 SSL 这样的加密技术配合使用，总而言之，<strong>基本认证存在下列安全缺陷</strong>。</p><div class="alert success no-icon"><p>基本认证会通过网络发送用户名和密码，这些用户名和密码都是以一种很容易解码的形式表示的。实际上，<strong>密码是以明文形式传输的</strong>，任何人都可以读取并将其捕获。虽然 Base-64 编码通过隐藏用户名和密码，致使一般用户不太可能在进行网络观测时无意中看到密码，但 Base-64 编码的用户名和密码可以很轻易地通过反向编码过程进行解码。所以经过 Base-64 编码的密码实际上就是<strong>明文</strong>传送的</p></div><p>即使密码是以更难解码的方式（非 base-64 编码）加密的，第三方用户仍然可以捕获被修改过的用户名和密码，并将修改过的用户名和密码一次一次地重放给原始服务器，以获得对服务器的访问权。没有什么措施可用来防止这些<strong>重放攻击</strong></p><p>即使将基本认证用于一些不太重要的应用程序，比如公司内部网络的访问控制或个性化内容的访问，「 <strong>一些不良习惯</strong> 」也会让它变得很危险。很多用户由于受不了大量密码保护的服务，会在这些服务间使用相同的用户名和密码。比如说，某个狡猾的攻击者会从免费的因特网邮件网站捕获明文形式的用户名和密码，然后会发现用同样的用户名和密码还可以访问重要的在线银行网站！</p><div class="alert info no-icon"><p>基本认证没有提供任何针对代理和作为中间人的中间节点的防护措施，它们没有修改认证首部，但却修改了报文的其余部分，这样就严重地改变了事务的本质</p></div><p>假冒服务器很容易骗过基本认证，如果在用户实际连接到一台恶意服务器或网关的时候，能够让用户相信他连接的是一个受基本认证保护的合法主机，攻击者就可以请求用户输入密码，将其存储起来以备未来使用，然后捏造一条错误信息传送给用户。这就是典型的中间人攻击。</p><p>这一切说明，在隐私保护严格的环境中，可以通过基本认证来提供便捷的文档个性化服务或访问控制保护，但是并不能真正的保证安全。通过这种方式，只能防止一些好奇的用户无意中或不小心对文档进行访问，对于专业的攻击者还是能够通过不正当的手段进行访问</p><div class="alert warning no-icon"><p>比如，在一个公司内部，产品管理可能要对未来的产品计划进行密码保护，以防止信息的过早发布。对一般用户而言，基本认证就足以让他们感到不便而不会再去访问这些数据了。同样，你可能会用密码来保护那些并非高度机密的，或者没什么信息价值的私人照片或私有站点，这些信息确实和其他人也没什么关系。将基本认证与加密数据传输（比如 SSL）配合使用，向恶意用户隐藏用户名和密码，会使基本认证变得更加安全，这是一种常用的技巧</p></div><div class="alert info no-icon"><p>🎶 如果一个场景中有第三方会去拦截基本认证发送的用户名和密码，就要通过 SSL 加密信道发送所有的 HTTP 事务，或者使用更安全的认证协议，比如<strong>摘要认证</strong></p></div><h2 id="代理认证"><a class="header-anchor" href="#代理认证">¶</a>代理认证</h2><p>中间的代理服务器也可以实现认证功能。有些组织会在用户访问服务器、LAN 或无线网络之前，用代理服务器对其进行认证。可以在代理服务器上对访问策略进行集中管理，因此，通过代理服务器提供对某组织内部资源的统一访问控制是一种很便捷的方式。这个过程的第一步就是通过代理认证（proxy authentication）来识别身份。</p><p>代理认证的步骤与 Web 服务器身份验证的步骤相同。但首部和状态码都有所不同。 下表列出了 Web 服务器和代理在认证中使用的状态码和首部的差异</p><div class="alert warning no-icon"><p>Web 服务器与代理认证的差异</p></div><table><thead><tr><th style="text-align:center">Web 服务器</th><th style="text-align:center">代理服务器</th></tr></thead><tbody><tr><td style="text-align:center">Unauthorized status code: 401</td><td style="text-align:center">Unauthorized status code: 407</td></tr><tr><td style="text-align:center">WWW-Authenticate</td><td style="text-align:center">Proxy-Authenticate</td></tr><tr><td style="text-align:center">Authorization</td><td style="text-align:center">Proxy-Authorization</td></tr><tr><td style="text-align:center">Authentication-Info</td><td style="text-align:center">Proxy-Authentication-Info</td></tr></tbody></table><h2 id="摘要认证"><a class="header-anchor" href="#摘要认证">¶</a>摘要认证</h2><div class="alert success no-icon"><p>基本认证便捷灵活，但极不安全，用户名和密码都是以明文形式传送的，用户名和密码用 Base-64 编码进行了加密，但很容易被解密。只能防止无意中的查看，没有任何防止恶意用户攻击的手段， 也没有采取任何措施防止对报文的篡改。安全使用基本认证的唯一方式就是将其与 SSL 配合使用</p></div><p>摘要认证与基本认证兼容，但却更为安全，尽管摘要认证还没有得到广泛应用，但对实现安全事务来说，这些概念是非常重要的，摘要认证是另一种 HTTP 认证协议，它试图修复基本认证协议的严重缺陷。具体来说，摘要认证进行了如下改进：</p><div class="alert info no-icon"><ul><li>永远不会以明文方式在网络上发送密码</li><li>可以防止恶意用户捕获并重放认证的握手过程</li><li>可以有选择地防止对报文内容的篡改</li><li>防范其他几种常见的攻击方式</li></ul></div><p>摘要认证并不是最安全的协议，与基于公有密钥的机制相比，摘要认证所提供的认证机制就不够强。同样，摘要认证除了能保护密码外，并没有提供保护其他内容的方式,请求和应答中的其余部分仍然可能被窃听；摘要认证并不能满足安全 HTTP 事务的很多需求，对这些需求来说，使用传输层安全<code>（Transport Layer Security，TLS）</code>和安全 HTTP <code>（Secure HTTP，HTTPS）</code>协议更为合适</p><p>但摘要认证比它要取代的基本认证强大很多。与很多建议其他因特网服务使用的常用策略相比，（比如曾建议 LDAP、POP 和 IMAP 使用的 CRAM-MD5），摘要认证也要强大很多</p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/HTTP/" rel="tag">HTTP</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/spring-%E6%8B%A6%E6%88%AA%E5%99%A8/" data-tooltip="Spring 拦截器" aria-label="上一篇: Spring 拦截器"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/uml%EF%BC%88%E4%B8%80%EF%BC%89%E7%B1%BB%E5%9B%BE/" data-tooltip="UML（一）类图" aria-label="下一篇: UML（一）类图"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/spring-%E6%8B%A6%E6%88%AA%E5%99%A8/" data-tooltip="Spring 拦截器" aria-label="上一篇: Spring 拦截器"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/uml%EF%BC%88%E4%B8%80%EF%BC%89%E7%B1%BB%E5%9B%BE/" data-tooltip="UML（一）类图" aria-label="下一篇: UML（一）类图"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>