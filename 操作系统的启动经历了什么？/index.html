<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>操作系统的启动经历了什么？ - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="系统启动流程"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n\n本文主要摘录自阮一峰老师的博客，想要查看原文的请访问原文\n\n¶计算机的启动过程\n\n“pull oneself up by one’s bootstraps”——通过拽着鞋带将自己拉起来\n✨最早的时候，工程师们用它来比喻，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！\n\n\n¶第一阶段：BIOS\n上个世纪 70 年代初，“只读内存”（read-only memory，缩写为 ROM）发明，开机程序被刷入 ROM 芯片，计算机通电后，第一件事就是读取它\n\n这块芯片里的程序叫做基本输入输出系统（Basic Input/Output System），简称 BIOS\n¶硬件自检\nBIOS 程序首先检查，计算机硬件能否满足运行的基本条件，这叫做「硬件自检」（Power-On Self-Test），缩写为POST，如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出 CPU、内存、硬盘等信息\n\n¶启动顺序选择\n硬件自检完成后，BIOS 把控制权转交给下一阶段的启动程序。此时，BIOS 需要知道，下一阶段的启动程序具体存放在哪一个设备之上。也就是说，BIOS 需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做启动顺序（Boot Sequence）\n✨打开 BIOS 的操作界面，里面有一项就是设定启动顺序\n\n\n¶第二阶段：主引导记录（MBR）\nBIOS 按照「启动顺序」，把控制权转交给排在第一位的储存设备。这时，计算机读取该设备的第一个扇区，也就是读取最前面的 512 个字节。如果这 512 个字节的最后两个字节是 0x55 和 0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权转交给启动顺序中的下一个设备\n🎶最前面的 512 字节，称为主引导记录（Master boot record，MBR）\n\n¶主引导记录的结构\nMBR 由于只有 512 字节，放不了太多信息，它的主要作用是：告诉计算机硬盘的哪一个位置存放着操作系统\n✨MBR 由三部分组成\n\n1-446 Bytes：调用操作系统的机器码\n447-510 Bytes：分区表（Partition table）\n511,512Bytes：主引导记录签名（存放0x55与0xAA）\n\n\n  🎶其中分区表的作用，是将硬盘分成若干个区\n\n¶分区表\n磁盘分区有很多好处，考虑到每个区可以安装不同的操作系统，MBR 因此必须知道将控制权交给哪个区。分区表的长度只有 64 个字节，里面又分成四项，每项 16 个 字节。所以，一个硬盘最多只能分四个一级分区，又叫做主分区\n✨每个主分区的 16 字节，由以下 6 部分组成\n\n第 1 个字节：如果为 0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的\n第 2-4 个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）\n第 5 个字节：主分区类型\n第 6-8 个字节：主分区最后一个扇区的物理位置\n第 9-12 字节：该主分区第一个扇区的逻辑地址\n第 13-16 字节：主分区的扇区总数\n\n\n  🎶最后的四个字节（主分区的扇区总数），决定了这个主分区的长度，也就是说，一个主分区的扇区总数最多不超过 $2^{32}$\n\n如果每个扇区为 512 个字节，就意味着单个分区最大不超过 2 TB。再考虑到扇区的逻辑地址也是 32 位，所以单个硬盘可利用的空间最大也不超过 2TB。如果想使用更大的硬盘，只有 2 个方法：一是提高每个扇区的字节数，二是增加扇区总数\n¶第三阶段：磁盘启动（Grub）\n此时，计算机的控制权转交给硬盘的某个分区，此时又分成三种情况\n¶情况一：卷引导记录\n四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做卷引导记录（Volume Boot Record，VBR）\n✨卷引导记录的主要作用是：告诉计算机，操作系统在这个分区里的位置，随后计算机就会加载操作系统\n\n¶情况二：扩展分区和逻辑分区\n随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成扩展分区（Extended Partition），所谓扩展分区，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做逻辑分区（logical partition）。\n计算机先读取扩展分区的第一个扇区，称为扩展引导记录（Extended Boot Record，EBR），它里面也包含一张 64 字节的分区表，但是最多只有两项（也就是两个逻辑分区）\n📓计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区，但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动\n\n¶情况三：启动管理器\n在这种情况下，计算机读取主引导记录前面 446 字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的启动管理器（Boot Loader），由用户选择启动哪一个操作系统。Linux 环境中，目前最流行的启动管理器是Grub\n\n¶第四阶段：操作系统启动\n控制权转交给操作系统后，操作系统的内核首先被载入内存。\n以 Linux 系统为例，先载入 /boot 目录下面的 kernel。内核加载成功后，第一个运行的程序是 /sbin/init。它根据配置文件（Debian 系统是 /etc/initab）产生 init 进程。这是 Linux 启动后的第一个进程，pid 进程编号为 1，其他进程都是它的后代。然后，init 线程加载系统的各个模块，比如窗口程序和网络程序，直至执行 /bin/login 程序，跳出登录界面，等待用户输入用户名和密码\n\n具体的操作系统启动流程在下面由阐述\n¶Linux（操作系统） 启动\n计算机的启动最后一步，就是操作系统的启动，接下来将研究操作系统的启动流程\n\n✨在 BIOS 阶段，计算机的行为基本上被写死了，程序员可以做的事情并不多；但是，一旦进入操作系统，程序员几乎可以定制所有方面\n\n¶第一步：加载内核\n操作系统接管硬件以后，首先读入 /boot 目录下的内核文件\n\n12345678910ls /boot　　config-3.2.0-3-amd64　　config-3.2.0-4-amd64　　grub　　initrd.img-3.2.0-3-amd64　　initrd.img-3.2.0-4-amd64　　System.map-3.2.0-3-amd64　　System.map-3.2.0-4-amd64　　vmlinuz-3.2.0-3-amd64　　vmlinuz-3.2.0-4-amd64\n¶第二步：启动初始化进程\n内核文件加载以后，就开始运行第一个程序 /sbin/init，它的作用是初始化系统环境，由于 init 是第一个运行的程序，它的进程编号（pid）就是 1。其他所有进程都从它衍生，都是它的子进程\n\n¶第三步：确定运行级别\n许多程序需要开机启动。它们在 Windows 叫做「服务」（service），在 Linux 就叫做守护进程（Daemon）。\ninit 进程的一大任务，就是去运行这些开机启动的程序。但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动 Apache，用作桌面就不需要。Linux 允许为不同的场合，分配不同的开机启动程序，这就叫做运行级别（Run Level）\n\n🎶也就是说，启动时根据运行级别，确定要运行哪些程序\n\n✨Linux 预置七种运行级别（0-6）。一般来说，0 是关机，1 是单用户模式（也就是维护模式），6 是重启。运行级别 2-5，各个发行版不太一样，对于 Debian 来说，都是同样的多用户模式（也就是正常模式）\ninit 进程首先读取文件 /etc/inittab，它是运行级别的设置文件。如果你打开它，可以看到第一行是这样的：\n1id:2:initdefault:\ninitdefault 的值是 2，表明系统启动时的运行级别为 2。如果需要指定其他级别，可以手动修改这个值\n🤔那么，运行级别 2 有些什么程序呢，系统怎么知道每个级别应该加载哪些程序呢？\n\n每个运行级别在/etc 目录下面，都有一个对应的子目录，指定要加载的程序\n\n1234567/etc/rc0.d/etc/rc1.d/etc/rc2.d/etc/rc3.d/etc/rc4.d/etc/rc5.d/etc/rc6.d\n上面目录名中的rc，表示run command（运行程序），最后的 d 表示 directory（目录）\n看看 /etc/rc2.d 目录中到底指定了哪些程序\n123456789101112　$ ls  /etc/rc2.d　　　　README　　S01motd　　S13rpcbind　　S14nfs-common　　S16binfmt-support　　S16rsyslog　　S16sudo　　S17apache2　　S18acpid　　...\n\n✨运行程序命名与运行特点\n\n可以看到，除了第一个文件 README 以外，其他文件名都是「字母 S+两位数字+程序名」的形式。\n字母 S 表示 Start，也就是启动的意思（启动脚本的运行参数为 start），如果这个位置是字母 K，就代表 Kill（关闭），即如果从其他运行级别切换过来，需要关闭的程序（启动脚本的运行参数为 stop）\n后面的两位数字表示处理顺序，数字越小越早处理，所以第一个启动的程序是 motd，然后是 rpcbing、nfs…数字相同时，则按照程序名的字母顺序启动，所以 rsyslog 会先于 sudo 启动\n\n\n这个目录里的所有文件（除了 README ），是启动时要加载的程序。如果想增加或删除某些程序，不建议手动修改 /etc/rcN.d 目录，最好是用一些专门命令进行管理\n¶第四步：加载开机启动程序\n七种预设的运行级别各自有一个目录，存放需要开机启动的程序\n😣如果多个运行级别需要启动同一个程序，那么这个程序的启动脚本，就会在每个目录都有一个拷贝，这样必然会造成管理上的困扰，如何做到优雅的修改启动脚本？\nLinux 的解决办法，是七个 /etc/rcN.d 目录里列出的程序，都设为链接文件，指向另外一个目录 /etc/init.d ，真正的启动脚本都统一放在这个目录中。init 进程逐一加载开机启动程序，其实就是运行这个目录里的启动脚本\n\n1234567891011　　$ ls -l /etc/rc2.d　　　　README　　S01motd -&gt; ../init.d/motd　　S13rpcbind -&gt; ../init.d/rpcbind　　S14nfs-common -&gt; ../init.d/nfs-common　　S16binfmt-support -&gt; ../init.d/binfmt-support　　S16rsyslog -&gt; ../init.d/rsyslog　　S16sudo -&gt; ../init.d/sudo　　S17apache2 -&gt; ../init.d/apache2　　S18acpid -&gt; ../init.d/acpid\n🎶/etc/init.d 这个目录名最后一个字母 d，是 directory 的意思，表示这是一个目录，用来与程序 /etc/init 区分\n\n¶第五步：用户登录\n开机启动程序加载完毕以后，就要让用户登录了\n\n✨一般而言，用户的登录方式有三种（命令行登录、SSH 登陆和图形界面登陆），不同的登录方式存在各自验证用户身份的方式\n¶命令行登录\ninit 进程调用 getty 程序（意为 get teletype），让用户输入用户名和密码；输入完成后，再调用 login 程序，核对密码（Debian 还会再多运行一个身份核对程序 /etc/pam.d/login），如果密码正确，就从文件 /etc/passwd 读取该用户指定的 shell，然后启动这个 shell\n\n¶ssh 登录\n这时系统调用 sshd 程序（Debian 还会再运行/etc/pam.d/ssh ），取代 getty 和 login，然后启动 shell\n\n¶图形界面登录\ninit 进程调用显示管理器，Gnome 图形界面对应的显示管理器为 gdm（GNOME Display Manager），然后用户输入用户名和密码。如果密码正确，就读取 /etc/gdm3/Xsession，启动用户的会话\n\n¶第六步：进入login shell\n所谓 shell，简单说就是命令行界面，让用户可以直接与操作系统对话，其中用户登录时打开的 shell，就叫做 login shell\n\n🎶Debain 默认的 shell 是 Bash，它会读入一系列的配置文件，上一步的三种情况，在这一步的处理，也存在差异\n\n¶命令行登录 &amp; ssh 登录\n首先读入 /etc/profile，这是对所有用户都有效的配置；然后依次寻找下面三个文件，这是当前用户对bash的配置\n123~/.bash_profile~/.bash_login~/.profile\n🎶这三个文件只要有一个存在，就不再读入后面的文件\n\n¶图形界面登录\n✨只加载 /etc/profile 和 ~/.profile\n\n¶第七步：打开non-login shell\n完成上一步，Linux 的启动过程已经结束，用户已经可以看到命令行提示符或者图形界面了，但是，为了内容的完整，必须再介绍一下这一步。用户进入操作系统以后，常常会再手动开启一个 shell。这个 shell 就叫做 non-login shell，意思是它不同于登录时出现的那个 shell，不读取 /etc/profile 和 .profile 等配置文件\n\nnon-login shell 的重要性，不仅在于它是用户最常接触的那个 shell，还在于它会读入用户自己的 bash 配置文件 ~/.bashrc。大多数时候，我们对于 bash 的定制，都是写在这个文件里面的\n\n✨只要运行 ～/.profile 文件，～/.bashrc 文件就会连带运行\n123456#~/.profile文件中的一部分代码if [ -n &quot;$BASH_VERSION&quot; ]; then　　　　if [ -f &quot;$HOME/.bashrc&quot; ]; then　　　　　　. &quot;$HOME/.bashrc&quot;　　　　fi　　fi\n🤔为什么 bash 的设置这么繁琐？不能和 Spring 一样统一配置，统一启动？\nBash 的设置之所以如此繁琐，是由于历史原因造成的。早期的时候，计算机运行速度很慢，载入配置文件需要很长时间，Bash 的作者只好把配置文件分成了几个部分，阶段性载入。系统的通用设置放在 /etc/profile，用户个人的、需要被所有子进程继承的设置放在 .profile，不需要被继承的设置放在 .bashrc\n\n¶系统运行级别\n¶Centos6\n系统一共有七个运行级别\n临时设置\n\n使用runlevel命令查看运行级别,使用init命令调整运行级别\n永久设置\n\n通过修改 /etc/inittab 可以做到永久性更改启动级别\n00:系统的关机级别 init 1 进入到关机状态\n01:用户的单用户模式 用于修复系统 或重置密码信息,\n02: 系统的多用户模式, 没有网络\n03: 系统的多用户模式 正常系统运行多用户模式级别 有网络\n04:预留级别\n05: 图形化界面\n06: 系统的重新启动级别\n¶Centos7 运行目标(target)\n/usr/lib/systemd/system/runlevel*target\n12systemctl get-defaultsystemctl set-default &lt;run-target&gt;  # 永久设置\n0(poweroff target):系统的关机级别 init 1 进入到维修模式\n1(rescue target):用户的单用户模式 用于修复系统 或重置密码信息,\n2(multi-user target): 系统的多用户模式, 没有网络\n3(multi-user target): 系统的多用户模式 正常系统运行多用户模式级别 有网络\n04(multi-user target):预留级别\n05(graphical target): 图形化界面\n06(reboot target): 系统的重新启动级别\n¶附录\n计算机是如何启动的？\nLinux 的启动流程——阮一峰\n开机流程、模组管理与 Loader——鸟哥\n开机流程管理——鸟哥\nLinux 开机详细流程——骏马金龙\n","dateCreated":"2022-01-08T12:00:54+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2022-01-08T12:00:54+00:00","description":"最近学习 JVM 启动流程，忽然想到了操作系统的启动流程，特意查找相关资料整理一下","headline":"操作系统的启动经历了什么？","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/","keywords":"操作系统"}</script><meta name="description" content="最近学习 JVM 启动流程，忽然想到了操作系统的启动流程，特意查找相关资料整理一下"><meta property="og:type" content="blog"><meta property="og:title" content="操作系统的启动经历了什么？"><meta property="og:url" content="https://pineapple-man.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="最近学习 JVM 启动流程，忽然想到了操作系统的启动流程，特意查找相关资料整理一下"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292144400.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292145385.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292145856.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292146980.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292147158.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292148907.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292148303.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292148373.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292149696.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292149090.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292149754.png"><meta property="article:published_time" content="2022-01-08T12:00:54.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.003Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="操作系统"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292144400.jpg"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">操作系统的启动经历了什么？</h1><div class="post-meta"><time datetime="2022-01-08T12:00:54+00:00">1月 08, 2022 </time><span>发布在 </span><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 4.2k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 40 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">计算机的启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%9ABIOS"><span class="toc-text">第一阶段：BIOS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%87%AA%E6%A3%80"><span class="toc-text">硬件自检</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F%E9%80%89%E6%8B%A9"><span class="toc-text">启动顺序选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%9A%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95%EF%BC%88MBR%EF%BC%89"><span class="toc-text">第二阶段：主引导记录（MBR）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">主引导记录的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-text">分区表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%EF%BC%9A%E7%A3%81%E7%9B%98%E5%90%AF%E5%8A%A8%EF%BC%88Grub%EF%BC%89"><span class="toc-text">第三阶段：磁盘启动（Grub）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%B8%80%EF%BC%9A%E5%8D%B7%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95"><span class="toc-text">情况一：卷引导记录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%BA%8C%EF%BC%9A%E6%89%A9%E5%B1%95%E5%88%86%E5%8C%BA%E5%92%8C%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA"><span class="toc-text">情况二：扩展分区和逻辑分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%B8%89%EF%BC%9A%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-text">情况三：启动管理器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8"><span class="toc-text">第四阶段：操作系统启动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%EF%BC%88%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%89-%E5%90%AF%E5%8A%A8"><span class="toc-text">Linux（操作系统） 启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8"><span class="toc-text">第一步：加载内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%90%AF%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%9B%E7%A8%8B"><span class="toc-text">第二步：启动初始化进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E7%A1%AE%E5%AE%9A%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB"><span class="toc-text">第三步：确定运行级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E5%8A%A0%E8%BD%BD%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">第四步：加载开机启动程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9A%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95"><span class="toc-text">第五步：用户登录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%99%BB%E5%BD%95"><span class="toc-text">命令行登录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ssh-%E7%99%BB%E5%BD%95"><span class="toc-text">ssh 登录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E7%99%BB%E5%BD%95"><span class="toc-text">图形界面登录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E6%AD%A5%EF%BC%9A%E8%BF%9B%E5%85%A5login-shell"><span class="toc-text">第六步：进入login shell</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%99%BB%E5%BD%95-ssh-%E7%99%BB%E5%BD%95"><span class="toc-text">命令行登录 &amp; ssh 登录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E7%99%BB%E5%BD%95-v2"><span class="toc-text">图形界面登录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E6%AD%A5%EF%BC%9A%E6%89%93%E5%BC%80non-login-shell"><span class="toc-text">第七步：打开non-login shell</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB"><span class="toc-text">系统运行级别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Centos6"><span class="toc-text">Centos6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Centos7-%E8%BF%90%E8%A1%8C%E7%9B%AE%E6%A0%87-target"><span class="toc-text">Centos7 运行目标(target)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol><blockquote><p>本文主要摘录自阮一峰老师的博客，想要查看原文的请访问<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2013/02/booting.html">原文</a></p></blockquote><h2 id="计算机的启动过程"><a class="header-anchor" href="#计算机的启动过程">¶</a>计算机的启动过程</h2><blockquote><p>“pull oneself up by one’s bootstraps”——通过拽着鞋带将自己拉起来</p><div class="alert success no-icon"><p>✨最早的时候，工程师们用它来比喻，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！</p></div></blockquote><h3 id="第一阶段：BIOS"><a class="header-anchor" href="#第一阶段：BIOS">¶</a>第一阶段：BIOS</h3><p>上个世纪 70 年代初，“只读内存”（read-only memory，缩写为 ROM）发明，开机程序被刷入 ROM 芯片，计算机通电后，第一件事就是读取它</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292144400.jpg" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292144400.jpg" alt=""></a></div><p>这块芯片里的程序叫做<strong>基本输入输出系统（Basic Input/Output System）</strong>，简称 BIOS</p><h4 id="硬件自检"><a class="header-anchor" href="#硬件自检">¶</a>硬件自检</h4><p>BIOS 程序首先检查，计算机硬件能否满足运行的基本条件，这叫做「硬件自检」（Power-On Self-Test），缩写为<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Power-on_self-test">POST</a>，如果硬件出现问题，主板会发出不同含义的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Power-on_self-test#Original_IBM_POST_beep_codes">蜂鸣</a>，启动中止。如果没有问题，屏幕就会显示出 CPU、内存、硬盘等信息</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292145385.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292145385.png" alt=""></a></div><h4 id="启动顺序选择"><a class="header-anchor" href="#启动顺序选择">¶</a>启动顺序选择</h4><p>硬件自检完成后，BIOS 把控制权转交给下一阶段的启动程序。此时，BIOS 需要知道，<strong>下一阶段的启动程序</strong>具体存放在哪一个设备之上。也就是说，BIOS 需要有一个<strong>外部储存设备的排序</strong>，<font style="color:red;font-weight:700">排在前面的设备就是优先转交控制权的设备</font>。这种排序叫做<strong>启动顺序（Boot Sequence）</strong></p><div class="alert success no-icon"><p>✨打开 BIOS 的操作界面，里面有一项就是<strong>设定启动顺序</strong></p></div><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292145856.jpg" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292145856.jpg" alt=""></a></div><h3 id="第二阶段：主引导记录（MBR）"><a class="header-anchor" href="#第二阶段：主引导记录（MBR）">¶</a>第二阶段：主引导记录（MBR）</h3><p>BIOS 按照「启动顺序」，把控制权转交给排在第一位的储存设备。这时，计算机读取该设备的第一个扇区，也就是读取最前面的 512 个字节。如果这 512 个字节的<strong>最后两个字节是 0x55 和 0xAA</strong>，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权转交给<strong>启动顺序</strong>中的<strong>下一个设备</strong></p><div class="alert success no-icon"><p>🎶最前面的 512 字节，称为<strong>主引导记录（Master boot record，MBR）</strong></p></div><h4 id="主引导记录的结构"><a class="header-anchor" href="#主引导记录的结构">¶</a>主引导记录的结构</h4><p>MBR 由于只有 512 字节，放不了太多信息，它的主要作用是：<span class="highlight-text red">告诉计算机硬盘的哪一个位置存放着操作系统</span></p><p>✨MBR 由三部分组成</p><div class="alert success no-icon"><ul><li><code>1-446 Bytes</code>：调用操作系统的机器码</li><li><code>447-510 Bytes</code>：分区表（Partition table）</li><li><code>511,512Bytes</code>：主引导记录签名（存放<code>0x55与0xAA</code>）</li></ul></div><div class="alert info no-icon"><p>🎶其中分区表的作用，是将硬盘分成若干个区</p></div><h4 id="分区表"><a class="header-anchor" href="#分区表">¶</a>分区表</h4><p>磁盘分区有很多好处，考虑到每个区可以安装不同的操作系统，MBR 因此必须知道将控制权交给哪个区。分区表的长度只有 64 个字节，里面又分成四项，每项 16 个 字节。所以，<font style="color:red;font-weight:700">一个硬盘最多只能分四个一级分区</font>，又叫做<strong>主分区</strong></p><p>✨每个主分区的 16 字节，由以下 6 部分组成</p><div class="alert success no-icon"><ul><li>第 1 个字节：如果为 0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的</li><li>第 2-4 个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）</li><li>第 5 个字节：主分区类型</li><li>第 6-8 个字节：主分区最后一个扇区的物理位置</li><li>第 9-12 字节：该主分区第一个扇区的逻辑地址</li><li>第 13-16 字节：主分区的扇区总数</li></ul></div><div class="alert info no-icon"><p>🎶最后的四个字节（<strong>主分区的扇区总数</strong>），决定了这个主分区的长度，也就是说，一个主分区的扇区总数最多不超过 $2^{32}$</p></div><p>如果每个扇区为 512 个字节，就意味着单个分区最大不超过 2 TB。再考虑到扇区的逻辑地址也是 32 位，所以单个硬盘可利用的空间最大也不超过 2TB。如果想使用更大的硬盘，只有 2 个方法：一是<strong>提高每个扇区的字节数</strong>，二是<strong>增加扇区总数</strong></p><h3 id="第三阶段：磁盘启动（Grub）"><a class="header-anchor" href="#第三阶段：磁盘启动（Grub）">¶</a>第三阶段：磁盘启动（Grub）</h3><p>此时，计算机的控制权转交给<strong>硬盘的某个分区</strong>，此时又分成三种情况</p><h4 id="情况一：卷引导记录"><a class="header-anchor" href="#情况一：卷引导记录">¶</a>情况一：卷引导记录</h4><p>四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做<strong>卷引导记录（Volume Boot Record，VBR）</strong></p><div class="alert info no-icon"><p>✨<strong>卷引导记录</strong>的主要作用是：告诉计算机，操作系统在这个分区里的位置，随后计算机就会加载操作系统</p></div><h4 id="情况二：扩展分区和逻辑分区"><a class="header-anchor" href="#情况二：扩展分区和逻辑分区">¶</a>情况二：扩展分区和逻辑分区</h4><p>随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成<strong>扩展分区（Extended Partition）</strong>，所谓<strong>扩展分区</strong>，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做<strong>逻辑分区</strong>（logical partition）。</p><p>计算机先读取扩展分区的第一个扇区，称为<strong>扩展引导记录（Extended Boot Record，EBR）</strong>，它里面也包含一张 64 字节的分区表，但是最多只有两项（也就是两个逻辑分区）</p><div class="alert info no-icon"><p>📓计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区，但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动</p></div><h4 id="情况三：启动管理器"><a class="header-anchor" href="#情况三：启动管理器">¶</a>情况三：启动管理器</h4><p>在这种情况下，计算机读取<strong>主引导记录</strong>前面 446 字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的<strong>启动管理器（Boot Loader）</strong>，由用户选择启动哪一个操作系统。Linux 环境中，目前最流行的启动管理器是<code>Grub</code></p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292146980.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292146980.png" alt=""></a></div><h3 id="第四阶段：操作系统启动"><a class="header-anchor" href="#第四阶段：操作系统启动">¶</a>第四阶段：操作系统启动</h3><p>控制权转交给操作系统后，操作系统的内核首先被载入内存。</p><div class="alert warning no-icon"><p>以 Linux 系统为例，先载入 <code>/boot</code> 目录下面的 <code>kernel</code>。内核加载成功后，第一个运行的程序是 <code>/sbin/init</code>。它根据配置文件（Debian 系统是 <code>/etc/initab</code>）产生 <code>init</code> 进程。这是 Linux 启动后的第一个进程，pid 进程编号为 1，其他进程都是它的后代。然后，init 线程加载系统的各个模块，比如窗口程序和网络程序，直至执行 <code>/bin/login</code> 程序，跳出登录界面，等待用户输入用户名和密码</p></div><p>具体的操作系统启动流程在下面由阐述</p><h2 id="Linux（操作系统）-启动"><a class="header-anchor" href="#Linux（操作系统）-启动">¶</a>Linux（操作系统） 启动</h2><p>计算机的启动最后一步，就是操作系统的启动，接下来将研究操作系统的启动流程</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292147158.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292147158.png" alt=""></a></div><div class="alert success no-icon"><p>✨在 BIOS 阶段，计算机的行为基本上被写死了，程序员可以做的事情并不多；但是，一旦进入操作系统，程序员几乎可以定制所有方面</p></div><h3 id="第一步：加载内核"><a class="header-anchor" href="#第一步：加载内核">¶</a>第一步：加载内核</h3><p>操作系统接管硬件以后，首先读入 /boot 目录下的内核文件</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292148907.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292148907.png" alt=""></a></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ls /boot</span><br><span class="line">　　config-3.2.0-3-amd64</span><br><span class="line">　　config-3.2.0-4-amd64</span><br><span class="line">　　grub</span><br><span class="line">　　initrd.img-3.2.0-3-amd64</span><br><span class="line">　　initrd.img-3.2.0-4-amd64</span><br><span class="line">　　System.map-3.2.0-3-amd64</span><br><span class="line">　　System.map-3.2.0-4-amd64</span><br><span class="line">　　vmlinuz-3.2.0-3-amd64</span><br><span class="line">　　vmlinuz-3.2.0-4-amd64</span><br></pre></td></tr></table></figure><h3 id="第二步：启动初始化进程"><a class="header-anchor" href="#第二步：启动初始化进程">¶</a>第二步：启动初始化进程</h3><p>内核文件加载以后，就开始运行第一个程序 /sbin/init，它的作用是初始化系统环境，由于 init 是第一个运行的程序，它的进程编号（pid）就是 1。其他所有进程都从它衍生，都是它的子进程</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292148303.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292148303.png" alt=""></a></div><h3 id="第三步：确定运行级别"><a class="header-anchor" href="#第三步：确定运行级别">¶</a>第三步：确定运行级别</h3><p>许多程序需要开机启动。它们在 Windows 叫做「服务」（service），在 Linux 就叫做<strong>守护进程（Daemon）</strong>。</p><div class="alert info no-icon"><p>init 进程的一大任务，就是去运行这些开机启动的程序。但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动 Apache，用作桌面就不需要。Linux 允许为不同的场合，分配不同的开机启动程序，这就叫做<strong>运行级别</strong>（Run Level）</p></div><p>🎶也就是说，启动时根据<strong>运行级别</strong>，确定要运行哪些程序</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292148373.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292148373.png" alt=""></a></div><p>✨Linux 预置七种运行级别（0-6）。一般来说，0 是关机，1 是单用户模式（也就是维护模式），6 是重启。运行级别 2-5，各个发行版不太一样，对于 Debian 来说，都是同样的多用户模式（也就是正常模式）</p><p>init 进程首先读取文件 <code>/etc/inittab</code>，它是运行级别的设置文件。如果你打开它，可以看到第一行是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id:2:initdefault:</span><br></pre></td></tr></table></figure><p>initdefault 的值是 2，表明系统启动时的运行级别为 2。如果需要指定其他级别，可以手动修改这个值</p><p>🤔那么，运行级别 2 有些什么程序呢，系统怎么知道每个级别应该加载哪些程序呢？</p><div class="alert warning no-icon"><ul><li>每个运行级别在/etc 目录下面，都有一个对应的子目录，指定要加载的程序</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc0.d</span><br><span class="line">/etc/rc1.d</span><br><span class="line">/etc/rc2.d</span><br><span class="line">/etc/rc3.d</span><br><span class="line">/etc/rc4.d</span><br><span class="line">/etc/rc5.d</span><br><span class="line">/etc/rc6.d</span><br></pre></td></tr></table></figure><p>上面目录名中的<strong>rc</strong>，表示<strong>run command（运行程序）</strong>，最后的 d 表示 directory（目录）</p><p>看看 /etc/rc2.d 目录中到底指定了哪些程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">　$ ls  /etc/rc2.d</span><br><span class="line">　　</span><br><span class="line">　　README</span><br><span class="line">　　S01motd</span><br><span class="line">　　S13rpcbind</span><br><span class="line">　　S14nfs-common</span><br><span class="line">　　S16binfmt-support</span><br><span class="line">　　S16rsyslog</span><br><span class="line">　　S16sudo</span><br><span class="line">　　S17apache2</span><br><span class="line">　　S18acpid</span><br><span class="line">　　...</span><br></pre></td></tr></table></figure></div><p>✨运行程序命名与运行特点</p><div class="alert success no-icon"><ul><li>可以看到，除了第一个文件 README 以外，其他文件名都是「字母 S+两位数字+程序名」的形式。</li><li>字母 S 表示 <code>Start</code>，也就是启动的意思（启动脚本的运行参数为 start），如果这个位置是字母 K，就代表 Kill（关闭），即如果从其他运行级别切换过来，需要关闭的程序（启动脚本的运行参数为 stop）</li><li>后面的两位数字表示处理顺序，<strong>数字越小越早处理</strong>，所以第一个启动的程序是 motd，然后是 rpcbing、nfs…数字相同时，则按照程序名的字母顺序启动，所以 rsyslog 会先于 sudo 启动</li></ul></div><p>这个目录里的所有文件（除了 README ），是启动时要加载的程序。如果想增加或删除某些程序，不建议手动修改 /etc/rcN.d 目录，最好是用一些专门命令进行管理</p><h3 id="第四步：加载开机启动程序"><a class="header-anchor" href="#第四步：加载开机启动程序">¶</a>第四步：加载开机启动程序</h3><p>七种预设的<strong>运行级别</strong>各自有一个目录，存放需要开机启动的程序</p><p>😣如果多个<strong>运行级别</strong>需要启动同一个程序，那么这个程序的启动脚本，就会在每个目录都有一个拷贝，这样必然会造成管理上的困扰，如何做到优雅的修改启动脚本？</p><div class="alert success no-icon"><p>Linux 的解决办法，是七个 <code>/etc/rcN.d</code> 目录里列出的程序，都设为链接文件，指向另外一个目录 <code>/etc/init.d</code> ，真正的启动脚本都统一放在这个目录中。init 进程逐一加载开机启动程序，其实就是运行这个目录里的启动脚本</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　$ <span class="built_in">ls</span> -l /etc/rc2.d</span><br><span class="line">　　</span><br><span class="line">　　README</span><br><span class="line">　　S01motd -&gt; ../init.d/motd</span><br><span class="line">　　S13rpcbind -&gt; ../init.d/rpcbind</span><br><span class="line">　　S14nfs-common -&gt; ../init.d/nfs-common</span><br><span class="line">　　S16binfmt-support -&gt; ../init.d/binfmt-support</span><br><span class="line">　　S16rsyslog -&gt; ../init.d/rsyslog</span><br><span class="line">　　S16sudo -&gt; ../init.d/sudo</span><br><span class="line">　　S17apache2 -&gt; ../init.d/apache2</span><br><span class="line">　　S18acpid -&gt; ../init.d/acpid</span><br></pre></td></tr></table></figure><div class="alert info no-icon"><p>🎶/etc/init.d 这个目录名最后一个字母 d，是 directory 的意思，表示这是一个目录，用来与程序 /etc/init 区分</p></div><h3 id="第五步：用户登录"><a class="header-anchor" href="#第五步：用户登录">¶</a>第五步：用户登录</h3><p>开机启动程序加载完毕以后，就要让用户登录了</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292149696.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292149696.png" alt=""></a></div><p>✨一般而言，用户的登录方式有三种（命令行登录、SSH 登陆和图形界面登陆），不同的登录方式存在各自验证用户身份的方式</p><h4 id="命令行登录"><a class="header-anchor" href="#命令行登录">¶</a>命令行登录</h4><div class="alert success no-icon"><p>init 进程调用 getty 程序（意为 get teletype），让用户输入用户名和密码；输入完成后，再调用 login 程序，核对密码（Debian 还会再多运行一个身份核对程序 <code>/etc/pam.d/login</code>），如果密码正确，就从文件 <code>/etc/passwd</code> 读取该用户指定的 shell，然后启动这个 shell</p></div><h4 id="ssh-登录"><a class="header-anchor" href="#ssh-登录">¶</a>ssh 登录</h4><div class="alert success no-icon"><p>这时系统调用 sshd 程序（Debian 还会再运行/etc/pam.d/ssh ），取代 getty 和 login，然后启动 shell</p></div><h4 id="图形界面登录"><a class="header-anchor" href="#图形界面登录">¶</a>图形界面登录</h4><div class="alert success no-icon"><p>init 进程调用显示管理器，Gnome 图形界面对应的显示管理器为 gdm（GNOME Display Manager），然后用户输入用户名和密码。如果密码正确，就读取 /etc/gdm3/Xsession，启动用户的会话</p></div><h3 id="第六步：进入login-shell"><a class="header-anchor" href="#第六步：进入login-shell">¶</a>第六步：进入<code>login shell</code></h3><p>所谓 shell，简单说就是命令行界面，让用户可以直接与操作系统对话，其中用户登录时打开的 shell，就叫做 login shell</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292149090.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292149090.png" alt=""></a></div><div class="alert info no-icon"><p>🎶Debain 默认的 shell 是 <code>Bash</code>，它会读入一系列的配置文件，上一步的三种情况，在这一步的处理，也存在差异</p></div><h4 id="命令行登录-ssh-登录"><a class="header-anchor" href="#命令行登录-ssh-登录">¶</a>命令行登录 &amp; ssh 登录</h4><p>首先读入 <code>/etc/profile</code>，这是对所有用户都有效的配置；然后依次寻找下面三个文件，这是当前用户对<code>bash</code>的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/.bash_profile</span><br><span class="line">~/.bash_login</span><br><span class="line">~/.profile</span><br></pre></td></tr></table></figure><div class="alert info no-icon"><p>🎶这三个文件只要有一个存在，就不再读入后面的文件</p></div><h4 id="图形界面登录-v2"><a class="header-anchor" href="#图形界面登录-v2">¶</a>图形界面登录</h4><div class="alert info no-icon"><p>✨只加载 /etc/profile 和 ~/.profile</p></div><h3 id="第七步：打开non-login-shell"><a class="header-anchor" href="#第七步：打开non-login-shell">¶</a>第七步：打开<code>non-login shell</code></h3><p>完成上一步，Linux 的启动过程已经结束，用户已经可以看到命令行提示符或者图形界面了，但是，为了内容的完整，必须再介绍一下这一步。用户进入操作系统以后，常常会再手动开启一个 shell。这个 shell 就叫做 <code>non-login shell</code>，意思是它不同于登录时出现的那个 shell，不读取 <code>/etc/profile</code> 和 <code>.profile</code> 等配置文件</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292149754.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292149754.png" alt=""></a></div><div class="alert info no-icon"><p>non-login shell 的重要性，不仅在于它是用户最常接触的那个 shell，还在于它会读入用户自己的 bash 配置文件 ~/.bashrc。大多数时候，我们对于 bash 的定制，都是写在这个文件里面的</p></div><p>✨只要运行 ～/.profile 文件，～/.bashrc 文件就会连带运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#~/.profile文件中的一部分代码</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$BASH_VERSION</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">　　　　<span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$HOME</span>/.bashrc&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">　　　　　　. <span class="string">&quot;<span class="variable">$HOME</span>/.bashrc&quot;</span></span><br><span class="line">　　　　<span class="keyword">fi</span></span><br><span class="line">　　<span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>🤔为什么 bash 的设置这么繁琐？不能和 Spring 一样统一配置，统一启动？</p><div class="alert warning no-icon"><p>Bash 的设置之所以如此繁琐，是由于历史原因造成的。早期的时候，计算机运行速度很慢，载入配置文件需要很长时间，Bash 的作者只好把配置文件分成了几个部分，阶段性载入。系统的通用设置放在 /etc/profile，用户个人的、需要被所有子进程继承的设置放在 <code>.profile</code>，不需要被继承的设置放在 <code>.bashrc</code></p></div><h2 id="系统运行级别"><a class="header-anchor" href="#系统运行级别">¶</a>系统运行级别</h2><h3 id="Centos6"><a class="header-anchor" href="#Centos6">¶</a>Centos6</h3><p>系统一共有七个运行级别</p><div class="alert warning no-icon"><p>临时设置</p></div><p>使用<code>runlevel</code>命令查看运行级别,使用<code>init</code>命令调整运行级别</p><div class="alert warning no-icon"><p>永久设置</p></div><p>通过修改 <code>/etc/inittab</code> 可以做到永久性更改启动级别</p><p>00:系统的关机级别 init 1 进入到关机状态</p><p>01:用户的单用户模式 用于修复系统 或重置密码信息,</p><p>02: 系统的多用户模式, 没有网络</p><p>03: 系统的多用户模式 正常系统运行多用户模式级别 有网络</p><p>04:预留级别</p><p>05: 图形化界面</p><p>06: 系统的重新启动级别</p><h3 id="Centos7-运行目标-target"><a class="header-anchor" href="#Centos7-运行目标-target">¶</a>Centos7 运行目标(target)</h3><p><code>/usr/lib/systemd/system/runlevel*target</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl get-default</span><br><span class="line">systemctl set-default &lt;run-target&gt;  # 永久设置</span><br></pre></td></tr></table></figure><p>0(poweroff target):系统的关机级别 init 1 进入到维修模式<br>1(rescue target):用户的单用户模式 用于修复系统 或重置密码信息,<br>2(multi-user target): 系统的多用户模式, 没有网络<br>3(multi-user target): 系统的多用户模式 正常系统运行多用户模式级别 有网络<br>04(multi-user target):预留级别<br>05(graphical target): 图形化界面<br>06(reboot target): 系统的重新启动级别</p><h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2><p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的？</a><br><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html">Linux 的启动流程——阮一峰</a><br><a target="_blank" rel="noopener" href="http://linux.vbird.org/linux_basic/0510osloader.php">开机流程、模组管理与 Loader——鸟哥</a><br><a target="_blank" rel="noopener" href="http://linux.vbird.org/linux_basic_train/unit13.php#13.2">开机流程管理——鸟哥</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/f-ck-need-u/p/7100336.html">Linux 开机详细流程——骏马金龙</a></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/maven-%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" data-tooltip="Maven 工具的使用" aria-label="上一篇: Maven 工具的使用"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/spring-%E6%80%BB%E8%A7%88/" data-tooltip="Spring 总览" aria-label="下一篇: Spring 总览"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/maven-%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" data-tooltip="Maven 工具的使用" aria-label="上一篇: Maven 工具的使用"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/spring-%E6%80%BB%E8%A7%88/" data-tooltip="Spring 总览" aria-label="下一篇: Spring 总览"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>