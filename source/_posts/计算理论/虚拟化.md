---
title: 虚拟化技术概述
toc: true
clearReading: true
thumbnailImagePosition: right
metaAlignment: center
categories: 操作系统
tags: 虚拟化
keywords: 虚拟化
excerpt: 虚拟化
date: 2021-11-18 13:23:39
thumbnailImage:
---
<!-- toc -->


## 概述
:question:什么是虚拟化?

{% alert success no-icon%}

虚拟化是由位于下层的软件模块，通过向上一层软件模块提供一个与它原先所期待的运行环境完全一致的接口的方法，抽象出一个虚拟的软件或硬件接口，使得上层软件可以直接运行在虚拟的环境上
{%endalert%}

:question:虚拟化有什么好处？
{% alert success no-icon%}

虚拟化技术和云计算的提供极为相关。云计算采用服务模式，提供云上创建的存储、计算和高层对象。所提供的服务覆盖从诸如物理体系结构等的底层方面（基础设施即服务IaaS）到诸如软件平台（平台即服务PaaS），再到任意应用层次的服务（软件即服务SaaS）。云服务的提供被虚拟化技术直接驱动，允许为云的用户提供一个或多个虚拟机，供用户自己使用。{% post_link 查看关于服务模式的介绍 "杂项/云服务" %}

另一个好处是，在单台计算机上提供对几个不同操作系统环境的便利访问，虚拟化可用于在一种物理体系结构上提供多种操作系统类型

{%endalert%}

## 虚拟化技术的分类
{% alert success no-icon%}

计算机系统中，从底层至高层依次可分为：**硬件层**、**操作系统层**、**函数库层**、**应用程序层**，虚拟化可以发生在现代计算机系统的各个层次上，不同层次的虚拟化会带来不同的虚拟化概念。
{%endalert%}

{% alert info no-icon%}

在虚拟化中，物理资源通常称为**宿主（Host）**，而虚拟出来的资源通常称为**客户（Guest）**，在对 Guest 的某一层进行虚拟化时，并未对 Host 在哪一层实现它作出要求
{%endalert%}

### 硬件层上的虚拟化
{% alert success no-icon%}

硬件层虚拟化又称为**指令集级虚拟化**是虚拟化粒度是最小的，这种虚拟化技术是指：通过**虚拟硬件层来实现虚拟机**，为客户机操作系统呈现与物理硬件相同或相近的硬件抽象层。即：可将一台物理计算机系统虚拟化为一台或多台虚拟计算机系统，故又可称作**系统级虚拟化**，是最早被提出和研究的一种虚拟化技术，当前存在多种此种技术的具体实现方案，

{%endalert%}

通过硬件虚拟化，每个虚拟计算机系统（简称**虚拟机**）都拥有自己的虚拟硬件（如CPU、内存和设备等），来提供一个独立的虚拟机执行环境。其中每个虚拟机中的操作系统可以完全不同，并且它们的执行环境是完全独立的。由于客户机操作系统所能看到的是硬件抽象层，因此，客户机操作系统的行为和在物理平台上没有什么区别。

在每台虚拟机中都有属于它的虚拟硬件，通过虚拟化层的模拟，虚拟机中的操作系统仍认为是独占系统运行，**这个虚拟化层被称为虚拟机监控器（Virtual Machine Monitor，VMM）**

{% alert info no-icon%}

VMM 对物理资源的虚拟可以归结为三个主要任务：**处理器虚拟化**、**内存虚拟化**和**I/O虚拟化**。其中，**处理器虚拟化是VMM中最核心的部分**（因为访问内存或进行I/O本身就是通过一些指令来实现，依赖于处理器虚拟化技术）
{%endalert%}
### 操作系统层上的虚拟化

操作系统领域一直以来面临的一个主要挑战：**应用程序间存在的相互独立性和资源互操作性之间的矛盾**，即每个应用程序都希望能运行在一个相对独立的系统环境下，不受到其他程序的干扰，同时又能以方便快捷的方式与其他程序交换和共享系统资源

{% alert success no-icon%}

操作系统层上的虚拟化是指：**操作系统的内核提供多个互相隔离的用户态实例**。这些用户态实例（经常被称为容器）对于它的用户来说就像是一台真实的计算机，有自己独立的文件系统、网络、系统设置和库函数等

{%endalert%}

操作系统层虚拟化是操作系统内核主动提供的虚拟化，因此操作系统层上的虚拟化通常非常高效，它的**虚拟化资源和性能开销非常小**，也**不需要有硬件的特殊支持**。但它的**灵活性相对较小**，每个容器中的操作系统通常必须是同一种操作系统。另外，**操作系统层上的虚拟化虽然为用户态实例间提供了比较强的隔离性，但虚拟化粒度比较粗**

操作系统虚拟化技术中，物理机只有唯一的系统内核，不虚拟任何硬件设备。通过使用操作系统提供的功能，多个虚拟环境之间相互隔离。通常所说的容器（Container）技术，如目前为止最流行的容器系统 Docker，即属于操作系统级虚拟化。此外，在不同的场景中，隔离出的虚拟环境也被称作虚拟环境（即 VE，`Virtual Environment`）或虚拟专用服务器（即 VPS，`Virtual Private Server`）

{% alert warning no-icon%}

以容器技术为例，它有自己独特的优点，它的出现，一方面解决了传统操作系统所忽视和缺乏的应用程序间的独立性问题，另一方面，它避免了相对笨重的系统级虚拟化，是一种轻量级的虚拟化解决方案。

容器技术还可以更高效地使用系统资源，由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。此外，容器还具有更快速的启动时间，传统的虚拟机技术启动应用服务往往需要数分钟，而对于容器由于，直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间，大大的节约了应用开发、测试、部署的时间
{%endalert%}

当前通用操作系统更强调**程序间的互操作性**，而缺乏**对程序间相对独立性**的有效支持，然而对于许多分布式系统如 Web 服务、数据库、游戏平台等应用领域，提供高效的资源互操作同保持程序间的相对独立性具有同等重要的意义。

## 操作系统级虚拟化实现

了解操作系统虚拟化的想法后，接下来主要阐述几种操作系统虚拟化的实现方式
### chroot
{% alert success no-icon%}

容器的概念始于 1979 年的 UNIX chroot，它是一个 UNIX 操作系统上的系统调用，用于将一个进程及其子进程的根目录改变到文件系统中的一个新位置，让这些进程只能访问到该目录。这个功能的想法是为每个进程提供独立的磁盘空间。其后在 1982年，它被加入到了 BSD 系统中
{%endalert%}

### LXC
{% alert success no-icon%}

LXC 的意思是 LinuX Containers，它是第一个最完善的 Linux 容器管理器的实现方案，是通过 cgroups 和 Linux namespace 实现的。LXC 存在于 liblxc 库中，提供了各种编程语言的 API 实现，包括 Python3、Python2、Lua、Go、Ruby 和 Haskell 等。与其它容器技术不同的是， LXC 可以工作在普通的 Linux 内核上，而不需要增加补丁。
{%endalert%}
### Docker
{% alert success no-icon%}

Docker 是到现在为止最流行和使用广泛的容器管理系统。它最初是一个叫做 dotCloud 的 PaaS 服务公司的内部项目，后来该公司改名为 Docker。Docker 开始阶段使用的也是 LXC ，之后采用自己开发的 libcontainer 替代了它。不像其它的容器平台，Docker 引入了一整个管理容器的生态系统，这包括高效、分层的容器镜像模型、全局和本地的容器注册库、清晰的 REST API、命令行等等。稍后的阶段， Docker 推动实现了一个叫做 Docker Swarm 的容器集群管理方案
{%endalert%}
### 库函数层上的虚拟化
操作系统通常会通过库函数提供给应用程序一组服务，例如文件操作服务、时间操作服务等。这些库函数可以隐藏操作系统内部的一些细节，使得应用程序编程更为简单。

{% alert success no-icon%}

库函数层上的虚拟化就是：通过**虚拟化操作系统的应用级库函数的服务接口**，使得应用程序不需要修改，就可以在不同的操作系统中无缝运行，从而提高系统间的互操作性

{%endalert%}

如此就解决了操作系统领域的两大难题：**程序间的互操作性**和**相对独立性**
### 应用程序（编程语言）层上的虚拟化

{% alert success no-icon%}

编程语言层上的虚拟机称为语言级虚拟机，例如 `JVM（Java Virtual Machine）` 和微软的 `CLR（Common Language Runtime）`。应用程序层上的虚拟机运行的是**进程级的作业**，所不同的是这些程序所针对的不是一个硬件上存在的体系结构，而是一个虚拟体系结构。这些程序的代码首先被编译为针对其虚拟体系结构的中间代码，再由虚拟机的运行时支持系统翻译为硬件的机器语言进行执行。
{%endalert%}

## 虚拟化模型

在当前的系统级虚拟化解决方案中，全虚拟化应用得非常普遍，典型的有知名的产品有 VirtualBox、KVM、VMware Workstation和 VMware vSphere、Xen。在系统级虚拟化的实现中，`VMM（Virtual Machine Monitor，VMM）` 是一个关键角色。从 Host 实现 VMM 的角度出发，还可以将当前主流的虚拟化技术按照实现结构分为如下三类：**Hypervisor模型**、**宿主模型**、**混合模型**

### Hypervisor模型

Hypervisor 这个术语是在 20 世纪 70 年代出现的，在早期计算机界，操作系统被称为 Supervisor，因而能够在其他操作系统上运行的操作系统被称为 Hypervisor。主流虚拟化产品 VMware 和 Xen 等均采用 Hypervisor 模型（Xen 采用的混合模型与 Hypervisor 模型差别不大，可统称为 Hypervisor 模型）。该模型通过将应用程序运行在多个不同虚拟机内，实现对上层应用程序的隔离。但由于 Hypervisor 模型倾向于每个虚拟机都拥有一份相对独立的系统资源，以提供更为完全的独立性，这种策略造成处于不同虚拟机内的应用程序间实现互操作非常困难。
{% alert warning no-icon%}

例如， 即使是运行在同一台物理机器上，如果处于不同虚拟机内，那么应用程序间仍然只能通过网络进行数据交换，而非共享内存或者文件。
{%endalert%}

{% alert success no-icon%}

在Hypervisor模型中，VMM 可以被看做是一个完备的操作系统，不过和传统操作系统不同的是，VMM 是为虚拟化而设计的，因此还具备虚拟化功能。从架构上来看，首先，所有的物理资源如处理器、内存和I/O设备等都归 VMM 所有，所以，VMM 承担着管理物理资源的责任；其次，VMM 需要向上提供虚拟机用于运行客户机操作系统，所以，VMM 还负责虚拟环境的创建和管理。由于VMM同时具备物理资源的管理功能和虚拟化功能，因此，物理资源虚拟化的效率会更高一些。在安全方面，虚拟机的安全只依赖于 VMM 的安全
{%endalert%}

Hypervisor 模型在拥有虚拟化高效率的同时也有其缺点。由于 VMM 完全拥有物理资源，因此，VMM 需要进行物理资源的管理，包括设备的驱动。设备驱动开发的工作量是很大的。因此，对于Hypervisor模型来说这是个很大的挑战。事实上，在实际的产品中，基于 Hypervisor 模型的 VMM 通常会根据产品定位，有选择地挑选一些 I/O 设备来支持，而不是支持所有的I/O设备。

### 宿主模型

:sparkles:采用这种模型的典型是 KVM、VirtualBox 和 VMware Workstation，宿主模型的优缺点和Hypervisor模型恰好相反：
{% alert success no-icon%}

与 Hypervisor 模型不同，在宿主模型中，物理资源由宿主机操作系统管理。宿主机操作系统是传统操作系统，如 Windows 、Linux等，这些传统操作系统并不是为虚拟化而设计的，因此本身并不具备虚拟化功能，实际的虚拟化功能由 VMM 来提供。VMM 通常是宿主机操作系统独立的内核模块，有些实现中还包括用户态进程，如负责 I/O 虚拟化的用户态设备模型。 VMM 通过调用宿主机操作系统的服务来获得资源， 实现处理器、内存和 I/O 设备的虚拟化。VMM 创建出虚拟机之后，通常将虚拟机作为宿主机操作系统的一个进程参与调度

{%endalert%}

:+1:宿主模型最大的优点是：
{% alert success no-icon%}

- 可以充分利用现有操作系统的设备驱动程序，VMM 无须为各类 I/O 设备重新实现驱动程序，可以专注于物理资源的虚拟化
- 宿主模型也可以利用宿主机操作系统的其他功能，例如调度和电源管理等，这些都不需要 VMM 重新实现就可以直接使用
{%endalert%}

:persevere:宿主模型当然也有缺点：
{% alert success no-icon%}

- **在效率方面**，由于物理资源由宿主机操作系统控制，VMM 需要调用宿主机操作系统的服务来获取资源进行虚拟化，而某些系统服务在设计开发之初并没有考虑虚拟化的支持，因此，VMM 虚拟化的效率和功能会受到一定影响
- **在安全方面**，由于 VMM 是宿主机操作系统内核的一部分，虚拟机的安全不仅依赖于 VMM 的安全，也依赖于宿主机操作系统的安全
{%endalert%}

### 混合模型
混合模型是上述两种模式的汇合体，采用这种模型的典型是 Xen，其中VMM 依然位于最低层，拥有所有的物理资源。

:+1:混合模型集中了上述两种模型的优点：
{% alert success no-icon%}

- 与 Hypervisor 模式不同，混合模型的 VMM 会主动让出大部分 I/O 设备的控制权，将它们交由一个运行在特权虚拟机中的特权操作系统控制，I/O 设备虚拟化由 VMM 和特权操作系统共同完成。因此，设备模型模块位于特权操作系统中，并且通过相应的通信机制与 VMM 合作
- VMM 直接控制处理器、内存等物理资源，提高虚拟化的效率
- 在安全方面，如果对特权操作系统的权限控制得当，虚拟机的安全性只依赖于 VMM。
{%endalert%}

:persevere:混合模型也存在缺点：

{% alert success no-icon%}

由于特权操作系统运行在虚拟机上，当需要特权操作系统提供服务时，VMM 需要切换到特权操作系统，这里面就产生上下文切换的开销。当切换比较频繁时，上下文切换的开销会造成性能的明显下降
{%endalert%}

## 附录

[虚拟化技术的分类及介绍](https://zhuanlan.zhihu.com/p/102809005)
