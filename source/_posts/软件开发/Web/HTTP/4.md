---
title: HTTP（四）HTTP 摘要认证
toc: true
clearReading: true
thumbnailImage: "https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/http权威指南.jpg"
thumbnailImagePosition: right
metaAlignment: center
categories: Web
tags: HTTP
keywords: HTTP 摘要认证
excerpt: 本文继 HTTP 基本认证之后，阐述 HTTP 中的摘要认证技术
date: 2022-01-31 01:08:50
---

<!-- toc -->

## 用摘要保护密码

{% alert success no-icon %}

摘要认证遵循的箴言是「 绝不通过网络发送密码 」。客户端不会发送密码，而是会发送一个「 指纹 」或密码的「 摘要 」，这是密码的哈希。客户端和服务器都知道这个密码，因此服务器可以验证所提供的摘要是否与密码相匹配。

{% endalert %}

对于第三者，如果单独只有摘要的话，想要逆向获得密码，他除了将所有的密码都拿来试试之外，没有其他方法可以找出摘要是来自哪个密码，这样就可以保证最终用户密码的安全性！

{% image fancybox fig-100  center https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/摘要实现隐藏密码的认证.png %}

:boat: 在上图，客户端请求了某个受保护文档。

1. 在客户端能够证明其知道密码从而确认其身份之前，服务器拒绝提供文档，随后服务器向客户端发起质询，询问用户名和摘要形式的密码。

2. 随后，客户端传递了密码的摘要，证明它是知道密码的。服务器知道所有用户的密码（实际上，服务器只需要知道密码的摘要即可）因此可以将客户提供的摘要与服务器自己计算得到的摘要进行比较，以验证用户是否知道密码。另一方在不知道密码的情况下，很难伪造出正确的摘要。

3. 最终，服务器将客户端提供的摘要与服务器内部计算出的摘要进行对比。 如果匹配，就说明客户端知道密码，服务器会将文档提供给客户端——整个过程都没有在网络上发送密码

{% alert info no-icon %}

:notes: 如果只是简单的摘要，很容易被第三方猜测到，因此可以设置摘要函数，使其产生很多数字，让第三方不可能幸运地猜中摘要。

{% endalert %}

## 单向摘要

{% alert info no-icon %}

摘要是「 对信息主体的浓缩 」，摘要本质是一种单向函数，主要用于将无限的输入值转换为有限的浓缩输出值。常见的摘要函数 MD5，会将任意长度的字节序列转换为一个 128 位的摘要。MD5 表示「 报文摘要的第五版 」，是摘要算法系列中的一种。安全散列算法（Secure Hash Algorithm， SHA）是另一种常见的摘要函数。
{% endalert %}

理论上来讲，我们将数量无限的输入值转换成了数量有限的输出值，所以两个不同的输入值就可能映射为同一个摘要。这种情况被称为冲突（collision）。实际上，由于可用输出值的数量足够大，所以在现实生活中，出现冲突的可能是微乎其微的，对我们要实现的密码匹配来说并不重要

对这些摘要来说，同时满足以下两点就可以说明设计了一个很好的摘要函数：
{% alert info no-icon %}

- 如果在不知道密码的情况下，非常难猜出发送给服务器的摘要；
- 如果在知道有摘要的情况下，非常难判断出它是由无数输入值中的哪一个产生的

{% endalert %}

### 用随机数防止重放攻击

{% alert success no-icon %}

使用单向摘要就无需以明文形式发送密码了。可以只发送密码的摘要，而且可以确信，没有哪个恶意用户能轻易地从摘要中解码出原始密码，但是，仅仅隐藏密码并不能避免危险，因为即便不知道密码，别有用心的人也可以截获摘要，并一遍遍地重放给服务器。

{% endalert %}

为防止此类重放攻击的发生，服务器可以向客户端发送一个称为随机数（nonce）的特殊令牌，这个数会经常发生变化（可能是每毫秒，或者是每次认证都变化）。客户端在计算摘要之前要先将这个随机数令牌附加到密码上去。在密码中加入随机数会使摘要随着随机数的每一次变化而变化。记录下的密码摘要只对特定的随机值有效，而没有密码的话，攻击者就无法计算出正确的摘要，这样就可以防止重放攻击的发生

随机数是在 WWW-Authenticate 质询中从服务器传送给客户端的，随机数这个词表示「 本次 」或「 临时的 」。
