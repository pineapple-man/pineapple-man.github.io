---
title: 服务的状态
toc: true
clearReading: true
thumbnailImagePosition: right
metaAlignment: center
thumbnailImage:
categories: 其他
tags: 操作系统
keywords: 状态
excerpt: 经常听到什么有状态服务，无状态服务，这些概念究竟想要表达什么含义？
---
**有状态服务**和**无状态服务**是两种不同的服务架构，两者的不同之处在于对于服务状态的处理，本文将主要记录：什么是状态？不同的状态会对服务产生什么样的影响、以及为什么如今都倡导无状态服务？
![](https://gitee.com/mingchaohu/blog-image/raw/master/image/stateful-and-stateless-applications.webp)
## 概述
在了解服务的装填之前，先了解应用的状态
理解有状态和无状态应用程序的概念是大多数架构和设计所基于的基础——像 RESTful 设计这样的概念是建立在这些基础上的，因此拥有一个可靠的逻辑框架是至关重要的
一个无状态应用程序或进程是不保存或引用有关先前操作的信息的东西。每次它都像第一次一样从头开始执行每个操作，并提供使用打印、CDN（内容交付网络）或 Web 服务器的功能来处理每个短期请求。
{% alert success no-icon%}

例如，有人在搜索引擎中搜索问题并按下了 Enter 按钮。如果搜索操作由于某种原因被中断或关闭，您必须重新开始，因为没有为您之前的请求保存数据。
{%endalert%}
有状态应用程序会记住用户的特定详细信息，例如个人资料、首选项和用户操作。该信息被视为系统的“状态”。

例如：在网购时（某宝或者某东），每次您选择一个商品并将其添加到您的购物车时，您都会将它与之前添加的商品一起添加，并最终导航到结帐页面，每次添加新商品时，不会丢失之前的任何信息

无状态服务不会记录服务状态，不同请求之间也是没有任何关系；而有状态服务则刚好相反，不同的请求之间是有关联关系的。判断一个服务状态性最简单的标识就是：两个来自相同发起者的请求在服务端是否具有上下文关系


:question:什么是服务的状态？
{% blockquote RedHat https://www.redhat.com/zh/topics/cloud-native-apps/stateful-vs-stateless "云原生下应用的状态" %}
The state of an application (or anything else, really) is its condition or quality of being at a given moment in time--its state of being. Whether something is stateful or stateless depends on how long the state of interaction with it is being recorded and how that information needs to be stored. 
应用（或其他任何事物）的状态是指它在特定时间的状况或品质，即当前应用的一种存在属性（运行中活宕机了）。要判断一个应用是有状态还是无状态的，取决于和这个应用交互的过程中，当前这种交互状态维持的时间以及需要在这个过程中需要存储的信息
{% endblockquote%}

## 有状态与无状态会话
有状态和无状态应用程序将来自客户端请求的状态存储在服务器本身上，并使用该状态来处理进一步的请求。它使用 DB 作为后端存储数据，但会话信息存储在服务器本身。当用户发送登录请求时，它使登录成为真实并且用户现在通过身份验证，并且在第二个请求中，用户看到仪表板。有状态应用程序不需要第二次调用 DB 作为会话信息存储在服务器本身上。因此它更快。但它确实有缺点。
有一个负载均衡器，后面有两台服务器，运行同一个有状态的应用程序。第一个登录请求会转到服务器 1，第二个请求可能会转到服务器 2；现在，由于只有服务器启用了登录才能为真，当 LB 将他发送到第二台服务器时，用户将无法进行逻辑处理。所以不可能水平扩展有状态的应用程序

## 无状态和有状态的容器管理
尽管无状态应用程序以不同的方式工作，但它们不会在服务器上存储任何状态。他们使用 DB 来存储所有信息。DB 是有状态的，即它具有附加的持久存储。通常，用户请求使用凭据登录，LB 后面的任何服务器都会处理该请求，生成一个 auth 令牌，将其存储在 DB 中，然后将令牌返回给前端的客户端。下一个请求与令牌一起发送，现在，无论哪个服务器处理请求，它都会将令牌与数据库中的信息进行匹配，并授予用户登录权限。每个请求都是独立的，与前一个或下一个请求没有任何联系，就像 REST 一样。尽管无状态应用程序有一个额外的调用 DB 的开销，但这些应用程序在水平扩展方面非常出色，这对于可能拥有数百万用户的现代应用程序至关重要。现代应用程序和遗留应用程序具有一个共同特征，即是否存储状态。无论是处理 Monoliths 还是微服务取决于应用程序的需求'；有些需要存储状态，而有些不需要关心状态

## 有状态应用程序与无状态应用程序之间的区别
有状态和无状态应用程序在互联网中无处不在，但是现代大部分软件是以无状态方式构建的，因为可伸缩性是如今非常重要的一个因素

![](https://gitee.com/mingchaohu/blog-image/raw/master/image/xenonstack-stateful-vs-stateless.webp)

有状态和无状态应用程序之间的八个主要区别是：

工作状态：有状态的应用程序根据当前状态做出下一步反应，而无状态的应用程序不会考虑上一个/下一个请求，对于每一个请求都是相同的处理逻辑

存储数据：如果 Web 服务器存储数据并使用它来将用户标识为始终连接的客户端，则该服务是有状态的。在无状态时，服务器确实存储数据，但随后通过数据库去验证用户/客户端曾经是否登录

对客户端的反应：在 Stateful 中，服务器认为客户端只是一台愚蠢的机器，而在 Stateless 中，服务器端的客户端是一台智能机器，不需要依赖于服务器端的任何状态

请求：在无状态中，请求是自包含的，即请求中包含的所有内容，并在两个不同的阶段处理这些请求，“请求”和“响应”。在有状态时，请求始终依赖于服务器端状态。

生成状态：在浏览互联网时，状态生成并存储在某处。虽然在这两种类型中生成的状态都存储在服务器上时，它会生成一个会话。这称为有状态应用程序。

状态存储：当客户端存储状态时，它会生成一些用于进一步请求的数据，而技术上“有状态”因为它引用了一个状态，但状态由客户端存储，因此称为无状态

Cookie 存储：在客户端，cookie 存储身份验证数据。在服务器端，创建临时客户端数据或存储在数据库中（这是典型情况）。在返回仪表板进行另一次付款时，它是一个存储在浏览器中的 cookie，用于与服务器建立状态

用户群：当有单体应用而没有动态用户群时，Stateful 已经过去了。无状态是未来，微服务随处可见，并且主要通过 REST 接口和类似缩放的任何东西进行通信，因为没有存储状态。

## 为什么无状态应用很重要
以前有状态应用程序运行良好，为什么还需要无状态应用程序？
有状态的应用程序非常适合最小的用例，但它有一些问题。首先，当用户在服务器上引用一个状态时，用户打开了很多不完整的会话和交易发生

在Stateful系统中，客户端计算出的状态，系统应该让连接保持多久？

如何在服务器端验证客户端是否崩溃或与会话断开连接？

在维护文档更改和回滚的同时如何跟踪用户的操作？

大多数消费者/客户端以智能、动态的方式响应服务器，从而在假设客户端只是一个“哑巴”的情况下保持独立于客户端的服务器状态；客户很浪费。

无状态是现代应用程序的一个基本方面——每一天；它使用各种无状态服务和应用程序。它使用 HTTP 以无状态方式连接，利用在彼此隔离和客户端状态下呈现和工作的消息。

Facebook 不断使用无状态服务。当服务器使用 Facebook API 请求最近消息的列表时，它会发出一个带有令牌和日期的 GET 请求。响应独立于任何服务器状态，一切都以缓存的形式存储在客户端的机器上

类似地，调用 POST 命令，在不考虑服务器状态的情况下，在标头中传递带有授权/身份验证数据的复杂主体

与上一个、当前和下一个请求没有关系。在无状态中，客户端不会等待来自服务器的同步。

REST 是设计、架构和开发现代 API 的主流方式，而具象状态传输 (REST) 是无状态的。

## 无状态应用程序如何工作
无状态架构意味着应用程序仅依赖于第三方存储，因为它不会在内存或磁盘上存储任何类型的状态。它需要或请求所有数据都必须从其他有状态服务（数据库）获取或存在于 CRUD 请求中


![](https://gitee.com/mingchaohu/blog-image/raw/master/image/xenonstack-how-stateless-applications-works.png)

第 1 步：请求负载均衡到无状态服务的任何副本，因为它所有数据都存储在其他地方，通常是具有持久存储的数据库

第 2 步：当有状态应用程序中的并发用户数量增加时，添加更多运行相同程序的服务器（横向扩展），并使用负载平衡器在这些服务器之间均匀分配负载。但是由于每个服务器“记住”每个登录用户的状态，因此有必要在“粘性模式”下配置此负载平衡器

第 3 步：跨服务器分配负载，负载均衡器需要将每个用户的请求发送到响应该用户先前请求的同一台服务器，以正确处理请求，这违背了负载均衡的目的，因为负载不以真正的循环方式分发。

第 4 步：服务器端逻辑的编码方式不依赖于客户端的“先前存储的状态”。

第 5 步：状态信息与每个请求一起发送到服务器，服务器通过该服务器继续为请求提供服务。Load-balancer 不需要担心将请求路由到同一台服务器，真正实现了负载均衡。 第 6 步：负载均衡器将流量发送到任何服务良好的服务器和请求，因为客户端在每个请求中发送令牌或其他需要的信息。JSON Web Token (JWT) 广泛用于创建无状态应用程序
## 无状态应用程序的好处
以下是无状态应用程序的 5 个主要优点：
消除创建/使用会话的开销
横向扩展以满足现代用户的需求
按需添加/删除应用程序的新实例
它允许跨各种应用程序的一致性
无状态使应用程序更易于使用和可维护

无状态应用程序的其他扩展和性能优势如下：
减少服务器端的内存使用
消除会话过期问题——有时，过期会话会导致难以发现和测试的问题。无状态应用程序不需要会话，因此它们不会受到这些影响。
从用户的角度来看，无状态允许资源可链接。如果页面是无状态的，那么当用户将朋友链接到该页面时，它可以确保用户查看的内容与其他用户查看的内容相同


## 如何采用无状态应用程序
以下是采用无状态应用程序的 5 个步骤

第 1 步：适应和开发新应用程序
采用无状态应用程序起初可能是一项艰巨的任务，因为它是一种新范式。但是，通过正确的思维方式和信息，可以在不保持任何状态的情况下适应和开发新的应用程序。使用身份验证/授权连接到服务器

第 2 步：使用微服务开发应用程序
在此步骤中，将出于部署目的进行容器化。容器最擅长运行无状态工作负载。当需要管理的多个容器增加时，可以考虑切换到 Kubernetes 等云编排和管理工具来运行大量容器

第 3 步：容器化微服务应用程序
从资源点找到运行安全的容器的最佳位置，并维护应用程序的高可用性

第 4 步：将存储附加到无状态临时文件
附加到无状态的存储是短暂的。组织必须从无状态容器开始，因为它们更容易适应这种类型的架构，并且与单体应用程序分离并独立扩展

第 5 步：应用 REST 哲学
后端应该使用 REST 设计模式来构建应用程序。REST 哲学不是维护状态，只是在客户端稍微维护 cookie 和本地存储

### 无状态服务

无状态请求，服务器端所能够处理的数据全部来自于请求所携带的信息，无状态服务对于客户端的单次请求的处理，不依赖于其他请求，处理一次请求的信息都包含在该请求里。最典型的就是通过cookie保存token的方式传输
请求数据。也可以理解为Cookie是通过客户端保持状态的解决方案
{% image fancybox fig-100  center  https://gitee.com/mingchaohu/blog-image/raw/master/image/image-20211102194130571.png%}

## 无状态应用程序的最佳实践
尝试不惜一切代价避免session。
session增加了不必要的复杂性，但价值却很少。
重现错误变得困难。
由于所有内容都存储在服务器端，因此很难修复与会话相关的错误。
无法扩展会话。
如果应用程序的负载呈指数增长，请将负载分配到不同的服务器。如果使用会话，请同时将所有会话复制到所有服务器。该系统变得非常复杂且容易出错。避免会话。
会话仅对特定用例有用，例如 FTP（文件传输协议）。
对于共享 Dropbox 等用例，有状态会话会增加额外的开销，而无状态则是完美的方式。
会话功能使用 cookie 复制，在客户端缓存。

## 无状态应用程序工具
最好的无状态应用程序工具如下：
Python、Golang等现代语言 。
出于部署目的—— 容器和编排，例如 Docker 和 Kubernetes。
其他服务发现 ——Kube 代理服务等。
API 网关 – 从外部连接到各种服务。
对于围绕所有无状态应用程序的服务网格：LinkedD/Istio
### 有状态服务

有状态服务则相反，服务会存储请求上下文相关的数据信息，先后的请求是可以有关联的。例如，在Web 应用
中，经常会使用Session 来维系登录用户的上下文信息。虽然http 协议是无状态的，但是借助Session，可以使
http 服务转换为有状态服务

{% image fancybox fig-100  center  https://gitee.com/mingchaohu/blog-image/raw/master/image/image-20211102194134064.png %}

为什么如今都倡导无状态？
{% alert success no-icon%}

无状态能够让系统得到一种特性：伸缩性（scaliability）
{%endalert%}


## 

## 附录



:question:什么是一个应用的状态？

- 它在特定时间的状况或品质，即它的存在状态。

如果同一时刻同一个请求产生的数据的状态大于一，则是有状态的，只有一个状态则为无状态

:question:如何判断一个应用是有状态还是无状态的

要判断一个应用为有状态或无状态，取决于交互状态的**记录时长**以及**该信息所需的存储方式**



## 无状态应用

无状态进程或应用可以理解为孤立的。关于它的既往事务，我们一无所知，没有任何参考。每项事务处理似乎都是从头开始。无状态应用只提供一项服务或功能，并使用内容交付网络（CDN）、Web 或打印服务器来处理这些短期请求。 

无状态事务的典型示例是执行在线搜索，寻找您想要的答案。您在搜索引擎中输入问题，然后按 Enter。如果您的事务被意外中断或关闭，则只需重新开始即可。我们不妨将无状态事务看作一台自动售货机：一个请求对应一个响应。 

## 有状态应用

有状态应用和流程则是可以周而复始、反复发生的应用和流程，例如网上银行或电子邮件。

这些操作是在先前的事务背景下执行的，当前事务可能会受到先前事务的影响。正因如此，有状态应用在每次处理用户的请求时**都会使用相同的服务器**

如果有状态事务被中断，其上下文和历史记录会被存储下来，这样就可以或多或少地从上次中断的地方继续。

有状态应用会跟踪诸如窗口位置、设置首选项和近期活动等内容。我们可以把有状态事务视为与同一个人进行的定期对话。

## 容器与状态

随着云计算和微服务的普及，无论是有状态还是无状态应用，其容器化程度都在不断提高。容器时一组打包在一起的应用代码以及他们的库和依赖项，这样一来，他们就可以轻松移动并能在任何环境中运行——无论是在台式机、传统IT基础架构上，还是在云端

最初，容器被构建为无状态，因为这比较符合其便携、灵活的特性。但随着容器的广泛使用，人们开始对现有的有状态应用进行容器化处理（重新设计和重新封装，以实现从容器运行）。这在为他们赋予容器的灵活性和速度的同时，也提供了有状态应用的存储和上下文。

正因为这个原因，有状态应用越来越像无状态应用，无状态应用向有状态应用靠近的趋势，如：存在一个无状态的应用，它不需要长期存储，但允许服务器使用 Cookie 来跟踪同一客户端的请求



## 无状态和有状态容器管理

有状态现在已成为容器存储的主体，而现在的问题从要不要使用有状态容器，变成了该如何使用

究竟是使用有状态还是无状态容器，要取决于构建哪种类型的应用以及用途。如果只是临时需要信息（快速而短暂），无状态便是解决之道。但如果应用需要更多的内存来存储从一个会话到下一个会话的操作，则应用采用有状态方式



## 有状态服务

有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如 tomcat 中的 session。

例如登录：用户登录后，我们把登录者的信息保存在服务端 session 中，并且给用户一个 cookie 值，记录对应的 session。然后下次请求，用户携带 cookie 值来，我们就能识别到对应 session，从而找到用户的信息。

:persevere:有状态的缺点

- 服务端保存大量数据，增加服务端压力
- 服务端保存用户状态，无法进行水平扩展
- 客户端请求依赖服务端，多次请求必须访问同一台服务器
状态化的判断是指两个来自相同发起者的请求在服务器端是否具备上下文关系。

有状态服务仍然存在优点
数据定位（可通过函数传递范例来实现）、高可用和强并发模式。

数据局部性是指每个请求都会被路由到（“运送到”）可以操作数据的机器上。当一个请求做到时第一次命中了数据存储，之后处理数据的请求离开了服务，在将来来自内存中的数据可以让类似的请求更快的找到同样的服务。结果就是低延时的好处，毋需再去访问数据存储。这就是“函数传递范例”，是有状态服务和无状态服务区别的关键所在

有状态的服务通常会导致强一致性的模式。根据 CAP 理论（一致性、可用性、容忍网络分区），基本上说构建一个满足三种所有属性是几乎不可能的。这里有一个非常容易理解的有关于 CAP 概念的问答，然而没有那个分布式系统能够避免“P”。现实世界是要么选择可用性胜过一致性，这称之为 AP；要么选择一致性胜过可用性，这称之为 CP。有状态的服务可以构建一种粘性的链接，也就是说客户端的请求总是会被路由到原来为之提供服务的服务器主机上。以此方式实现的服务，可以增加 AP 系统的一致性力度。这些强的模式包括有线性随机访问内存和读你所写（Read your Write）

https://en.wikipedia.org/wiki/PRAM_consistency
第一种实现是所有的请求所看到的写入都来自一个有序的请求，由它们自己所发出的
。第二种实现是一旦请求要写，它就会读区更新后的值，且永远不会再理会旧的值。
Werner Vogels在他的文章中总结了这些内容：
https://www.allthingsdistributed.com/2008/12/eventually_consistent.html

无论是否是读你所写、会话以及单调的一致性，这些的实现通常都依赖于“无粘性”都客户端到服务器，为它们执行分布式的协议。如果这每次都是同一台服务器的话，相对能够容易保证读你所写和 monotonic 读取。这就对负载均衡和容错稍有难度，但是它是一个较简单的解决方案。使用粘性的会话，可以更加明确以及提供抛出的客户推理的水平。

McCaffrey 谈到业界通常聚焦于无状态的服务是为了实现可扩展性而忽略了有状态的服务， Eric Evans 在他的书领域驱动开发中写道：

当在某域中的某个重要的进程或转换不是天生的负责一个实体或值的对象时，为模式增加一操作作为独立的接口来声明一个服务。定义接口是模型预言中的一个术语，还要确保操作的名称是无处不在的语言的一部分。将服务成为无状态的。
无状态的服务很容易的通过给后端添加服务器和前端的负载均衡实现横向的扩展。此类应用拥有叫做“数据运送范例”的方式，就是数据被请求时是来自后端的数据存储为请求提供，在未来的请求中，若相同的数据被请求时，是不会去关心这些请求是从哪个服务实例来的，因为服务实例是无状态的


此模式会放之四海而皆准吗？McCaffrey 谈到在“通信频繁”的应用中简直是一种浪费，因为这些应用要在服务端与客户端之间频繁的通信，而且在此类应用中有状态的服务显然是一种更好的选择。
Kai Wähner同意并列举了有状态服务的优点：

当状态是共享的跨调用时，开发是容易的；
不需要额外的持久存储；
通常，为低延时优化。
粘性连接可以使用持久性的连接来实现，但是会带来负载在后端分布不均的问题，这就会导致客户端捆绑到服务器，而有些服务器不能得到充分利用，而有些服务器却负载过多。其中一个减轻此种[后端压力](http://mechanical-sympathy.blogspot.in/2012/05/apply-back-pressure-when-overloaded.html)的方法就是一旦达到某个阀值就拒绝再来的请求。非粘性的服务还可以通过路由的逻辑来实现，这可以使得任何的客户端通过获得正确的路由来找到任何的服务器。此实现会带来两个问题，路由到集群成员（谁在我的集群中？）和工作分布（谁来做？）。集群成员可以是静态的也可以是动态的。后者可以通过使用[ gossip 协议](https://en.wikipedia.org/wiki/Gossip_protocol)和[共识](https://en.wikipedia.org/wiki/Consensus_(computer_science))系统来实现。工作分布则有更多的实现机制－随机替代、[一致性哈希](https://en.wikipedia.org/wiki/Consistent_hashing)、以及[分布式哈希表]

三个有状态服务的真实案例：

- [Scuba ](https://research.facebook.com/publications/456106467831449/scuba-diving-into-data-at-facebook/)，一个 Facebook 所使用的内存数据库，用于代码分析、bug 报告、调试性能等。单个的请求会分散到多个后端服务器，然后将响应收集起来，最后决定如何将经过量化的响应完整的返回。
- 优步的[ Ringpop ](https://github.com/uber/ringpop-node)，一个应用层的切片库，也提供了请求转发。
- [Orleans ](http://research.microsoft.com/en-us/projects/orleans/)，来自[微软研究所](http://research.microsoft.com/en-us/default.aspx)的基于行为的分布式系统编程[模型](http://research.microsoft.com/pubs/210931/Orleans-MSR-TR-2014-41.pdf)

有状态的模式其实在[ MMO ](https://en.wikipedia.org/wiki/Massively_multiplayer_online_game)的开发世界中是[见惯不怪的](https://gameserverarchitecture.com/2015/11/presentation-building-scalable-stateful-services/)，近期有很多其它领域的也在[大量的采用这些模式](https://twitter.com/boulderDanH/status/655839187170496512)，上面的例子就是明证。

在采访快结束的时候，McCaffrey 讨论了通过从进程的生命周期解藕内存的生命周期，[ Facebook 是如何管理 Scuba 的快速重启的](https://research.facebook.com/publications/553456231437505/fast-database-restarts-at-facebook/)。在 Scuba 所在的机器重启后，会花费很长的时间去从磁盘读入数据。要解决此问题就是将这些基于内存的数据从将要宕机的机器中复制到一个共享的地方，当节点恢复后再复制回来。

McCaffrey 在他的演讲中列出了一些构建有状态服务的陷阱，其中包括没有绑定的数据结构导致的内存问题、类似长期的垃圾回收暂停和重载状态时出现的内存管理问题等。状态重载会在恢复和部署新代码时发生，这两者都会像第一次从数据库中获取数据那样付出高昂的代价。

[ Scaling Stateful Services ](http://www.infoq.com/news/2015/11/scaling-stateful-services)


如果是状态化请求，那么服务器端一般都要保存请求的相关信息，每个请求可以默认地使用以前的请求信息。

而无状态的请求，服务器端的处理信息必须全部来自于请求所携带的信息以及可以被所有请求所使用的公共信息。

无状态的服务器程序，最著名的就是WEB服务器。

状态化的服务器有更广阔的应用范围，比如MSN、网络游戏等服务器。他在服务端维护每个连接的状态信息，服务端在接收到每个连接的发送的请求时，可以从本地存储的信息来重现上下文关系。

纯函数式编程，就是无状态的。有状态，也叫有副作用。
无状态的服务易伸缩： 很容易的通过给后端添加服务器和前端的负载均衡实现横向的扩展。
当系统中存在着大量「有状态」的业务处理过程时，伸缩扩展就会变得复杂起来。

是指该服务的实例可以将一部分数据随时进行备份，并且在创建一个新的有状态服务时，可以通过备份恢复这些数据，以达到数据持久化的目的。有状态服务只能有一个实例，因此不支持“自动服务容量调节”。一般来说，数据库服务或者需要在本地文件系统存储配置文件或其它永久数据的应用程序可以创建使用有状态服务。要想创建有状态服务，必须满足几个前提：
待创建的服务镜像（image）的Dockerfile中必须定义了存储卷（Volume），因为只有存储卷所在目录里的数据可以被备份
创建服务时，必须指定给该存储卷分配的磁盘空间大小
如果创建服务的同时需要从之前的一个备份里恢复数据，那么还要指明该存储卷用哪个备份恢复。


程序做的事情本质上就是**数据的移动和组合**，以此来达到我们所期望的结果。而如何移动、如何组合是由“算法”来定的。通过程序处理所得到的“成果”其实和你平时生活中完成的任何事情所得到的“成果”是一样的。任何一个“成果”都是你通过一系列的“行动”将最开始的“原料”进行加工、转化，最终得到你所期望的“成果”。
![](https://gitee.com/mingchaohu/blog-image/raw/master/image/state1.png)

比如，你将常温的水，通过“倒入水壶”、“通电加热”等工作后变成了100度的水，就是这样一个过程。

正如烧水的例子，大多数时候得到一个“成果”往往需要好几道“行动”才能完成。
![](https://gitee.com/mingchaohu/blog-image/raw/master/image/state2.png)
这个时候如果想降低这几道“行动”总的成本（如：时间）该怎么办呢？

自然就是提炼出反复要做的事情，让其只做一次。而这个事情在程序中，就是将一部分“数据”放到一个「暂存区」（一般就是本地内存），以提供给相关的“行动”共用。
![](https://gitee.com/mingchaohu/blog-image/raw/master/image/state3.png)
但是如此一来，就导致了需要增加一道关系，以表示每一个“行动”与哪一个「暂存区」关联。因为在程序里，“行动”可能是「多线程」的。

这时，这个“行动”就变成「有状态」的了
![](https://gitee.com/mingchaohu/blog-image/raw/master/image/state4.png)

共用同一个「暂存区」的多个“行动”所处的环境经常被称作「上下文」。
「暂存区」里存的是「数据」，所以可以理解为“有数据”就等价于“有状态”
「数据」在程序中的作用范围分为「局部」和「全局」（对应局部变量和全局变量），因此「状态」其实也可以分为两种，一种是局部的「会话状态」，一种是全局的「资源状态」

因为有些服务端不单单负责运算，还会提供其自身范围内的「数据」出去，这些「数据」属于服务端完整的一部分，被称作「资源」。所以，理论上「资源」可以被每个「会话」来使用，因此是全局的状态

与「有状态」相反的是「无状态」，「无状态」意味着每次“加工”的所需的“原料”全部由外界提供，服务端内部不做任何的「暂存区」。并且请求可以提交到服务端的任意副本节点上，处理结果都是完全一样的
有一类方法天生是「无状态」，就是负责表达移动和组合的“算法”。因为它的本质就是：
接收“原料”（入参）
“加工”并返回“成果”（出参）

为什么网上主流的观点都在说要将方法多做成「无状态」的呢？
因为我们更习惯于编写「有状态」的代码，但是「有状态」不利于系统的易伸缩性和可维护性
在分布式系统中，「有状态」意味着一个用户的请求必须被提交到保存有其相关状态信息的服务器上，否则这些请求可能无法被理解，导致服务器端无法对用户请求进行自由调度（例如双11的时候临时加再多的机器都没用）。
同时也导致了容错性不好，倘若保有用户信息的服务器宕机，那么该用户最近的所有交互操作将无法被透明地移送至备用服务器上，除非该服务器时刻与主服务器同步全部用户的状态信息
但是如果想获得更好的伸缩性，就需要尽量将「有状态」的处理机制改造成「无状态」的处理机制

## 无状态化处理
将「有状态」的处理过程改造成「无状态」的，
首先，状态信息前置，丰富入参，将处理需要的数据尽可能都通过上游的客户端放到入参中传过来
![](https://gitee.com/mingchaohu/blog-image/raw/master/image/state5.png)

当然，这个方案的弊端也很明显：网络数据包的大小会更大一些。
另外，客户端与服务端的交互中如果涉及到多次交互，则需要来回传递后续服务端处理中所需的数据，以避免需要在服务端暂存
![](https://gitee.com/mingchaohu/blog-image/raw/master/image/state6.png)
橙色请求，绿色响应

这些改造的目的都是为了尽量少出现类似下面的代码。
```java
int func(){
    return i++;
}
```
而是变成
```java
int func(i){
    return i+1;
}
```
要更好的做好这个「无状态」化的工作，依赖于你在架构设计或者项目设计中的合理分层
尽量将会话状态相关的处理上浮到最前面的层，因为只有最前面的层才与系统使用者接触，如此一来，其它的下层就可以将「无状态」作为一个普遍性的标准去做
与此同时，由于会话状态集中在最前面的层，所以哪怕真的状态丢失了，重建状态的成本相对也小很多
比如三层架构的话，保证BLL和DAL都不要有状态，代码的可维护性大大提高
如果是分布式系统的话，保证那些被服务化的程序都不要有状态。除了能提高可维护性，也大大有利于做灰度发布、A/B测试
：在这里，提到做分层的目的是为了说明，只有将IO密集型程序和CPU密集型程序分离，才是通往「无状态」真正的出路。一旦分离后，CPU密集型的程序自然就是「无状态」了
如此也能更好的做「弹性扩容」。因为常见的需要「弹性扩容」的场景一般指的就是CPU负荷过大的时候
最后，如果前面的都不合适，可以将共享存储作为降级预案来运用，如远程缓存、数据库等。然后当状态丢失的时候可以从这些共享存储中恢复
所以，最理想的状态存放点。要么在最前端，要么在最底层的存储层
![](https://gitee.com/mingchaohu/blog-image/raw/master/image/state7.png)
任何事物都是有两面性的，正如前面提到的，我们并不是要所有的业务处理都改造成「无状态」，而只是挑其中的一部分。最终还是看“价值”，看“性价比”
比如，将一个以“状态”为核心的即时聊天工具的所有处理过程都改造成「无状态」的，就有点得不偿失了

# 无状态服务

客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份。服务端不保存任何客户端请求者信息。

:sparkles:无状态服务特点

- 客户端请求不依赖服务端的信息，任何多次请求不需要必须访问到同一台服务
- 服务端的集群和状态对客户端透明
- 服务端可以任意的迁移和伸缩
- 减小服务端存储压力


无状态服务是指服务运行的实例不会在本地存储需要持久化的数据，并且多个实例对于同一个请求响应的结果是完全一致的。这类服务在网易蜂巢云平台创建后，借助k8s内部的负载均衡，当访问该服务的请求到达服务一端后，负载均衡会随机找到一个实例来完成该请求的响应（目前为轮询）。这类服务的实例可能会因为一些原因停止或者重新创建（如扩容时），这时，这些停止的实例里的所有信息（除日志和监控数据外）都将丢失(重启容器即会丢失)。因此如果您的容器实例里需要保留重要的信息，并希望随时可以备份以便于以后可以恢复的话，那么建议您创建有状态服务。



## 无状态服务和有状态服务主要有以下区别
实例数量：无状态服务可以有一个或多个实例，因此支持两种服务容量调节模式；有状态服务只能有一个实例，不允许创建多个实例，因此也不支持服务容量调节模式
存储卷：无状态服务可以有存储卷，也可以没有，即使有也无法备份存储卷里面的数据；有状态服务必须要有存储卷，并且在创建服务时，必须指定给该存储卷分配的磁盘空间大小
数据存储：无状态服务运行过程中的所有数据（除日志和监控数据）都存在容器实例里的文件系统中，如果实例停止或者删除，则这些数据都将丢失，无法找回；而对于有状态服务，凡是已经挂载了存储卷的目录下的文件内容都可以随时进行备份，备份的数据可以下载，也可以用于恢复新的服务。但对于没有挂载卷的目录下的数据，仍然是无法备份和保存的，如果实例停止或者删除，这些非挂载卷里的文件内容同样会丢失。


## 从单机服务到集群化

[分布式基础5-无状态主从集群设计](http://blog.sina.com.cn/s/blog_7d1968e20102xaej.html)

构建单机服务非常简单，但如果单机服务可靠性或性能不足，就需要多机器共同承担某项服务。集群化包含以下三种情况：

无状态主备集群：仅有一台主机完成任务，且没有本地状态，其余从机机器待命，一旦主机宕机，从机选主成为主机

有状态主备集群：仅有一台主机完成任务，有本地状态，其余从机机器待命，一旦主机宕机，从机选主成为主机

无状态的主从集群：所有机器没有本地状态，理论上机器可以无限叠加，共同向外界提供同一服务。

有状态的主从集群

所有机器都有本地状态，共同向外界提供同一服务。一旦某台机器宕机，需要主机协调其他从机代理其本地状态的任务。Paxos、raft和ZAB等一众分布式一致性算法的终极目标就是解决该问题
# 有状态与无状态

[Service statelessness principle](https://en.wikipedia.org/wiki/Service_statelessness_principle)

https://www.proud2becloud.com/stateful-vs-stateless-the-good-the-bad-and-the-ugly/

在**SaaS服务**时代，构建**无状态微服务**似乎是取得成功的唯一途径。但这是真的吗？并且总是可以设计无状态服务吗？在本文中，我们将介绍**有状态和无状态微服务之间的根本区别。**状态和无状态微服务之间的关键区别在于，**无状态的**微服务**不将数据存储在主机上**，而**状态**微服务**需要某种类型的存储**在为请求提供服务的主机上。保持状态对于有状态服务至关重要。另一方面，无状态服务可以仅使用请求有效负载中可用的信息片段工作，或者可以从专用的有状态服务（如数据库）获取所需的信息片段。这里是无状态服务之间主要区别的快速概述和有状态的服务。

## 无状态

- 服务器仅根据每个请求中继的信息处理请求，而不依赖于早期请求的信息——这意味着服务器不需要保留请求之间的状态信息（或者状态可以保存到外部服务中） ，就像一个数据库）
- 不同的请求可以由不同的服务器处理
- 任何服务实例都可以从其他地方检索执行行为所需的所有服务状态这一事实实现了弹性、弹性以及任何可用服务实例执行任何任务的能力



## 有状态

- 有状态服务要么是一个数据库，要么基于需要在单个主机上进行严格状态处理的 Internet 协议
- 服务器根据与每个请求一起中继的信息以及从先前请求中存储的信息来处理请求
- 必须使用相同的服务器来处理链接到相同状态信息的所有请求，或者需要与所有需要它的服务器共享状态信息

## **运行有状态工作负载的挑战**

运行有状态工作负载有多种挑战：

- 资源隔离——目前市场上的许多容器编排解决方案仍然只涉及一种尽力而为的资源分配方法，例如 CPU、内存和存储。这可能适用于无状态微服务，但对于有状态微服务来说，这可能是一种灾难性的方法，客户交易或数据由于性能不可靠而丢失
- 持久存储——每个有状态数据服务可能需要或支持不同类型的存储类型（例如块设备或分布式文件系统），并且确定有状态服务的后备存储类型可能具有挑战性

这些挑战部分是因为许多**有状态微服务是为遗留环境构建的**，并且可能是单体的。组织可能首先尝试将其有状态服务容器化，但随后他们需要开发高度特定的工具来协调众多相关实例以实现高可用性，或采用其他复杂的策略来部署、管理或操作这些服务。这可能会导致手动开销需求，这可能会变得耗时且成本高昂，和/或需要为每项服务开发定制操作，从而带来相当大的操作风险。

## **SaaS呢？**

SaaS 是一种软件许可和交付模型，其中软件以订阅方式获得许可并集中托管。它有时被称为“按需软件”。SaaS 微服务也称为基于 Web 的软件、按需软件和托管软件。术语“软件即服务”(SaaS) 被认为是云计算术语的一部分。**并非所有流程都可以设为无状态，**因此，您可以构建成功的无状态或有状态 SaaS 服务。请记住，单体有状态服务可能会更昂贵且难以维护，并且会使扩展变得更加困难。此外，它还需要对备份和高可用性进行特殊处理。

## **结论**

有时您必须构建有状态的服务，这不会自动损害您的 SaaS 准备。但是，您需要确保对有状态服务进行某种扩展，并计划备份和快速灾难恢复。虽然这几乎总是可能的，但工作量可能比在无状态微服务上获得更好结果所需的工作要多得多。规模大，地理分布全球。



# 附录

[RedHat](https://www.redhat.com/zh/topics/cloud-native-apps/stateful-vs-stateless)
[Stateful and Stateless Applications Best Practices and Advantages](https://www.xenonstack.com/insights/stateful-and-stateless-applications)
[分布式系统中的“无状态”和“有状态”详解](https://blog.csdn.net/universsky2015/article/details/105677992)
[构建可伸缩的有状态服务](https://www.infoq.cn/article/2015/12/scaling-stateful-services/)
[【高可用架构】理解有状态服务和无状态服务](http://liaojiacan.me/2019/05/27/%E3%80%90%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E3%80%91%E7%90%86%E8%A7%A3%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1/index.html)
[Service statelessness principle](https://en.wikipedia.org/wiki/Service_statelessness_principle)
[无状态服务VS有状态服务](https://blog.csdn.net/u010472499/article/details/53888480)