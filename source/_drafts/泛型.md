---
title: Java 泛型从入门到入土
toc: true
clearReading: true
thumbnailImagePosition: right
metaAlignment: center
thumbnailImage:
categories: Java
tags: JDK
keywords: 泛型
excerpt: 泛型是如今高级语言都支持的特性，Java 最初并不支持泛型，那么最后 Java 是如何优雅的增加这个功能？
---

## 泛型

### 10.1 泛型引进

```java
ArrayList arrayList = new ArrayList();
arrayList.add("hello");
arrayList.add("world");
arrayList.add(10);//集合可以装任意引用类型的元素,虽然10并不是引用类型,但是JDK5以后存在自动装箱
```

<span style="color:red;font-weight:bold">在访问集合中的元素时,却由于并不能明确元素的类型,从而向下转型错误,不能使用元素的特定功能</span>

```java
String[] s = new String[3];
s[0] = "hello";
s[1] = "world";
s[2] = 10;//将会出错,因为数组明确每一个元素只能是String类型
```

> :notes:集合也模仿着数组的做法:<span style="color:red;font-weight:bold">在创建对象的时候明确元素的数据类型</span>.这样就不会存在向下转型问题,

### 10.2 泛型定义以及意义

**泛型**与C++中的**模版**概念类似,目的就是将**类型参数化（type parameters）**”

> :sparkles:**类型参数化**的含义
>
> - 类型明确的工作推迟到创建对象或者调用方法时,才去明确的特殊类型.之后将类型作为一种参数传递给集合
> - 类型参数使得程序具有更好的可读性和安全性
>
> :+1:使用泛型的优点
>
> 1. 把运行时期的问题提前到了编译期间
> 2. 避免了强制类型转换
> 3. 优化了程序设计,明确每种集合元素类型
>
> :persevere:对于类型参数，程序员可能想要内置（plug in）所有的类，在没有过多的限制以及混乱的错误消息的状态下，做所有的事情。一个泛型程序员的任务就是预测出所用类的未来可能有的所有用途

### 10.3 简单泛型类

一个泛型类（generic class) 就是具有一个或多个类型变量的类

```java
ArrayList<type>//type只能是引用类型,即只能是类
//泛型前后类型必须一致,即必须写相同的类,就是父子类之间也不允许
ArrayList<String> arrayList = new ArrayList<String>();
Collection<Object> c = new Collection<String>();//会报错,因为泛型前后类型不一致
```

> :notes:类型变量要求
>
> - 使用大写形势
> - 命名比较短
>
> :sparkles:常见的类型变量
>
> | 类型变量  |                含义                 |
> | :-------: | :---------------------------------: |
> |     E     | 元素（Element），多用于java集合框架 |
> |     K     |            关键字（Key）            |
> |     N     |           数字（Number）            |
> | T（U、S） |            类型（Type）             |
> |     V     |             值（Value）             |

```java
ArrayList<String > arrayList = new ArrayList<String >();
arrayList.add("hello");
arrayList.add("world");
arrayList.add("java");
Iterator<String> it = arrayList.iterator();
while (it.hasNext()){
	String s = it.next();
	System.out.println(s);
}
//JDK7新特性,泛型推断
ArrayList<String > arrayList2 = new ArrayList<>();//会基于之前的泛型推断出new后的泛型
```

### 10.6 泛型方法

可以定义一个带有类型参数的简单方法

:sparkles:泛型方法特点

- 泛型方法可以定义在普通类中，也可以定义在泛型类中
- 不用因为相同的功能而重载多个类

#### 10.6.1 格式

```java
public <T> T show(T t);//public 后的<T>声明使用泛型
```

#### 10.6.2 用例

```java
class ObjectTool{
    //将泛型定义在方法上
    public <T> void show(T t){
        System.out.println(t);
    }
}
//show方法可以接受任何一种参数
public static void main(String[] args) {
	ObjectTool objectTool = new ObjectTool();
	objectTool.<String>show("this is string type");
	//不知道形式参数类型,泛型参数可以不用明确指定,编译器会自动识别
    objectTool.show("hello world");		
	objectTool.<Integer>show(100);
	objectTool.show(true);
}
```

### 10.7 泛型接口

> :sparkles:将泛型定义在接口上,实现类在实现泛型接口的时候具有以下两种
>
> 1. 已经知道该泛型的明确类型(__不常用__)
> 2. 并不知道泛型的明确类型(__常用__)

```java
interface Inter<T>{
    public abstract void show(T t);
}
//方式一:已经知道该泛型的明确类型
class InterImple implements Inter<String>{
  //不常用
    @Override
    public void show(String str) {
        System.out.println("from normal imple"+str);
    }
}
//方式二:并不知道泛型的明确类型
class InterImple2<T> implements Inter<T>{
    //此时泛型接口的使用与泛型类相同
    @Override
    public void show(T t) {
        System.out.println(t);
    }
}
public static void main(String[] args) {
	Inter<String> inter = new InterImple2<String>();
	inter.show("String");
	Inter<Integer> inter2 = new InterImple2<Integer>();
	inter2.show(123);
	Inter<Boolean> inter3 = new InterImple2<Boolean>();
	inter3.show(true);
}
```

### 类型变量的限定（泛型边界）

在泛型类或方法需要对类型变量加以约束，这就需要使用类型变量的限定符

一个类型变量或通配符可以有多个限定， 例如：`T extends Comparable & Serializable`

在 Java 的继承中， 可以根据需要拥有多个接口超类型， 但限定中至多有一个类。如果用
一个类作为限定，它必须是限定列表中的第一个。  

限定类型使用`&`分隔，逗号永安里分隔类型变量



### 10.8 泛型高级(通配符)

主要介绍`?`,`? extends E`,`? super E`这三种

```java
class Animal{}
class Dog extends Animal{}
class Cat extends Animal{}
```

#### 10.8.1 ?

任意的引用类型都可以

```java
Collection<?> c1 = new ArrayList<Animal>();
Collection<?> c2 = new ArrayList<Dog>();
Collection<?> c3 = new ArrayList<Cat>();
```

#### 10.8.2 ? extends E:

向下限定,E及其子类

```java
Collection<? extends Animal> c4 = new ArrayList<Animal>();
Collection<? extends Animal> c5 = new ArrayList<Dog>();
Collection<? extends Animal> c6 = new ArrayList<Object>();//出错,只能是子类
```

#### 10.8.3 ? super E:

向上限定

```java
Collection<? super Animal> c7 = new ArrayList<Object>();
Collection<? super Animal> c8 = new ArrayList<Dog>();//出错,只能是父类
```

### 10.9 泛型的约束和局限性

> :sparkles:使用泛型的特点(约束性和局限性)
>
> 1. 不能实例化泛型类
> 2. 静态变量或方法不能引用泛型类型变量，但是静态泛型方法是可以的
> 3. 基本类型无法作为泛型类型
> 4. 无法使用instanceof关键字或==判断泛型类的类型
> 5. 泛型类的原生类型与所传递的泛型无关，无论传递什么类型，原生类是一样的
> 6. 泛型数组可以声明但无法实例化
> 7. 泛型类不能继承Exception或者Throwable
> 8. 不能捕获泛型类型限定的异常但可以将泛型限定的异常抛出

### 10.10 泛型类型继承规则

> :sparkles:泛型类间的继承特点
>
> 1. 泛型参数是继承关系的泛型类之间是没有继承关系的
> 2. 泛型类可以继承其它泛型类;如: public class ArrayList<E> extends AbstractList<E>
> 3. 泛型类的继承关系在使用中同样会受到泛型类型的影响

### 10.11Java泛型特点

> :sparkles:泛型特点
>
> - 在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型.传入不同泛型实参的泛型类在内存上仅存在一个,即还是原来的最基本的类型，在逻辑上我们可以理解成多个不同的泛型类型。
>
> - Java泛型**只是作用于代码编译阶段**,在编译过程中,对于正确检验泛型结果后,会将泛型的相关信息擦出,也就是说,成功编译过后的class文件中是不包含任何泛型信息的,**泛型信息不会进入到运行时阶段。**

### 泛型代码和虚拟机

虚拟机没有泛型类型对象—所有对象都属于普通类  

在泛型代码内部，无法获得任何有关泛型参数类型的信息

#### 类型擦除

擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入到 Java 语言。

泛型类型参数将擦除到它的第一个边界（它可能会有多个边界）

当你希望代码能够跨多个类工作时，使用泛型才有所帮助

泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的原始类型



无论何时定义一个泛型类型， 都自动提供了一个相应的原始类型 （ raw type）

原始类型的名字就是删去类型参数后的泛型类型名

擦除（erased）类型变量，并替换为限定类型（无限定的变量用 Object）

```java
public class Pair<T>
{
	private T first;
	private T second;
	public Pair() { first = null ; second = null ; }
	public PairfT first, T second) { this,first = first; this.second = second; }
	public T getFirstO { return first; }
	public T getSecondO { return second; }
	public void setFirst(T newValue) { first = newValue; }
	public void setSecond(T newValue) { second = newValue; }
}
//原始类型如下，T是无限定变量，直接使用Object替换
public class Pair
{
	private Object first;
	private Object second;
	public Pair(Object first, Object second)
	{
		this,first = first;
		this.second = second;
    }
	public Object getFirstO { return first; }
	public Object getSecondO { return second; }
	public void setFirst(Object newValue) { first = newValue; }
	public void setSecond(Object newValue) { second = newValue; }
}
```

:notes:C++ 中每个模板的实例化产生不同的类型，这一现象称为**模板代码膨账**，Java 不存在这个问题的困扰。  



:notes:Java 泛型转换的事实

- 虚拟机中没有泛型，只有普通的类和方法
- 所有的类型参数都用它们的限定类型替换
- 桥方法被合成来保持多态
- 为保持类型安全性，必要时插入强制类型转换

## 约束与局限性

使用 Java 泛型时需要考虑一些限制，这些限制大多数都是由类型擦除引起的

#### 不能用基本类型实例化类型参数



### 运行时类型查询只适用于原始类型



### 不能创建参数化类型的数组

不能实例化参数化类型的数组， 例如：

```java
Pair<String>[] table = new Pair<String>[10]; // Error  
```

需要说明的是， 只是不允许创建这些数组， 而声明类型为 Pair<String>[] 的变量仍是合法
的。不过不能用 new Pair<String>[10] 初始化这个变量  

:notes:可以声明通配类型的数组，然后进行类型转换

```java
Pair<String>[] table = (Pair<String>[]) new Pair<?>[10];
```

结果将是不安全的。 如果在 table[0] 中存储一个 Pair<Employee>, 然后对 table[0].
getFirst() 调用一个 String 方法， 会得到一个 ClassCastException 异常  

:notes:如果需要收集参数化类型对象， 只有一种安全而有效的方法： 使用 ArrayList:Arra
yList<Pair<String»  

### Varargs 警告



## 附录

[Java泛型详解](https://www.jianshu.com/p/986f732ed2f1)

https://blog.csdn.net/s10461/article/details/53941091

https://zhuanlan.zhihu.com/p/37779524