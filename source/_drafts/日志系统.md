---
title: 日志系统概述
toc: true
clearReading: true
thumbnailImagePosition: right
metaAlignment: center
thumbnailImage:
categories: 中间件
tags: 日志系统
keywords: 日志系统
excerpt: 恭喜你即将成为合格的高级程序员，日志记录是一个优秀的开发必然的选择，本文将简要的阐述 Java 环境中日志系统的那些事
---
## 日志概述

:question:为什么需要日志？

在很多的情况下，日志可能是我们了解应用如何执行的唯一方式，所以学习日志非常有必要

因为软件系统发展到了今天非常的复杂，特别时服务器的软件，设计到的知识和内容问题非常的多。

对于日志记录来讲，在某些方面使用别人研发好的成熟的框架，这就相当于让别人帮你完成一些基础的工作。

所以，程序员只需要集中精力去完成业务逻辑就可以了

比如事务处理，日志记录等一些安全性的问题，我们可以使用框架去做

### 日志体系概述

在 Java 中一直秉持着面向接口编程，所以任何优秀的框架一定是先存在接口，而后再是根据这些接口做到不同的实现。Java 日志体系如下图：

![](https://gitee.com/mingchaohu/blog-image/raw/master/image/java日志体系.jpg)

### 日志接口

| 日志接口 |                             含义                             |
| :------: | :----------------------------------------------------------: |
|  `JCL`   | Java Commons Loggin，Apache基⾦会所属的项⽬，是⼀套 Java ⽇志接⼝ |
| `SLF4J`  | Simple Logging Facade for Java，是一套简单的 Java 日志门面，只提供相关接口，和其他日志之间需要桥接 |

:notes:这里说的门面其实就是表示，这是一套接口，并没有给出 Java 日志的具体实现方式。其中所说的桥接，指的是桥接模式



:question:为什么要使用日志门面技术

每一种日志框架都有自己单独的API，要使用对应的框架就要使用对应的API，这就大大的增加了应用程序代码对于日志框架的耦合性

使用日志门面技术之后，对于应用程序来说，无论底层的日志框架如何改变，应用程序不需要修改任何一行代码就可以上线运行

### 日志实现

| 日志实现  |                         含义                          |
| :-------: | :---------------------------------------------------: |
|   `JUL`   |                   JDK 中的⽇志⼯具                    |
|  `Log4j`  |   ⾪属于 Apache 基⾦会的⼀套⽇志框架，现已不再维护    |
| `Log4j2`  |       Log4j的升级版本，与Log4j变化很⼤，不兼容        |
| `Logback` | ⼀个具体的⽇志实现框架，和Slf4j是同⼀个作者，性能很好 |

### 发展历程

在JDK 1.3及以前，Java打⽇志依赖System.out.println(), System.err.println()或者 e.printStackTrace()，Debug⽇志被写到STDOUT流，错误⽇志被写到STDERR流。这样打⽇志有⼀个⾮常⼤的缺陷，⾮常机械，⽆法定制，且⽇志粒度不够细分

```java
System.out.println("123");
System.err.println("456");
```

随后，在 2001 年发布了 `Log4j`，Log4j 在设计上⾮常优秀， 它定义的Logger、Appender、Level等概念对后续的 Java Log 框架有深远的影响，如今的很多⽇志框 架基本沿⽤了这种思想。Log4j 的性能是个问题，在Logback 和 `Log4j2 `出来之后，2015年9⽉， Apache 软件基⾦会宣布，`Log4j` 不再维护，建议所有相关项⽬升级到Log4j2

### 为什么需要日志？

日志文件是用于记录系统操作事情的文件集合

:sparkles:日志文件的作用

- 处理历史数据
- 诊断问题的追踪
- 理解系统的活动

### 调试日志

在软件开发中，需要经常的调试程序，或者做一些状态的输出，便于我们查询程序的运行状况，为了让我们能够更加灵活且方便的控制这些调试信息，我们肯定是需要更加专业的日志技术。我们平时在调试程序的过程中所使用的肯定就是专业开发工具自带的 debug功能，可以实时查看程序运行情况，不能够有效保存运行情况的信息。调试日志是能够更加方便的去“重现”这些问题

### 系统日志

系统日志是实际生产环境中最常使用的日志

系统日志是用来记录系统中硬件、软件和系统相关问题的信息，同时还可以监视系统中发生的事件，用户可以通过它来检查错误发生的原因，或者寻找到攻击时留下的痕迹

系统日志包括系统运行日志、应用日志和安全日志这几种分类

## 混乱的日志体系

### Log4J 使用

引入依赖

```xml
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.17</version>
</dependency>
<dependency>
    <groupId>log4j</groupId>
    <artifactId>apache-log4j-extras</artifactId>
    <version>1.2.17</version>
</dependency>
```

日志输出模式配置

```properties
log4j.rootLogger=debug
#console
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=log4j:[%d{yyyy-MM-dd HH:mm:ssa}]:%p %l%m%n
#dailyfile
log4j.appender.dailyfile=org.apache.log4j.DailyRollingFileAppender
log4j.appender.dailyfile.DatePattern='_'yyyy-MM-dd'.log'
log4j.appender.dailyfile.File=./log4j.log
log4j.appender.dailyfile.Append=true
log4j.appender.dailyfile.Threshold=INFO
log4j.appender.dailyfile.layout=org.apache.log4j.PatternLayout
log4j.appender.dailyfile.layout.ConversionPattern=log4j:[%d{yyyy-MM-dd HH:mm:ssa}] [Thread: %t][ Class:%c >> Method: %l ]%n%p:%m%n
```



```java
public class TestLoger {
	public static void main(String[] args) {
		Logger logger = Logger.getLogger(TestLoger.class);
		logger.info("xxxxxxxxxxx");
	}
}
```



## JUL

在已经存在 log4j 后，sun 公司在 JDK 1.4 版本后，增加了一个名为`java.util.logging`的包，简称为`JUL`，如此就给开发造成了麻烦（两个日志工具的 API 不同:cry:）,这就造成了相互引用的项目之间可能引用了不同的日志框架，经常将代码搞得一片混乱

```java
public class TestLoger {
   public static void main(String[] args) {
      java.util.logging.Logger logger1 = java.util.logging.Logger.getLogger(TestLoger.class.getName());
      logger1.finest("jul xxxx");
   }
}
```

配置路径在：`$JAVA_HOME/jre/lib/logging.properties`，JUL功能远不如log4j完善，⾃带的Handlers有限，性能和可⽤性上也⼀般，JUL在Java1.5以后才有 所提升

### JCL

从上⾯可以看出，JUL的api与log4j是完全不同的（参数只接受string）。由于⽇志系统互相没有关 联，彼此没有约定，不同⼈的代码使⽤不同⽇志，替换和统⼀也就变成了⽐较棘⼿的⼀件事。假如你的 应⽤使⽤log4j，然后项⽬引⽤了⼀个其他团队的库，他们使⽤了JUL，你的应⽤就得使⽤两个⽇志系统 了，然后其他团队⼜使⽤了simplelog……这个时候如果要调整⽇志的输出级别，⽤于跟踪某个信息，简 直就是⼀场灾难。 　

:question:那这个状况该如何解决呢？答案就是进⾏抽象，抽象出⼀个接⼝层，对每个⽇志实现都适配或者转 接，这样这些提供给别⼈的库都直接使⽤抽象层即可 ，以后调⽤的时候，就调⽤这些接⼝。（⾯向接⼝ 思想） 　于是，JCL(Jakarta Commons Logging)应运⽽⽣，也就是commons-logging-xx.jar组件。JCL 只提 供 log 接⼝，具体的实现则在运⾏时动态寻找。这样⼀来组件开发者只需要针对 JCL 接⼝开发，⽽调⽤组件的应⽤程序则可以在运⾏时搭配⾃⼰喜好的⽇志实践⼯具

那接⼝下真实的⽇志是谁呢？

JCL会在ClassLoader中进⾏查找，如果能找到Log4j 则默认使⽤log4j 实现，如果没有则使⽤ JUL(jdk⾃带的) 实现，再没有则使⽤JCL内部提供的SimpleLog 实现。（代码验证）

#### 引入依赖

```xml
<dependency>
    <groupId>commons-logging</groupId>
    <artifactId>commons-logging</artifactId>
    <version>1.2</version>
</dependency>
```

```java
public class TestLoger {
   public static void main(String[] args) {
      Log log = LogFactory.getLog(TestLoger.class);
      log.info("xxxxxxx");
   }
}
```

JCL缺点也很明显，⼀是效率较低，二是容易引发混乱，三是JCL的机制有很⼤的可能会引发内存泄露。 　同时，JCL的书写存在⼀个不太优雅的地⽅，典型的场景如下：



假如要输出一条debug日志，而一般情况下，生产环境 log 级别都会设到 info 或者以上，那这条
log 是不不会被输出的。于是，在代码⾥里里就出现了了  

```java
logger.debug("this is a debug info , message :" + msg);
```

这个有什么问题呢？虽然⽣产不会打出⽇志，但是这其中都会做⼀个字符串连接操作，然后⽣成⼀ 个新的字符串。如果这条语句在循环或者被调⽤很多次的函数中，就会多做很多⽆⽤的字符串连接，影 响性能

所以，JCL推荐的写法如下

```java
if (logger.isDebugEnabled()) {
 logger.debug("this is a debug info , message :" + msg);
}
```

虽然解决了问题，但是这个代码实在看上去不怎么舒服.

## 日志配置

### 概述

⽇志级别
⼀个完整的⽇志组件都要具备⽇志级别的概念，每种⽇志组件级别定义不同，⽇常编码最经常⽤到的主流分级如下（由低到⾼）

| 日志级别 |       含义       |
| :------: | :--------------: |
| `trace`  |     路径跟踪     |
| `debug`  | ⼀般⽤于⽇常调式 |
|  `info`  |   打印重要信息   |
|  `warn`  |     给出警告     |
| `error`  |  出现错误或问题  |

　每个⽇志组件的具体级别划分稍有不同

日志组件

| 日志组件 |                         含义                         |
| :------: | :--------------------------------------------------: |
| appender |  ⽇志输出⽬的地，负责⽇志的输出 （输出到什么 地⽅）  |
|  logger  |  ⽇志记录器，负责收集处理⽇志记录 （如何处理⽇志）   |
|  layout  | ⽇志格式化，负责对输出的⽇志格式化（以什么形式展现） |

### jul 配置



### log4j 配置



### logback

http://logback.qos.ch/manual/index.html



⽇志打印级别 ALL > TRACE > FATAL > DEBUG > INFO > WARN > ERROR > OFF

http://logback.qos.ch/manual/layouts.html



### JCL



## 附录

https://www.pianshen.com/article/93831045086/
