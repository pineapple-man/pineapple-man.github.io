<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>Shiro 概述 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="Shiro"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n¶Shiro 概述\n🤔什么是 shiro ？\nApache Shiro 是一个强大且易用的 Java 安全框架，具有身份验证、授权、密码和会话管理等功能。使用 Shiro 可以快速地开发安全的应用程序\n\n✨Shiro 具有如下的特点\n\n易于使用：易用性是项目的最终目标，使用 Shiro 能够让没有安全开发经验的人员也能开发出安全的应用程序\n灵活：Apache Shiro 可以在任何应用程序环境中工作。虽然在网络工作、EJB 和 IoC 环境中可能并不需要它。但 Shiro 的授权也没有任何规范,甚至没有许多依赖关系\nWeb 支持：Apache Shiro 对 web 应用程序支持,允许您基于应用程序的 url 创建灵活的安全策略和网络协议(例如 REST),同时还提供一组 JSP 库控制页面输出\n低耦合：Shiro 干净的 API 和设计模式使它容易与许多其他框架和应用程序集成。Shiro 可以无缝地集成 Spring 这样的框架\n\n¶Shiro 入门\n如果想要使用 Shiro 就需要在项目中引入 Shiro 的依赖\n12345&lt;dependency&gt;  &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;  &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;  &lt;version&gt;1.5.3&lt;/version&gt;&lt;/dependency&gt;\n¶shiro 基本功能点\n\n\n\n\n功能名\n功能\n\n\n\n\nAuthentication\n身份认证/登录，验证用户是不是拥有相应的身份\n\n\nAuthorization\n授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情\n\n\nSession Management\n会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是 Web 环境的\n\n\nCryptography\n加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储\n\n\nWeb Support\nWeb 支持，可以非常容易的集成到 Web 环境\n\n\nCaching\n缓存，用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率\n\n\nConcurrency\nShiro 支持多线程应用程序\n\n\nTesting\n提供测试支持\n\n\nRun As\n允许一个用户假装为另一个用户的身份进行访问\n\n\nRemember Me\n记住我，即一次登录后，下次再次访问就不需要登录\n\n\n\n¶Shiro 核心架构\n\n\n刚开始接触不必要全部记住，只需要了解到有哪些组件即可\n\n¶subject\n\n应用代码直接交互的对象是 Subject， Shiro 的对外 API 核心是 Subject，Subject 代表了当前「用户」，这个用户不一定是一个具体的人，只要与当前应用交互的任何东西都是 Subject；\n与 Subject 的所有交互都会委托给 Security Manager；\nSubject 其实是一个门面，SecurityManager 才是实际的执行者\n\n\n¶Security Manager\nSecurity Manager 相当于 SpringMVC 中的 DispatcherServlet；是 Shiro 的心脏；所有具体的交互都通过 Security Manager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理、安全管理器，所有与安全有关的操作都会与 Security Manager 交互；\n\n¶Authenticator\n认证器，负责对 Subject 认证，可以自定义实现；其需要认证策略（Authentication Strategy）\n\n¶Authrizer\n授权器，或者访问控制器，用来决定 Subject 是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；\n\n¶Realm\nShiro 从 Realm 获取安全数据（如用户、角色、权限），就是说 Security Manager 要验证用户角色，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 realm 看成 DataSource\n可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是 JDBC 实现，也可以是 LDAP 实现，或者内存实现等等；由用户提供；\n\n🎶Shiro 不知道用户/权限存储在哪及以何种格式存储；所以一般在应用中都需要实现自己的 Realm\n\n¶SessionManager\nSession 需要人为管理它的生命周期，在 Shiro 中这个组件就是 Session Manager；而 Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB 等环境；所有，Shiro 就抽象了一个自己的 Session 来管理 Subject 与应用之间交互的数据\n\n¶SessionDAO\nDAO——数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如 JDBC 写到数据库；例如：想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能\n\n¶CacheManager\n缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能\n\n¶Cryptography\n密码模块，Shiro 提供了一些常见的加密组件用于如密码加密/解密的\n\n¶Shiro 认证\n身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。\n\n¶shiro 认证的关键对象\n\n\n\n对象\n含义\n\n\n\n\nSubject：主体\n访问系统的用户\n\n\nPrincipal：身份信息\n是主体（subject）进行身份认证的标识，标识必须具有唯一性，如用户名、手机号、邮箱地址等，一个主体可以有多个身份，但是必须有一个主身份（Primary Principal）\n\n\ncredential：凭证信息\n是只有主体自己知道的安全信息，如密码、证书等\n\n\n\n¶认证流程\n\n\n\n首先调用 Subject.login(token) 进行登录认证，其会自动委托给 Security Manager，调用之前必须通过 SecurityUtils. setSecurityManager()；\n\n\nSecurityManager 负责身份验证逻辑；它会委托给 Authenticator 进行身份验证；\n\n\nAuthenticator 是真正的身份验证者，Shiro API 中核心的身份认证入口点，此处可以自定义插入自己的实现\n\n\nAuthenticator 可能会委托给相应的 Authentication Strategy 进行多 Realm 身份验证，默认 ModularRealmAuthenticator 会调用 AuthenticationStrategy 进行多 Realm 身份验证\n\n\nAuthenticator 会把相应的 token 传入 Realm，从 Realm 获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个 Realm，将按照相应的顺序及策略进行访问\n\n\n\n¶认证实现\nshiro.ini123[users]zhangsan=123456lisi=123456\n📓配置文件的名称随意，主要以 .ini 结尾，放在 resources 目录下即可。在实际的项目开发中并不会使用配置文件的方式，这种方式主要是用来初学者学习使用\nTestLoging.java1234567891011121314151617181920@Testpublic void testLogin() throws Exception &#123;//1.加载 ini 配置文件创建 SecurityManagerFactory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);//2.获取 securityManagerSecurityManager securityManager = factory.getInstance();//3.将 securityManager 绑定到当前运行环境SecurityUtils.setSecurityManager(securityManager);//4.创建主体(此时的主体还为经过认证)Subject subject = SecurityUtils.getSubject();//5.构造主体登录的凭证（即用户名/密码)UsernamePasswordToken upToken = new UsernamePasswordToken(&quot;zhangsan&quot;, &quot;123456&quot;);//6.主体登录subject.login(upToken);//7.验证是否登录成功System.out.println(&quot;用户登录成功=&quot; + subject.isAuthenticated());//8.登录成功获取数据//getPrincipal 获取登录成功的安全数据System.out.println(subject.getPrincipal());&#125;\n¶Shiro 授权\nShiro 中的授权，就是对某个用户授予某些权限，如果使用 RBAC 模型，也就是对某些用户授予某些角色\nshiro 授权和认证大体过程类似，不过是Authentication认证过程变成了Authorizer授权过程\n\n¶权限字符串\n权限字符串的规则是：资源标识符：操作：资源实例标识符，意思是对哪个资源的哪个实例具有什么操作，“:”是资源标识符、操作、资源实例的分割符，权限字符串也可以使用*通配符，下面列举了几个权限字符串的例子\n\n用户创建权限：user:create，或 user:create:*\n用户修改实例 001 的权限：user:update:001\n用户实例 001 的所有权限：user:*：001\n\n\n¶授权流程\n\n首先调用 Subject.isPermitted/hasRole 接口，其会委托给 SecurityManager，而 SecurityManager 接着会委托给 Authorizer\nAuthorizer 是真正的授权者，如果我们调用如 isPermitted(“user:view”)，其首先会通过 PermissionResolver 把字符串转换成相应的 Permission 实例\n在进行授权之前，其会调用相应的 Realm 获取 Subject 相应的角色/权限用于匹配传入的角色/权限\nAuthorizer 会判断 Realm 的角色/权限是否和传入的匹配，如果有多个 Realm，会委托给 ModularRealmAuthorizer 进行循环判断，如果匹配如 isPermitted/hasRole 会返回 true，否则返回 false 表示授权失败\n\n\n¶授权实现\nshiro.ini1234567[users] #模拟从数据库查询的用户 #数据格式 用户名=密码,角色 1,角色 2..zhangsan=123456,role1,role2lisi=654321,role2[roles] #模拟从数据库查询的角色和权限列表 #数据格式 角色名=权限 1，权限 2role1=user:save,user:updaterole2=user:update,user.deleterole3=user.find\nTestPermission.Java12345678910111213141516@Testpublic void testLogin() &#123;Subject subject = SecurityUtils.getSubject();String username = &quot;abc&quot;;String password = &quot;123456&quot;;UsernamePasswordToken usernamePasswordToken = new UsernamePasswordToken(username,password);subject.login(usernamePasswordToken);//验证用户是否登陆成功System.out.println(subject.isAuthenticated());//获取登陆成功的数据System.out.println(subject.getPrincipals());//判断 subject 是否拥有相关角色System.out.println(subject.hasRole(&quot;role1&quot;));//判断 subject 是否拥有相关权限System.out.println(subject.isPermitted(&quot;user:save&quot;));&#125;\n📓认证与授权的关系\n\n¶自定义 Realm\n自定义 Realm 的作用：放弃使用.ini 文件，使用数据库查询具体用户的权限等信息，上边的程序使用的是 Shiro 自带的 IniRealm。\nIniRealm 从 ini 配置文件中读取用户的信息，大部分情况下需要从系统的数据库中读取用户信息，所以需要自定义 realm\n\nshiro.ini123[main]permRealm = cn.pineapple.shiro.PermissionRealmsecurityManager.realms=$permRealm\nPermissionRealm.java12345678910111213141516171819202122232425262728293031323334353637public class PermissionRealm extends AuthorizingRealm &#123;@Overridepublic void setName(String name) &#123;System.out.println(name);super.setName(&quot;permissionRealm&quot;);&#125;/_授权：授权的主要目的对用户增加某些权限或角色_/@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123;String username = (String) principalCollection.getPrimaryPrincipal();System.out.println(username);List&lt;String&gt; permissions = new ArrayList&lt;&gt;();permissions.add(&quot;user:save&quot;);permissions.add(&quot;user:update&quot;);List&lt;String&gt; roles = new ArrayList&lt;&gt;();roles.add(&quot;role1&quot;);roles.add(&quot;role2&quot;);SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();simpleAuthorizationInfo.addStringPermissions(permissions);simpleAuthorizationInfo.addRoles(roles);return simpleAuthorizationInfo;&#125;/_ 认证：认证的主要目的，比较用户输入的用户名密码是否和数据库中的一致_/@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) authenticationToken;String username = usernamePasswordToken.getUsername();String password = String.valueOf(usernamePasswordToken.getPassword());if (!&quot;123456&quot;.equals(password)) &#123;throw new RuntimeException(&quot;username or password error&quot;);&#125; else &#123;return new SimpleAuthenticationInfo(username, password, this.getName());      &#125;&#125;&#125;\nShiro 中 Realm 的继承体系 \n\nSimpleAccountRealm 的继承体系\n\nSimpleAccountRealm 的部分源码中有两个方法一个是「认证」一个是「授权」\n¶Shiro 加密\n在之前的操作中，在数据库中保存的密码都是明文的，一旦数据库数据泄露，就会造成不可估算的损失，所以通常都会使用非对称加密，等其他安全的手段保护用户的密码。通过加密算法后，就可以将加密的字符串保存在数据库中，等下次用户登陆时将密码通过同样的算法加密后再从数据库中取出这个字符串进行比较，就能够知道密码是否正确了。这样既保留了密码验证的功能又大大增加了安全性。\n\n12345public void testMd5() &#123;  String password = &quot;123456&quot;;  String encodedPassword = new Md5Hash(password).toString();  System.out.println(encodedPassword);&#125;\nMD5是一种 hash 算法，根据哈希的特性，相同的输入，必然拥有相同的输出，所以就需要让原始密码再加上一个随机数，然后再进行 MD5 哈希，这种随机数也就是通常说的盐（salt），当然需要将盐也保存进数据库，以便后续进行验证。\n\n12345678String password = &quot;123456&quot;;String salt = new SecureRandomNumberGenerator().nextBytes().toString();int times = 2;  // 加密次数：2String alogrithmName = &quot;md5&quot;;   // 加密算法String encodePassword = new SimpleHash(alogrithmName, password, salt, times).toString();System.out.printf(&quot;原始密码是 %s , 盐是： %s, 运算次数是： %d, 运算出来的密文是：%s &quot;,password,salt,times,encodePassword);\n另外我们可以通过多次加密的方法，即使黑客通过一定的技术手段拿到了我们的密码 md5 值，但它并不知道我们到底加密了多少次，所以这也使得破解工作变得艰难\n\n¶附录\nShiro 安全框架【快速入门】就这一篇\n","dateCreated":"2021-12-31T07:01:45+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2021-12-31T07:01:45+00:00","description":"本文是 Shiro 的基本概述篇，总结 Shiro 相关知识","headline":"Shiro 概述","image":["https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/apache-shiro-logo.png"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/shiro-%E6%A6%82%E8%BF%B0/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/shiro-%E6%A6%82%E8%BF%B0/","keywords":"安全","thumbnailUrl":"https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/apache-shiro-logo.png"}</script><meta name="description" content="本文是 Shiro 的基本概述篇，总结 Shiro 相关知识"><meta property="og:type" content="blog"><meta property="og:title" content="Shiro 概述"><meta property="og:url" content="https://pineapple-man.github.io/shiro-%E6%A6%82%E8%BF%B0/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="本文是 Shiro 的基本概述篇，总结 Shiro 相关知识"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/shiro%E5%8A%9F%E8%83%BD%E7%82%B9.jpeg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112301643711.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292306050.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112311430483.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292310498.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292348055.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292348833.png"><meta property="article:published_time" content="2021-12-31T07:01:45.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.015Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="安全"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/shiro%E5%8A%9F%E8%83%BD%E7%82%B9.jpeg"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/apache-shiro-logo.png"><meta class="swiftype" name="image" data-type="enum" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/apache-shiro-logo.png"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">Shiro 概述</h1><div class="post-meta"><time datetime="2021-12-31T07:01:45+00:00">12月 31, 2021 </time><span>发布在 </span><a class="category-link" href="/categories/Java/">Java</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 3.2k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 32 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Shiro-%E6%A6%82%E8%BF%B0"><span class="toc-text">Shiro 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shiro-%E5%85%A5%E9%97%A8"><span class="toc-text">Shiro 入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shiro-%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E7%82%B9"><span class="toc-text">shiro 基本功能点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shiro-%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84"><span class="toc-text">Shiro 核心架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#subject"><span class="toc-text">subject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Security-Manager"><span class="toc-text">Security Manager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Authenticator"><span class="toc-text">Authenticator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Authrizer"><span class="toc-text">Authrizer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Realm"><span class="toc-text">Realm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SessionManager"><span class="toc-text">SessionManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SessionDAO"><span class="toc-text">SessionDAO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CacheManager"><span class="toc-text">CacheManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cryptography"><span class="toc-text">Cryptography</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shiro-%E8%AE%A4%E8%AF%81"><span class="toc-text">Shiro 认证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shiro-%E8%AE%A4%E8%AF%81%E7%9A%84%E5%85%B3%E9%94%AE%E5%AF%B9%E8%B1%A1"><span class="toc-text">shiro 认证的关键对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B"><span class="toc-text">认证流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">认证实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shiro-%E6%8E%88%E6%9D%83"><span class="toc-text">Shiro 授权</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">权限字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B"><span class="toc-text">授权流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E5%AE%9E%E7%8E%B0"><span class="toc-text">授权实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Realm"><span class="toc-text">自定义 Realm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shiro-%E5%8A%A0%E5%AF%86"><span class="toc-text">Shiro 加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol><h2 id="Shiro-概述"><a class="header-anchor" href="#Shiro-概述">¶</a>Shiro 概述</h2><p>🤔什么是 shiro ？</p><div class="alert success no-icon"><p>Apache Shiro 是一个强大且易用的 Java 安全框架，具有身份验证、授权、密码和会话管理等功能。使用 Shiro 可以快速地开发安全的应用程序</p></div><p>✨Shiro 具有如下的特点</p><ul><li><strong>易于使用</strong>：易用性是项目的最终目标，使用 Shiro 能够让没有安全开发经验的人员也能开发出安全的应用程序</li><li><strong>灵活</strong>：Apache Shiro 可以在任何应用程序环境中工作。虽然在网络工作、EJB 和 IoC 环境中可能并不需要它。但 Shiro 的授权也没有任何规范,甚至没有许多依赖关系</li><li><strong>Web 支持</strong>：Apache Shiro 对 web 应用程序支持,允许您基于应用程序的 url 创建灵活的安全策略和网络协议(例如 REST),同时还提供一组 JSP 库控制页面输出</li><li><strong>低耦合</strong>：Shiro 干净的 API 和设计模式使它容易与许多其他框架和应用程序集成。Shiro 可以无缝地集成 Spring 这样的框架</li></ul><h2 id="Shiro-入门"><a class="header-anchor" href="#Shiro-入门">¶</a>Shiro 入门</h2><p>如果想要使用 Shiro 就需要在项目中引入 Shiro 的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="shiro-基本功能点"><a class="header-anchor" href="#shiro-基本功能点">¶</a>shiro 基本功能点</h3><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/shiro功能点.jpeg" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/shiro功能点.jpeg" alt=""></a></div><table><thead><tr><th style="text-align:center">功能名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">Authentication</td><td style="text-align:center">身份认证/登录，验证用户是不是拥有相应的身份</td></tr><tr><td style="text-align:center">Authorization</td><td style="text-align:center">授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情</td></tr><tr><td style="text-align:center">Session Management</td><td style="text-align:center">会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是 Web 环境的</td></tr><tr><td style="text-align:center">Cryptography</td><td style="text-align:center">加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储</td></tr><tr><td style="text-align:center">Web Support</td><td style="text-align:center">Web 支持，可以非常容易的集成到 Web 环境</td></tr><tr><td style="text-align:center">Caching</td><td style="text-align:center">缓存，用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率</td></tr><tr><td style="text-align:center">Concurrency</td><td style="text-align:center">Shiro 支持多线程应用程序</td></tr><tr><td style="text-align:center">Testing</td><td style="text-align:center">提供测试支持</td></tr><tr><td style="text-align:center">Run As</td><td style="text-align:center">允许一个用户假装为另一个用户的身份进行访问</td></tr><tr><td style="text-align:center">Remember Me</td><td style="text-align:center">记住我，即一次登录后，下次再次访问就不需要登录</td></tr></tbody></table><h3 id="Shiro-核心架构"><a class="header-anchor" href="#Shiro-核心架构">¶</a>Shiro 核心架构</h3><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112301643711.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112301643711.png" alt=""></a></div><blockquote><p>刚开始接触不必要全部记住，只需要了解到有哪些组件即可</p></blockquote><h3 id="subject"><a class="header-anchor" href="#subject">¶</a><code>subject</code></h3><div class="alert info no-icon"><ul><li>应用代码直接交互的对象是 Subject， Shiro 的对外 API 核心是 Subject，Subject 代表了当前「用户」，这个用户不一定是一个具体的人，只要与当前应用交互的任何东西都是 Subject；</li><li>与 Subject 的所有交互都会委托给 Security Manager；</li><li>Subject 其实是一个门面，SecurityManager 才是实际的执行者</li></ul></div><h3 id="Security-Manager"><a class="header-anchor" href="#Security-Manager">¶</a><code>Security Manager</code></h3><div class="alert info no-icon"><p>Security Manager 相当于 SpringMVC 中的 DispatcherServlet；是 Shiro 的心脏；所有具体的交互都通过 Security Manager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理、安全管理器，所有与安全有关的操作都会与 Security Manager 交互；</p></div><h3 id="Authenticator"><a class="header-anchor" href="#Authenticator">¶</a><code>Authenticator</code></h3><div class="alert info no-icon"><p>认证器，负责对 Subject 认证，可以自定义实现；其需要认证策略（Authentication Strategy）</p></div><h3 id="Authrizer"><a class="header-anchor" href="#Authrizer">¶</a><code>Authrizer</code></h3><div class="alert info no-icon"><p>授权器，或者访问控制器，用来决定 Subject 是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</p></div><h3 id="Realm"><a class="header-anchor" href="#Realm">¶</a><code>Realm</code></h3><div class="alert info no-icon"><p>Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说 Security Manager 要验证用户角色，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 realm 看成 DataSource</p><p>可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是 JDBC 实现，也可以是 LDAP 实现，或者内存实现等等；由用户提供；</p></div><div class="alert warning no-icon"><p>🎶Shiro 不知道用户/权限存储在哪及以何种格式存储；所以一般在应用中都需要实现自己的 Realm</p></div><h3 id="SessionManager"><a class="header-anchor" href="#SessionManager">¶</a><code>SessionManager</code></h3><div class="alert info no-icon"><p>Session 需要人为管理它的生命周期，在 Shiro 中这个组件就是 Session Manager；而 Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB 等环境；所有，Shiro 就抽象了一个自己的 Session 来管理 Subject 与应用之间交互的数据</p></div><h3 id="SessionDAO"><a class="header-anchor" href="#SessionDAO">¶</a><code>SessionDAO</code></h3><div class="alert info no-icon"><p>DAO——数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如 JDBC 写到数据库；例如：想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能</p></div><h3 id="CacheManager"><a class="header-anchor" href="#CacheManager">¶</a><code>CacheManager</code></h3><div class="alert info no-icon"><p>缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能</p></div><h3 id="Cryptography"><a class="header-anchor" href="#Cryptography">¶</a><code>Cryptography</code></h3><div class="alert info no-icon"><p>密码模块，Shiro 提供了一些常见的加密组件用于如密码加密/解密的</p></div><h2 id="Shiro-认证"><a class="header-anchor" href="#Shiro-认证">¶</a>Shiro 认证</h2><p>身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292306050.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292306050.png" alt=""></a></div><h3 id="shiro-认证的关键对象"><a class="header-anchor" href="#shiro-认证的关键对象">¶</a>shiro 认证的关键对象</h3><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Subject：主体</strong></td><td style="text-align:center">访问系统的用户</td></tr><tr><td style="text-align:center"><strong>Principal：身份信息</strong></td><td style="text-align:center">是主体（subject）进行身份认证的标识，标识必须具有<code>唯一性</code>，如用户名、手机号、邮箱地址等，一个主体可以有多个身份，但是必须有一个主身份（Primary Principal）</td></tr><tr><td style="text-align:center"><strong>credential：凭证信息</strong></td><td style="text-align:center">是只有主体自己知道的安全信息，如密码、证书等</td></tr></tbody></table><h3 id="认证流程"><a class="header-anchor" href="#认证流程">¶</a>认证流程</h3><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112311430483.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112311430483.png" alt=""></a></div><div class="alert warning no-icon"><ol><li><p>首先调用 Subject.login(token) 进行登录认证，其会自动委托给 Security Manager，调用之前必须通过 SecurityUtils. setSecurityManager()；</p></li><li><p>SecurityManager 负责身份验证逻辑；它会委托给 Authenticator 进行身份验证；</p></li><li><p>Authenticator 是真正的身份验证者，Shiro API 中核心的身份认证入口点，此处可以自定义插入自己的实现</p></li><li><p>Authenticator 可能会委托给相应的 Authentication Strategy 进行多 Realm 身份验证，默认 ModularRealmAuthenticator 会调用 AuthenticationStrategy 进行多 Realm 身份验证</p></li><li><p>Authenticator 会把相应的 token 传入 Realm，从 Realm 获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个 Realm，将按照相应的顺序及策略进行访问</p></li></ol></div><h3 id="认证实现"><a class="header-anchor" href="#认证实现">¶</a>认证实现</h3><figure class="highlight ini"><figcaption><span>shiro.ini</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="attr">zhangsan</span>=<span class="number">123456</span></span><br><span class="line"><span class="attr">lisi</span>=<span class="number">123456</span></span><br></pre></td></tr></table></figure><p>📓配置文件的名称随意，主要以 .ini 结尾，放在 resources 目录下即可。在实际的项目开发中并不会使用配置文件的方式，这种方式主要是用来初学者学习使用</p><figure class="highlight java"><figcaption><span>TestLoging.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLogin</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//1.加载 ini 配置文件创建 SecurityManager</span></span><br><span class="line">Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> <span class="title class_">IniSecurityManagerFactory</span>(<span class="string">&quot;classpath:shiro.ini&quot;</span>);</span><br><span class="line"><span class="comment">//2.获取 securityManager</span></span><br><span class="line"><span class="type">SecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> factory.getInstance();</span><br><span class="line"><span class="comment">//3.将 securityManager 绑定到当前运行环境</span></span><br><span class="line">SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line"><span class="comment">//4.创建主体(此时的主体还为经过认证)</span></span><br><span class="line"><span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"><span class="comment">//5.构造主体登录的凭证（即用户名/密码)</span></span><br><span class="line"><span class="type">UsernamePasswordToken</span> <span class="variable">upToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//6.主体登录</span></span><br><span class="line">subject.login(upToken);</span><br><span class="line"><span class="comment">//7.验证是否登录成功</span></span><br><span class="line">System.out.println(<span class="string">&quot;用户登录成功=&quot;</span> + subject.isAuthenticated());</span><br><span class="line"><span class="comment">//8.登录成功获取数据</span></span><br><span class="line"><span class="comment">//getPrincipal 获取登录成功的安全数据</span></span><br><span class="line">System.out.println(subject.getPrincipal());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Shiro-授权"><a class="header-anchor" href="#Shiro-授权">¶</a>Shiro 授权</h2><p>Shiro 中的授权，就是对某个用户授予某些权限，如果使用 RBAC 模型，也就是对某些用户授予某些角色</p><div class="alert info no-icon"><p>shiro 授权和认证大体过程类似，不过是<code>Authentication</code>认证过程变成了<code>Authorizer</code>授权过程</p></div><h3 id="权限字符串"><a class="header-anchor" href="#权限字符串">¶</a>权限字符串</h3><p>权限字符串的规则是：<strong>资源标识符：操作：资源实例标识符</strong>，意思是对哪个资源的哪个实例具有什么操作，“:”是资源标识符、操作、资源实例的分割符，权限字符串也可以使用*通配符，下面列举了几个权限字符串的例子</p><div class="alert warning no-icon"><ul><li>用户创建权限：user:create，或 user:create:*</li><li>用户修改实例 001 的权限：user:update:001</li><li>用户实例 001 的所有权限：user:*：001</li></ul></div><h3 id="授权流程"><a class="header-anchor" href="#授权流程">¶</a>授权流程</h3><div class="alert success no-icon"><ol><li>首先调用 <code>Subject.isPermitted/hasRole</code> 接口，其会委托给 SecurityManager，而 SecurityManager 接着会委托给 Authorizer</li><li>Authorizer 是真正的授权者，如果我们调用如 isPermitted(“user:view”)，其首先会通过 PermissionResolver 把字符串转换成相应的 Permission 实例</li><li>在进行授权之前，其会调用相应的 Realm 获取 Subject 相应的角色/权限用于匹配传入的角色/权限</li><li>Authorizer 会判断 Realm 的角色/权限是否和传入的匹配，如果有多个 Realm，会委托给 ModularRealmAuthorizer 进行循环判断，如果匹配如 isPermitted/hasRole 会返回 true，否则返回 false 表示授权失败</li></ol></div><h3 id="授权实现"><a class="header-anchor" href="#授权实现">¶</a>授权实现</h3><figure class="highlight ini"><figcaption><span>shiro.ini</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[users]</span> <span class="comment">#模拟从数据库查询的用户 #数据格式 用户名=密码,角色 1,角色 2..</span></span><br><span class="line"><span class="attr">zhangsan</span>=<span class="number">123456</span>,role1,role2</span><br><span class="line"><span class="attr">lisi</span>=<span class="number">654321</span>,role2</span><br><span class="line"><span class="section">[roles]</span> <span class="comment">#模拟从数据库查询的角色和权限列表 #数据格式 角色名=权限 1，权限 2</span></span><br><span class="line"><span class="attr">role1</span>=user:save,user:update</span><br><span class="line"><span class="attr">role2</span>=user:update,user.delete</span><br><span class="line"><span class="attr">role3</span>=user.find</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>TestPermission.Java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLogin</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">UsernamePasswordToken</span> <span class="variable">usernamePasswordToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(username,password);</span><br><span class="line">subject.login(usernamePasswordToken);</span><br><span class="line"><span class="comment">//验证用户是否登陆成功</span></span><br><span class="line">System.out.println(subject.isAuthenticated());</span><br><span class="line"><span class="comment">//获取登陆成功的数据</span></span><br><span class="line">System.out.println(subject.getPrincipals());</span><br><span class="line"><span class="comment">//判断 subject 是否拥有相关角色</span></span><br><span class="line">System.out.println(subject.hasRole(<span class="string">&quot;role1&quot;</span>));</span><br><span class="line"><span class="comment">//判断 subject 是否拥有相关权限</span></span><br><span class="line">System.out.println(subject.isPermitted(<span class="string">&quot;user:save&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>📓认证与授权的关系</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292310498.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292310498.png" alt=""></a></div><h2 id="自定义-Realm"><a class="header-anchor" href="#自定义-Realm">¶</a>自定义 Realm</h2><div class="alert success no-icon"><p>自定义 Realm 的作用：放弃使用.ini 文件，使用数据库查询具体用户的权限等信息，上边的程序使用的是 Shiro 自带的 IniRealm。<br>IniRealm 从 ini 配置文件中读取用户的信息，大部分情况下需要从系统的数据库中读取用户信息，所以需要自定义 realm</p></div><figure class="highlight ini"><figcaption><span>shiro.ini</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[main]</span></span><br><span class="line"><span class="attr">permRealm</span> = cn.pineapple.shiro.PermissionRealm</span><br><span class="line"><span class="attr">securityManager.realms</span>=<span class="variable">$permRealm</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>PermissionRealm.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PermissionRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line"><span class="built_in">super</span>.setName(<span class="string">&quot;permissionRealm&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">/_授权：授权的主要目的对用户增加某些权限或角色_/</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) principalCollection.getPrimaryPrincipal();</span><br><span class="line">System.out.println(username);</span><br><span class="line">List&lt;String&gt; permissions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">permissions.add(<span class="string">&quot;user:save&quot;</span>);</span><br><span class="line">permissions.add(<span class="string">&quot;user:update&quot;</span>);</span><br><span class="line">List&lt;String&gt; roles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">roles.add(<span class="string">&quot;role1&quot;</span>);</span><br><span class="line">roles.add(<span class="string">&quot;role2&quot;</span>);</span><br><span class="line"><span class="type">SimpleAuthorizationInfo</span> <span class="variable">simpleAuthorizationInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">simpleAuthorizationInfo.addStringPermissions(permissions);</span><br><span class="line">simpleAuthorizationInfo.addRoles(roles);</span><br><span class="line"><span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">&#125;</span><br><span class="line">/_ 认证：认证的主要目的，比较用户输入的用户名密码是否和数据库中的一致_/</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"><span class="type">UsernamePasswordToken</span> <span class="variable">usernamePasswordToken</span> <span class="operator">=</span> (UsernamePasswordToken) authenticationToken;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> usernamePasswordToken.getUsername();</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> String.valueOf(usernamePasswordToken.getPassword());</span><br><span class="line"><span class="keyword">if</span> (!<span class="string">&quot;123456&quot;</span>.equals(password)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;username or password error&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(username, password, <span class="built_in">this</span>.getName());</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span class="highlight-text red">Shiro 中 Realm 的继承体系</span><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292348055.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292348055.png" alt=""></a></div><span class="highlight-text red">SimpleAccountRealm 的继承体系</span><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292348833.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/202112292348833.png" alt=""></a></div><p>SimpleAccountRealm 的部分源码中有两个方法一个是「认证」一个是「授权」</p><h2 id="Shiro-加密"><a class="header-anchor" href="#Shiro-加密">¶</a>Shiro 加密</h2><div class="alert success no-icon"><p>在之前的操作中，在数据库中保存的密码都是明文的，一旦数据库数据泄露，就会造成不可估算的损失，所以通常都会使用非对称加密，等其他安全的手段保护用户的密码。通过加密算法后，就可以将加密的字符串保存在数据库中，等下次用户登陆时将密码通过同样的算法加密后再从数据库中取出这个字符串进行比较，就能够知道密码是否正确了。这样既保留了密码验证的功能又大大增加了安全性。</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMd5</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">encodedPassword</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Md5Hash</span>(password).toString();</span><br><span class="line">  System.out.println(encodedPassword);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="alert warning no-icon"><p><code>MD5</code>是一种 hash 算法，根据哈希的特性，相同的输入，必然拥有相同的输出，所以就需要让原始密码再加上一个随机数，然后再进行 MD5 哈希，这种随机数也就是通常说的盐（<code>salt</code>），当然需要将盐也保存进数据库，以便后续进行验证。</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">salt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandomNumberGenerator</span>().nextBytes().toString();</span><br><span class="line"><span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">// 加密次数：2</span></span><br><span class="line"><span class="type">String</span> <span class="variable">alogrithmName</span> <span class="operator">=</span> <span class="string">&quot;md5&quot;</span>;   <span class="comment">// 加密算法</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">encodePassword</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHash</span>(alogrithmName, password, salt, times).toString();</span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">&quot;原始密码是 %s , 盐是： %s, 运算次数是： %d, 运算出来的密文是：%s &quot;</span>,password,salt,times,encodePassword);</span><br></pre></td></tr></table></figure><div class="alert warning no-icon"><p>另外我们可以通过<strong>多次加密</strong>的方法，即使黑客通过一定的技术手段拿到了我们的密码 md5 值，但它并不知道我们到底加密了多少次，所以这也使得破解工作变得艰难</p></div><h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54176956">Shiro 安全框架【快速入门】就这一篇</a></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/%E5%AE%89%E5%85%A8/" rel="tag">安全</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/java-tcp-ip-socket-%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E5%A5%97%E6%8E%A5%E5%AD%97/" data-tooltip="Java TCP/IP Socket 编程（一）基本套接字" aria-label="上一篇: Java TCP/IP Socket 编程（一）基本套接字"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E5%A0%86/" data-tooltip="堆" aria-label="下一篇: 堆"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/java-tcp-ip-socket-%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E5%A5%97%E6%8E%A5%E5%AD%97/" data-tooltip="Java TCP/IP Socket 编程（一）基本套接字" aria-label="上一篇: Java TCP/IP Socket 编程（一）基本套接字"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E5%A0%86/" data-tooltip="堆" aria-label="下一篇: 堆"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>