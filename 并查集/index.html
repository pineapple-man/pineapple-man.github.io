<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>并查集 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="并查集"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n¶简介\n并查集(Union-find data structure)是一种特殊的数据结构，用于快速处理一系列没有重复元素的集合(Disjoint sets)之间的合并以及查询问题\n✨并查集支持如下操作:\n\n¶并查集操作\n逻辑上，并查集将每一个集合以一棵树表示，每一个节点就是一个元素。节点保存着到它的父节点的引用，树的根节点则保存一个空引用或者到自身的引用或者其他无效值，以表示自身为根节点\n¶添加\n添加操作，makeSet(x)就是初始化操作，将x元素划分到属于仅有它自己的集合中，并且将父节点指向它自己。伪代码如下：\n123public  void makeSet(Element x)&#123;    x.parent = x;&#125;\n例如，通过初始化操作后，并查集逻辑结构如下：\n\n🎶初始化并查集注意点:\n\n在经过优化的并查集中，添加操作还会初始化一些有关节点的信息，例如集合的大小\n并查集初始化的时候，要求用户把所有的数据都给程序\n\n\n¶查询\n在并查集中，每个集合存在一个代表元素，代表元素通常是集合的根节点。查询操作findHead(x)，从x开始，根据节点中父节点的引用，递归查找，伪代码如下：\n1234567public Element findHead(Element x)&#123;    if(x.parent == x)&#123;        return x;    &#125;else&#123;        return findHead(x.parent)    &#125;&#125;\n\n🎶当集合很大或者树很不平衡时，上述代码效率很差，最坏的情况下（树退化成一条链），单次查询的时间复杂度高达(O(n) ,所以需要进行路径压缩。\n\n¶路径压缩优化（扁平化处理）\n路径压缩：在查询时(findHead)，将查询节点到根节点的路径上所有节点的父节点设置为根节点，从而减少树的高度。也就是说，在向上查询的同时，将路径上的每个节点都直接连接到根上，这样在以后查询时就可以直接查询到根节点。用伪代码表示如下：\n12345678public Element findHead(Element x)&#123;    if(x.parent == x)&#123;        return x;    &#125;else&#123;        x.parent = findHead(x.parent);        return x.parent；    &#125;&#125;\n\n¶合并\n合并操作union(x,y)将元素x所在的集合与元素y所在的集合合并为一个。\n首先，找出节点x与节点y对应的两个根节点，如果两个根节点其实是同一个，则说明元素x与元素y已经位于同一个集合中，否则，使其中一个根节点称为另一个的父节点,伪代码如下：\n1234567public void union(Element x,Element y)&#123;    xRoot = findHead(x);    yRoot = findHead(y);    if(xRoot != yRoot)&#123;        xRoot.parent = yRoot;    &#125;&#125;\n🎶单纯的合并，可能使得树变得不平衡，增加树的深度，从而增加查询的耗时,需要对树的深度进行优化\n¶按秩合并优化\n控制树的深度的办法是：在合并时，比较两棵树的大小，较大的树的根节点成为合并后树的根节点，较小的一棵树的根节点则成为前者的子节点\n✨树的大小有两种常用的衡量方式:\n\n以树中元素的数量作为树的大小（这被称为按大小合并）\n使用秩来比较树的大小\n\n\n🎶基于秩的比较规则：\n\n只有根节点的树（即只有一个元素的集合），秩为 0\n当两个秩不同的树合并后，新的树的秩为原来两个树的秩的较大者\n当两个秩相同的树合并后，新树的秩为原树的秩加一\n\n在合并时根据两棵树的秩的大小，决定新的根节点，这被称作按秩合并，用伪代码表示如下：\n123456789101112131415161718192021public  void makeSet(Element x)&#123;    x.parent = x;    x.rank = 0;&#125;public void union(Element x,Element y)&#123;\txRoot = findHead(x);    yRoot = findHead(y);    if(xRoot != yRoot)&#123;        if(xRoot.rank&lt;yRoot.rank)&#123;            large = yRoot;            small = xRoot;        &#125;else&#123;\t\t\tlarge = xRoot;            small = yRoot;        &#125;        small.parent = large;        if(large.rank == small.rank)&#123;            large.rank = large.rank + 1;        &#125;    &#125;&#125;\n🎶如果没有采用路径压缩优化，树的秩等于树的深度减一，使用路径压缩后，树的秩能反映出树的深度和大小。\n\n¶时空复杂度分析\n本小节主要介绍并查集结构的时空复杂度，并不会给予详细的证明，会用就行 😃\n¶时间复杂度\n经过优化的不交集森林（并查集）有线性的空间复杂度(O(n),n 为元素数目)，以及接近常数的单次操作平均时间复杂度 O($\\alpha({n})$)\n👴$\\alpha({n})$称为反阿克曼函数,反阿克曼函数的特点就是，$n\\to\\infty$,$\\alpha(n)&lt;5$,所以可以大致认为，并查集的操作是 O(1)的时间复杂度\n🎶同时使用路劲压缩和秩合优化的并查集，每次查询的合并操作的平均时间复杂度仅为 O($\\alpha({n})$)\n✨并查集编码特点：\n\nfindHead调用的越多，其他操作能够认为是 O(1)\nfindHead调用越频繁，复杂度逼近 O(N),但是其他操作的时间复杂度就越快\n\n¶空间复杂度\n并查集的空间复杂度是 O(n)，与初始化时输入数据的规模相关\n¶参考引用\nwiki\n","dateCreated":"2021-11-01T10:07:19+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2021-11-01T10:07:19+00:00","description":"并查集对于集合之间的操作非常有用，本文主要讲解并查集的基本操作","headline":"并查集","image":["https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/unionset.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/%E5%B9%B6%E6%9F%A5%E9%9B%86/","keywords":"数据结构与算法","thumbnailUrl":"https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/unionset.jpg"}</script><meta name="description" content="并查集对于集合之间的操作非常有用，本文主要讲解并查集的基本操作"><meta property="og:type" content="blog"><meta property="og:title" content="并查集"><meta property="og:url" content="https://pineapple-man.github.io/%E5%B9%B6%E6%9F%A5%E9%9B%86/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="并查集对于集合之间的操作非常有用，本文主要讲解并查集的基本操作"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E6%93%8D%E4%BD%9C.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/%E5%B9%B6%E6%9F%A5%E9%9B%86.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%9F%A5%E6%89%BE%E5%A4%B4%E8%8A%82%E7%82%B9.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/%E5%B9%B6%E6%9F%A5%E9%9B%86%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9.png"><meta property="article:published_time" content="2021-11-01T10:07:19.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.003Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="数据结构与算法"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E6%93%8D%E4%BD%9C.png"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/unionset.jpg"><meta class="swiftype" name="image" data-type="enum" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/unionset.jpg"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">并查集</h1><div class="post-meta"><time datetime="2021-11-01T10:07:19+00:00">11月 01, 2021 </time><span>发布在 </span><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a>, <a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 1.3k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 13 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%93%8D%E4%BD%9C"><span class="toc-text">并查集操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0"><span class="toc-text">添加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-text">查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96%EF%BC%88%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%84%E7%90%86%EF%BC%89"><span class="toc-text">路径压缩优化（扁平化处理）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6"><span class="toc-text">合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%A7%A9%E5%90%88%E5%B9%B6%E4%BC%98%E5%8C%96"><span class="toc-text">按秩合并优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-text">时空复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E5%BC%95%E7%94%A8"><span class="toc-text">参考引用</span></a></li></ol><h2 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h2><p><strong>并查集</strong>(Union-find data structure)是一种特殊的数据结构，<font style="color:red;font-weight:700">用于快速处理一系列没有重复元素的集合(Disjoint sets)之间的合并以及查询问题</font></p><p>✨并查集支持如下操作:</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E6%93%8D%E4%BD%9C.png" alt="并查集的操作"></p><h2 id="并查集操作"><a class="header-anchor" href="#并查集操作">¶</a>并查集操作</h2><p><strong>逻辑上</strong>，并查集将每一个集合以一棵树表示，每一个节点就是一个元素。节点保存着到它的父节点的引用，树的根节点则保存一个空引用或者到自身的引用或者其他无效值，以表示自身为根节点</p><h3 id="添加"><a class="header-anchor" href="#添加">¶</a>添加</h3><p>添加操作，<code>makeSet(x)</code>就是<font style="color:red;font-weight:700">初始化操作</font>，将<code>x</code>元素划分到属于仅有它自己的集合中，并且将父节点指向它自己。伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">makeSet</span><span class="params">(Element x)</span>&#123;</span><br><span class="line">    x.parent = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，通过初始化操作后，并查集逻辑结构如下：</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/并查集.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/并查集.png" alt=""></a></div><div class="alert info no-icon"><p>🎶初始化并查集注意点:</p><ul><li>在经过优化的并查集中，添加操作还会初始化一些有关节点的信息，例如集合的大小</li><li>并查集初始化的时候，要求用户把所有的数据都给程序</li></ul></div><h3 id="查询"><a class="header-anchor" href="#查询">¶</a>查询</h3><p>在并查集中，每个集合存在一个<strong>代表元素</strong>，代表元素通常是集合的根节点。查询操作<code>findHead(x)</code>，从<code>x</code>开始，根据节点中父节点的引用，<font style="color:red;font-weight:700">递归查找</font>，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Element <span class="title function_">findHead</span><span class="params">(Element x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.parent == x)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findHead(x.parent)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/并查集查找头节点.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/并查集查找头节点.png" alt=""></a></div><div class="alert info no-icon"><p>🎶当<font style="color:red;font-weight:700">集合很大</font>或者<font style="color:red;font-weight:700">树很不平衡</font>时，上述代码效率很差，<font style="color:#00f;font-weight:700">最坏的情况下（树退化成一条链）</font>，<font style="color:red;font-weight:700">单次查询的时间复杂度高达(O(n) </font>,所以需要进行路径压缩。</p></div><h3 id="路径压缩优化（扁平化处理）"><a class="header-anchor" href="#路径压缩优化（扁平化处理）">¶</a>路径压缩优化（扁平化处理）</h3><p><strong>路径压缩</strong>：在查询时(<code>findHead</code>)，<font style="color:red;font-weight:700">将查询节点到根节点的路径上所有节点的父节点设置为根节点</font>，从而减少树的高度。也就是说，在向上查询的同时，将路径上的每个节点都直接连接到根上，这样在以后查询时就可以直接查询到根节点。用伪代码表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Element <span class="title function_">findHead</span><span class="params">(Element x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.parent == x)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        x.parent = findHead(x.parent);</span><br><span class="line">        <span class="keyword">return</span> x.parent；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/并查集路径压缩.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/并查集路径压缩.png" alt=""></a></div><h3 id="合并"><a class="header-anchor" href="#合并">¶</a>合并</h3><p>合并操作<code>union(x,y)</code>将元素<code>x</code>所在的集合与元素<code>y</code>所在的集合合并为一个。</p><p><font style="color:red;font-weight:700">首先</font>，找出节点<code>x</code>与节点<code>y</code>对应的两个根节点，<font style="color:green;font-weight:700">如果两个根节点其实是同一个</font>，则说明元素<code>x</code>与元素<code>y</code>已经位于同一个集合中，<font style="color:#00f;font-weight:700">否则</font>，使其中一个根节点称为另一个的父节点,伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(Element x,Element y)</span>&#123;</span><br><span class="line">    xRoot = findHead(x);</span><br><span class="line">    yRoot = findHead(y);</span><br><span class="line">    <span class="keyword">if</span>(xRoot != yRoot)&#123;</span><br><span class="line">        xRoot.parent = yRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🎶<strong>单纯的合并</strong>，<font style="color:red;font-weight:700">可能使得树变得不平衡，增加树的深度，从而增加查询的耗时</font>,需要对树的深度进行优化</p><h3 id="按秩合并优化"><a class="header-anchor" href="#按秩合并优化">¶</a>按秩合并优化</h3><p>控制树的深度的办法是：在合并时，比较两棵树的大小，<font style="color:red;font-weight:700">较大的树的根节点成为合并后树的根节点，较小的一棵树的根节点则成为前者的子节点</font></p><div class="alert success no-icon"><p>✨树的大小有两种常用的衡量方式:</p><ul><li>以树中元素的数量作为树的大小（这被称为按大小合并）</li><li>使用秩来比较树的大小</li></ul></div><p>🎶基于秩的比较规则：</p><ul><li>只有根节点的树（即只有一个元素的集合），秩为 0</li><li>当两个秩不同的树合并后，新的树的秩为原来两个树的秩的较大者</li><li>当两个秩相同的树合并后，新树的秩为原树的秩加一</li></ul><p>在合并时根据两棵树的秩的大小，决定新的根节点，这被称作按秩合并，用伪代码表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">makeSet</span><span class="params">(Element x)</span>&#123;</span><br><span class="line">    x.parent = x;</span><br><span class="line">    x.rank = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(Element x,Element y)</span>&#123;</span><br><span class="line">	xRoot = findHead(x);</span><br><span class="line">    yRoot = findHead(y);</span><br><span class="line">    <span class="keyword">if</span>(xRoot != yRoot)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xRoot.rank&lt;yRoot.rank)&#123;</span><br><span class="line">            large = yRoot;</span><br><span class="line">            small = xRoot;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			large = xRoot;</span><br><span class="line">            small = yRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        small.parent = large;</span><br><span class="line">        <span class="keyword">if</span>(large.rank == small.rank)&#123;</span><br><span class="line">            large.rank = large.rank + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="alert info no-icon"><p>🎶如果没有采用路径压缩优化，树的秩等于树的深度减一，使用路径压缩后，树的秩能反映出树的深度和大小。</p></div><h2 id="时空复杂度分析"><a class="header-anchor" href="#时空复杂度分析">¶</a>时空复杂度分析</h2><p>本小节主要介绍并查集结构的时空复杂度，<font style="color:red;font-weight:700">并不会给予详细的证明，会用就行</font> 😃</p><h3 id="时间复杂度"><a class="header-anchor" href="#时间复杂度">¶</a>时间复杂度</h3><p>经过优化的不交集森林（并查集）有线性的空间复杂度(O(n),n 为元素数目)，以及接近常数的单次操作平均时间复杂度 O($\alpha({n})$)</p><p>👴$\alpha({n})$称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E9%98%BF%E5%85%8B%E6%9B%BC%E5%87%BD%E6%95%B0">反阿克曼函数</a>,反阿克曼函数的特点就是，$n\to\infty$,$\alpha(n)&lt;5$,所以可以大致认为，并查集的操作是 O(1)的时间复杂度</p><p>🎶同时使用路劲压缩和秩合优化的并查集，每次查询的合并操作的平均时间复杂度仅为 O($\alpha({n})$)</p><p>✨并查集编码特点：</p><ul><li><code>findHead</code>调用的越多，其他操作能够认为是 O(1)</li><li><code>findHead</code>调用越频繁，复杂度逼近 O(N),但是其他操作的时间复杂度就越快</li></ul><h3 id="空间复杂度"><a class="header-anchor" href="#空间复杂度">¶</a>空间复杂度</h3><p>并查集的空间复杂度是 O(n)，与初始化时输入数据的规模相关</p><h2 id="参考引用"><a class="header-anchor" href="#参考引用">¶</a>参考引用</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86">wiki</a></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E8%84%9A%E6%89%8B%E6%9E%B6/" data-tooltip="脚手架" aria-label="上一篇: 脚手架"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" data-tooltip="多租户数据库解决方案" aria-label="下一篇: 多租户数据库解决方案"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E8%84%9A%E6%89%8B%E6%9E%B6/" data-tooltip="脚手架" aria-label="上一篇: 脚手架"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" data-tooltip="多租户数据库解决方案" aria-label="下一篇: 多租户数据库解决方案"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>