<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>Eureka 学习笔记 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="服务注册中心"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n\n在了解 Eureka 常用操作之前，先查看一点微服务中关于服务发现的知识，这样能够帮助使用者更好的理解 Eureka 的工作模式\n\n¶服务发现\n❓微服务框架中，服务通常需要相互调用，为什么需要服务发现机制？\n在单体应用程序中，服务通过语言级别的方法或过程调用相互调用；在传统的分布式系统部署中，服务在固定的、众所周知的位置（主机和端口）运行，因此可以使用 HTTP/REST 或某种 RPC 机制轻松地相互调用，然而，现代基于微服务的应用程序通常在虚拟化或容器化环境中运行，其中服务的实例数量及其位置动态变化。因此，必须实现一种机制，使服务客户端能够向一组动态变化的临时服务实例发出请求，最终称这种机制为：服务发现\n\n\n根据发出请求方不同，将服务发现划分为两种模式：客户端服务发现模式和服务端服务发现模式两种\n¶客户端服务发现\n在客户端需要向服务发出请求时，客户端首先通过询问服务注册中心来获取服务实例的位置（服务注册中心知道所有服务实例的位置），随后根据服务注册中心的响应进行服务的访问，下图显示了此模式的结构\n\n\n✨RPC 远程调用框架核心设计思想在于注册中心，使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)，目前常用的注册中心架构如下图：\n\n❓什么是服务注册中心？\n服务注册中心就是服务的登记处，类似于生活中的社区登记处，用于记录整个系统中所有服务的位置，服务注册中心的位置时固定不变的，客户端通过访问服务注册中心查询到动态变化服务的位置。当服务漂移之后，服务会主动将目前所在位置通报给服务注册中心，服务注册中心随后在内部更改服务的位置，确保下次客户端能够正确获得服务漂移之后的位置\n\n服务发现依赖于服务注册表，系统中每个服务实例启动时，会将自己的网络位置信息发送到服务注册表，服务注册表利用心跳机制即时更新。实例关闭或者服务注册表检测到实例心跳超时情况下，实例信息就会从服务注册表移出\n¶服务器端服务发现\n当向服务发出请求时，客户端通过运行在众所周知的位置的负载均衡器（Router）发出请求，路由器查询可能内置于负载均衡器中的服务注册表，并将请求转发给可用的服务实例，下图显示了此模式的结构\n\n\n🆚服务器端服务与客户端服务发现的异同\n\n\n与客户端发现相比，客户端代码更加简单，因为它不必处理发现，相反客户端只是向负载均衡器发出请求，随后还需要根据负载均衡器返回的结果，在客户端再一次请求真正的服务\n\n\n除非服务端服务发现是云环境的一部分，否则路由器必须是另一个必须安装和配置的系统组件。它还需要复制以提高可用性和容量，路由器必须支持必要的通信协议（例如 HTTP、gRPC、Thrift 等），需要比使用客户端发现进行更多的网络跳数；客户端服务发现就没有这种限制\n\n\n\n¶总结\n对于两种不同类似的服务发现，主要区别在于：服务发现和负载均衡策略是由使用方自己实现还是作为一项服务来供使用方调用\n客户端发现模式是由服务请求方负责发现所有可用实例在网络中的具体位置，并根据具体的 Balance 策略将请求路由到具体的实例处理。而服务端发现模式则是请求方把请求经由 Load Balancer，Load Balancer 查询服务注册表后根据自己的 Balance 策略将请求路由到目标服务的一台具体实例上进行处理\n\n¶Eureka 概述\nEureka 是一种客户端服务发现模式，提供 Server 和 Client 两个组件。Eureka Server 作为服务注册表的角色，提供 REST API 管理服务实例的注册和查询。POST请求用于服务注册，PUT请求用于实现心跳机制，DELETE请求服务注册表移除实例信息，GET请求查询服务注册表来获取所有的可用实例。Eureka Client 是 Eureka 客户端，除了方便集成外，还提供了比较简单的Round-Robin Balance，配合使用 Netflix Ribbon，可以实现更加复杂的基于流量、资源占用情况、请求失败等因素的 Banlance 策略，为系统提供更可靠的弹性保证\n\nEureka 最初在 Netflix 主要用于 AWS 云上的服务发现，以实现服务器的负载均衡和容错。Eureka 也适用于基于 Docker 等虚拟化计数的微服务架构环境中，Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务治理。\n¶Eureka 的服务注册与发现\n之前阐述过，进行服务注册与发现时，存在一个注册中心，当服务器启动的时候，各个服务提供者会把将当前服务器的信息（比如服务地址通讯地址等以别名方式）注册到注册中心上。服务消费者使用该别名的方式去注册中心上获取到实际的服务通讯地址，获取到通讯地址后，就可以进行 RPC 调用\n✨Eureka 是一个 AP 的系统，具备高可用性和分区容错性。每个 Eureka Client 本地都有一份它最新获取到的服务注册表的缓存信息，即使所有的 Eureka Server 都挂掉了，依然可以根据本地缓存的服务信息正常工作\n\nEureka Server 没有基于 quorum 机制实现，而是采用 p2p 的去中心化结构，这样相比于zookeeper，集群不需要保证至少 $((n+1)/2)$台 Server 存活才能正常工作，增强了可用性；但是这种结构注定了 Eureka 不可能有 zookeeper 那样的一致性保证，因为 Client 缓存更新不及时或 Server 间同步失败等原因，都会导致 Client 访问不到新注册的服务或者访问到过期的服务\nQuorum 机制，是一种分布式系统中常用的，用来保证数据冗余和最终一致性的投票算法，其主要数学思想来源于鹊巢原理，由于不是本文重点，所以不在这里进行阐述\n\n当 Eureka Server 节点间某次信息同步失败时，同步失败的操作会在客户端下次心跳发起时再次同步；如果 Eureka Server 和 Eureka Client 间有网络分区存在，Eureka Server 会进入自我保护模式，不再把过期服务从服务注册表移除(这种情况下客户端有可能获取已经停止的服务，配合使用Hystrix通过熔断机制来容错和降级，弥补基于客户端服务发现的时效性缺点)\n¶Eureka 组件\n🆚Eureka 包含两个组件:Eureka Server 和 Eureka Client，下面主要介绍两者的区别\nEureka Server提供服务注册服务，各个微服务节点通过配置启动后，会在 EurekaServer 中进行注册，这样 EurekaServer 中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到\nEureka Client通过注册中心进行访问，它是一个 Java 客户端，用于简化 Eureka Server 的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，客户端将会向 Eureka Server 发送心跳(默认周期为 30 秒)。如果 Eureka Server 在多个心跳周期内没有接收到某个节点的心跳，EurekaServer 将会从服务注册表中把这个服务节点移除（默认 90 秒)\n\n¶使用\nEureka 可以和 Spring Cloud 无缝集成，本小节开始阐述 Eureka 常用操作。\n¶服务端（Eureka Server）\n添加组件依赖\n\n123456&lt;!-- eureka-server --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 其他依赖，主要是Spring Cloud及Spring Cloud Alibaba的依赖 --&gt;\n组件配置（Eureka 的配置）\n\n1234567891011121314# Eureka在Spring boot 项目中的配置文件server:  port: 6868eureka:  instance:    hostname: localhost  client:    #false表示不向注册中心注册自己。    register-with-eureka: false    #false表示自己就是注册中心，我的职责就是维护服务实例，并不需要去检索服务    fetch-registry: false    service-url:      # 设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址。      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/\ndefaultZone是一个魔数字符串默认值，作用是给没有指定Zone的客户端一个默认的Eureka地址，客户端可以在配置文件中指定当前服务属于哪一个Zone，如果没有指定，则属于默认Zone\n\n默认的应用名(Service ID)和端口号分别对应配置信息中的$&#123;spring.application.name&#125;和$&#123;server.port&#125;参数\nSpring Boot启动类\n\n1234567@SpringBootApplication()@EnableEurekaServerpublic class ServiceRegistry &#123;   public static void main(String[] args) &#123;      SpringApplication.run(ServiceRegistry.class, args);   &#125;&#125;\n随后就可以启动服务，访问http://localhost:6868就可以查看Eureka服务页面，由于只有服务端没有客户端所以看不到任何注册的服务，接下来介绍如何增加客户端\n¶客户端\n添加组件依赖，这里增加的是客户端 Eureka 依赖而不是服务端\n\n12345&lt;!--eureka client--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\n组件配置（Eureka 客户端的配置）\n\n123456eureka:  client:    register-with-eureka: true    fetch-registry: true    service-url:      defaultZone: http://localhost:6868/eureka\nSpring Boot启动类\n\n12345678@SpringBootApplication()@EnableEurekaClient\t//客户端配置public class CompanyApplication &#123;   public static void main(String[] args) &#123;      SpringApplication.run(CompanyApplication.class, args);   &#125;&#125;\n使用@EnableEurekaClient注解后，当前应用会同时变成 Eureka 服务端(它会注册自身)和 Eureka 客户端(可以查询当前服务列表)，与此相关的配置都在以eureka.instance.*开头的参数下，下图是启动 Eureka 后，访问当前系统内已注册的服务（由于存在网络分区所以默认开启的自我保护模式）\n\n画面中的那一段英文，表示的就是当前 Eureka 开启了自我保护模式，具体的自我保护机制在后面会有一小节内容进行介绍\n\nEMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.\n📓不要在@PostConstruct或@Scheduled方法中使用EurekaClient。在ApplicationContext还没有完全启动时使用该对象会发生错误\n\n\n¶Eureka 集群\n微服务 RPC 远程服务调用最核心的就是高可用性，试想你的注册中心只有一个，万一它出故障了，会导致整个为服务环境不可用，所以需要搭建 Eureka 注册中心集群，实现负载均衡+故障容错。\n\n完成 Eureka 集群的实现非常简单，就是通过将两个 Eureka 服务做到：互相注册，互相守望即可做到 Eureka 集群的高可用\n\n⛵使用步骤\n\n先启动 Eureka 注主册中心\n启动服务提供者 payment 支付服务\n服务启动后会把自身信息(服务地址以别名方式注朋进 eureka)\n消费者 order 服务在需要调用接口时，使用服务别名去注册中心获取服务的远程地址\n消费者获得调用地址后，底层实际是利用 HttpClient 技术实现远程调用\n消费者会将服务地址后会缓存在本地 JVM 内存中，默认每间隔 30 秒更新一次服务调用地址\n\n\n默认已经将eureka7002.com 和 eureka7001.com 映射到了本地host文件，映射地址就是127.0.0.1\nEureka 集群 1 配置123456789101112131415# 7001 微服务配置server:port: 7001eureka:instance:hostname: eureka7001.com #eureka 服务端的实例名称client:register-with-eureka: false #false 表示不向注册中心注册自己。fetch-registry: false #false 表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务service-url: #集群指向其它 eurekadefaultZone: http://eureka7002.com:7002/eureka/ #单机就是 7001 自己#defaultZone: http://eureka7001.com:7001/eureka/\nEureka 集群 2 配置12345678910111213141516# 7002 微服务配置server:port: 7002eureka:instance:hostname: eureka7002.com #eureka 服务端的实例名称client:register-with-eureka: false #false 表示不向注册中心注册自己。fetch-registry: false #false 表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务service-url: #集群指向其它 eurekadefaultZone: http://eureka7001.com:7001/eureka/ #单机就是 7002 自己#defaultZone: http://eureka7002.com:7002/eureka/\n此时由于拥有了两个微服务注册中心，所以每一个客户端都需要更改注册中心的位置信息\n支付微服务需要增加的配置123456eureka:client: #表示是否将自己注册进 Eurekaserver 默认为 true。register-with-eureka: true #是否从 EurekaServer 抓取已有的注册信息，默认为 true。单节点无所谓，集群必须设置为 true 才能配合 ribbon 使用负载均衡fetchRegistry: trueservice-url:defaultZone: http://eureka7001.com:7001/eureka, http://eureka7002.com:7002/eureka\n\n先要启动 EurekaServer，7001/7002 服务\n再要启动服务提供者 provider，8001\n再要启动消费者\n\n在使用过程中，遇到如下问题：\n\nHTTP 可以启动，但是使用 HTTPS 就会出错（服务注册失败）不知道为什么？\n\n\n¶服务发现（Discovery）\n对于注册进 eureka 里面的微服务，可以通过服务发现来获得该服务的信息\nEureka 客户端启动类12345678910@SpringBootApplication@EnableEurekaClient@EnableDiscoveryClient//添加该注解public class PaymentMain001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(PaymentMain001.class, args);    &#125;&#125;\nEureka 客户端 Controller文件12345678910111213141516171819202122232425@RestControllerpublic class PaymentController&#123;...    @Resource    private DiscoveryClient discoveryClient;    ...    @GetMapping(value = &quot;/payment/discovery&quot;)    public Object discovery()    &#123;        List&lt;String&gt; services = discoveryClient.getServices();        for (String element : services) &#123;            log.info(&quot;*****element: &quot;+element);        &#125;        //获取服务别名为 CLOUD-PAYMENT-SERVICE 的服务地址        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;);        for (ServiceInstance instance : instances) &#123;            log.info(instance.getServiceId()+&quot;\\t&quot;+instance.getHost()+&quot;\\t&quot;+instance.getPort()+&quot;\\t&quot;+instance.getUri());        &#125;        return this.discoveryClient;    &#125;&#125;\n¶Eureka 自我保护\n自我保护模式通常在一组客户端和 Eureka Server 之间存在网络分区场景下使用，一旦进入保护模式，Eureka Server 将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。默认Eureka开启了自我保护模式，进入首页的红字就是提示开启了保护模式\n❓什么是自我保护模式\n默认情况下，如果 Eureka Server 在一定时间内（默认时间为：90 秒）没有接收到某个微服务实例的心跳，Eureka Server 将会注销该实例。但是当网络分区故障发生时(例如：延时、卡顿、拥挤)，微服务客户端与 Eureka Server 之间无法正常通信，以上行为可能变得非常危险。因为微服务本身其实是健康的，此时本不应该注销这个微服务，错误的删除可能导致服务的丢失。Eureka 通过自我保护模式来解决这个问题，做到 AP 分布式系统。\n\n当 Eureka Server 节点在短时间内丢失过多客户端时(可能发生了网络分区故障)，那么这个节点就会进入自我保护模式，在自我保护模式中，Eureka Server 会保护服务注册表中的信息，不再注销任何服务实例，自我保护默认是开启的，也可以通过使用eureka.server.enable-self-preservation = false禁用自我保护模式关闭\n自我保护模式的设计哲学就是：宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例\n\n📓综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留）也不盲目注销任何健康的微服务；使用自我保护模式，可以让 Eureka 集群更加的健壮、稳定\n\nEureka Client 心跳检测与持续时间配置123456789eureka:...instance:instance-id: payment8001prefer-ip-address: true # #开发时没置小些，保证服务关闭后注册中心能即使剔除服务#Eureka 客户端向服务端发送心跳的时间间隔，单位为秒(默认是 30 秒)lease-renewal-interval-in-seconds: 1#Eureka 服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是 90 秒)，超时将剔除服务lease-expiration-duration-in-seconds: 2\n🎶最好不要修改 30 秒的默认心跳间隔，因为 Server 会使用这个时间数值来判断是否出现了大面积故障\n\n¶其他\n接下来记录 Eureka 其他功能\n¶Eureka Server 的身份验证\n如果客户端的eureka.client.serviceUrl.defaultZone参数值(即 Eureka Server 的地址)中包含HTTP Basic Authentication信息，如http://user:password@localhost:8761/eureka，那么客户端就会自动使用该用户名、密码信息与 Eureka 服务端进行验证。如果需要更复杂的验证逻辑，必须注册一个DiscoveryClientOptionalArgs组件，并将ClientFilter组件注入，在这里定义的逻辑会在每次客户端向服务端发起请求时执行。由于 Eureka 的限制，Eureka 不支持单节点身份验证\n¶状态页和健康信息指示器\nEureka 应用的状态页和健康信息默认的 url 为：/info和/health，这与Spring Boot Actuator中对应的 Endpoint 是重复的，因此必须进行修改，修改后的配置文件如下：\nEureka 服务端状态页和健康信息器配置文件1234eureka:instance:statusPageUrlPath: $&#123;management.context-path&#125;/infohealthCheckUrlPath: $&#123;management.context-path&#125;/health\n¶使用 HTTPS\n可以通过指定EurekaInstanceConfig类中的eureka.instance.[nonSecurePortEnabled,securePortEnabled]=[false,true]属性来指定是否使用 HTTPS。当配置使用 HTTPS 时，Eureka Server 会返回以https开头的服务地址。即使配置了使用 HTTPS，Eureka 的主页依然是以普通 HTTP 方式访问的，需要手动添加一些配置来将这些页面也通过 HTTPS 保护起来\nEureka Service 配置文件12345eureka:instance:statusPageUrl: https://$&#123;eureka.hostname&#125;/info    healthCheckUrl: https://$&#123;eureka.hostname&#125;/healthhomePageUrl: https://$&#123;eureka.hostname&#125;/\n🎶eureka.hostname是 Eureka 原生属性，只有新版本的 Eureka 才支持该属性，也可以使用 Spring EL 表达式代替$&#123;eureka.instance.hostName&#125;\n¶健康检查\n默认情况下，Eureka 通过客户端发来的心跳包来判断客户端是否在线。如果不显式指定，客户端在心跳包中不会包含当前应用的健康数据。这意味着只要客户端启动时完成了服务注册，那么该客户端在主动注销之前在 Eureka 中的状态会永远是UP状态。我们可以通过配置修改这一默认行为，即在客户端发送心跳包时会带上自己的健康信息。这样做的后果是只有当该服务的状态是UP时才能被访问，其它的任何状态都会导致该服务不能被调用\nEureka Service 配置文件1234eureka:client:healthcheck:enabled: true\n如果想对健康检查有更细粒度的控制，可以自己实现com.netflix.appinfo.HealthCheckHandler接口，做到自定义健康检查机制\n¶Eureka 元数据说明\n了解 Eureka 的元数据，就可以添加一些自定义的数据以适应特定的业务场景。像主机名、IP 地址、端口号、状态页 url 和健康检查 url 都是 Eureka 定义的标准元数据。这些元数据会被保存在 Eureka Server 的注册信息中，客户端会读取这些数据来向需要调用的服务直接发起连接。可以使用以eureka.instance.metadataMap开头的参数来添加自定义的元数据，所有客户端都会读取到该信息。通过这种方式你能给客户端自定义一些行为\n¶使用 Spring 的 DiscoveryClient 对象\n没有必要直接使用 Netflix 原生的EurekaClient对象，在此基础上做一些封装使用起来会更方便。Spring Cloud 支持Feign和Spring RestTmpelate，它们都可以使用服务的逻辑名而不是 URL 地址来查询服务。也可以使用 Spring 提供的DiscoveryClient对象访问远程服务，从而代码就不会与 Eureka 紧耦合\n12345678910@Autowiredprivate DiscoveryClient discoveryClient;public String serviceUrl() &#123;    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(&quot;STORES&quot;);    if (list != null &amp;&amp; list.size() &gt; 0 ) &#123;        return list.get(0).getUri();    &#125;    return null;&#125;\n¶伙伴感知\nEureka Server 可以通过运行多个实例并相互指定为伙伴的方式来达到更高的高可用性。实际上这就是默认设置，只需要指定伙伴的地址就可以了，这也就是之前说的 Eureka 集群方式\n¶Eureka Server伙伴感知配置文件1234567891011121314151617181920spring:profiles: peer1eureka:instance:hostname: peer1client:serviceUrl:defaultZone: http://peer2/eureka/---spring:profiles: peer2eureka:instance:hostname: peer2client:serviceUrl:defaultZone: http://peer1/eureka/\n在上面这个例子中，通过使用不同profile配置的方式可以在本地运行两个 Eureka Server。可以通过修改/etc/host文件，使用上述配置在本地测试伙伴感特性。可以同时启动多个 Eureka Server, 并通过伙伴配置使之围成一圈(相邻两个 Server 互为伙伴)，这些 Server 中的注册信息都是同步的。如果伙伴在物理上是分开的，那么系统原则上可以承受脑裂类型的故障\n¶Eureka 的高可用\nEureka 把所有注册信息都放在内存中，所有注册过的客户端都会向 Eureka 发送心跳包来保持连接。客户端会有一份本地注册信息的缓存，这样就不需要每次远程调用时都向 Eureka 查询注册信息。默认情况下，Eureka 服务端自身也是个客户端，所以需要指定一个 Eureka Server 的 URL 作为&quot;伙伴&quot;(peer)。如果没有提供这个地址，Eureka Server 也能正常启动工作，但是在日志中会有大量关于找不到 peer 的错误信息\n¶为什么注册一个服务这么慢?\n服务的注册涉及到心跳连接，默认为每 30 秒一次。只有当 Eureka 服务端和客户端本地缓存中的服务元数据相同时这个服务才能被其它客户端发现，这需要 3 个心跳周期。可以通过参数eureka.instance.leaseRenewalIntervalInSeconds调整这个时间间隔来加快这个过程。在生产环境中最好使用默认值，因为 Eureka 内部的某些计算依赖于该时间间隔\n¶Standalone 模式\n只要 Eureka Server 进程不会挂掉，这种集 Server 和 Client 于一身的模式能让 Standalone 部署的 Eureka Server 非常容易进行灾难恢复。在 Standalone 模式中，可以通过下面的配置来关闭查找伙伴的行为\nEureka Service Standlone 配置文件1234567891011server:port: 8761eureka:instance:hostname: localhostclient:registerWithEureka: falsefetchRegistry: falseserviceUrl:defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/\n🎶serviceUrl中的地址的主机名要与本地主机名相同\n¶使用 IP 地址\n有些时候可能更倾向于直接使用 IP 地址定义服务而不是使用主机名。把eureka.instance.preferIpAddress参数设为true时，客户端在注册时就会使用自己的 ip 地址而不是主机名\n¶附录\n官方中文文档\n微服务之服务发现 Eureka 的介绍与使用\nEureka 学习文档资料\n","dateCreated":"2021-11-22T10:00:24+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2021-11-22T10:00:24+00:00","description":"本文主要记录 Spring Cloud 中的 Eureka 组件，将记录常用 API 以及使用过程中遇见的问题","headline":"Eureka 学习笔记","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/eureka-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/eureka-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","keywords":"SpringCloud"}</script><meta name="description" content="本文主要记录 Spring Cloud 中的 Eureka 组件，将记录常用 API 以及使用过程中遇见的问题"><meta property="og:type" content="blog"><meta property="og:title" content="Eureka 学习笔记"><meta property="og:url" content="https://pineapple-man.github.io/eureka-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="本文主要记录 Spring Cloud 中的 Eureka 组件，将记录常用 API 以及使用过程中遇见的问题"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/discovery-problem.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/client-side-discovery.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/3956561052b9dc3909f16f1ff26d01bb.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/server-side-discovery.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/image-20211109170317330.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/14570c4b7c4dd8653be6211da2675e45.png"><meta property="article:published_time" content="2021-11-22T10:00:24.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.011Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="SpringCloud"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/discovery-problem.jpg"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">Eureka 学习笔记</h1><div class="post-meta"><time datetime="2021-11-22T10:00:24+00:00">11月 22, 2021 </time><span>发布在 </span><a class="category-link" href="/categories/Java/">Java</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 6.2k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 60 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-text">服务发现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-text">客户端服务发现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-text">服务器端服务发现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Eureka-%E6%A6%82%E8%BF%B0"><span class="toc-text">Eureka 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Eureka-%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0"><span class="toc-text">Eureka 的服务注册与发现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Eureka-%E7%BB%84%E4%BB%B6"><span class="toc-text">Eureka 组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%88Eureka-Server%EF%BC%89"><span class="toc-text">服务端（Eureka Server）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">客户端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Eureka-%E9%9B%86%E7%BE%A4"><span class="toc-text">Eureka 集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%EF%BC%88Discovery%EF%BC%89"><span class="toc-text">服务发现（Discovery）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Eureka-%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4"><span class="toc-text">Eureka 自我保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Eureka-Server-%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81"><span class="toc-text">Eureka Server 的身份验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E9%A1%B5%E5%92%8C%E5%81%A5%E5%BA%B7%E4%BF%A1%E6%81%AF%E6%8C%87%E7%A4%BA%E5%99%A8"><span class="toc-text">状态页和健康信息指示器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-HTTPS"><span class="toc-text">使用 HTTPS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5"><span class="toc-text">健康检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Eureka-%E5%85%83%E6%95%B0%E6%8D%AE%E8%AF%B4%E6%98%8E"><span class="toc-text">Eureka 元数据说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Spring-%E7%9A%84-DiscoveryClient-%E5%AF%B9%E8%B1%A1"><span class="toc-text">使用 Spring 的 DiscoveryClient 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E6%84%9F%E7%9F%A5"><span class="toc-text">伙伴感知</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#swig%EF%BF%BC46"><span class="toc-text">Eureka Server伙伴感知配置文件1234567891011121314151617181920spring:profiles: peer1eureka:instance:hostname: peer1client:serviceUrl:defaultZone: http:&#x2F;&#x2F;peer2&#x2F;eureka&#x2F;---spring:profiles: peer2eureka:instance:hostname: peer2client:serviceUrl:defaultZone: http:&#x2F;&#x2F;peer1&#x2F;eureka&#x2F;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Eureka-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-text">Eureka 的高可用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E8%BF%99%E4%B9%88%E6%85%A2"><span class="toc-text">为什么注册一个服务这么慢?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Standalone-%E6%A8%A1%E5%BC%8F"><span class="toc-text">Standalone 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-IP-%E5%9C%B0%E5%9D%80"><span class="toc-text">使用 IP 地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol><blockquote><p>在了解 Eureka 常用操作之前，先查看一点微服务中关于服务发现的知识，这样能够帮助使用者更好的理解 Eureka 的工作模式</p></blockquote><h2 id="服务发现"><a class="header-anchor" href="#服务发现">¶</a>服务发现</h2><p>❓<strong>微服务框架中，服务通常需要相互调用</strong>，为什么需要服务发现机制？</p><div class="alert success no-icon"><p>在单体应用程序中，服务通过语言级别的方法或过程调用相互调用；在传统的分布式系统部署中，服务在固定的、众所周知的位置（主机和端口）运行，因此可以使用 HTTP/REST 或某种 RPC 机制轻松地相互调用，然而，现代基于微服务的应用程序通常在虚拟化或容器化环境中运行，其中服务的实例数量及其位置动态变化。因此，必须实现一种机制，<strong>使服务客户端能够向一组动态变化的临时服务实例发出请求</strong>，最终称这种机制为：服务发现</p></div><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/discovery-problem.jpg" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/discovery-problem.jpg" alt=""></a></div><p>根据发出请求方不同，将服务发现划分为两种模式：<a target="_blank" rel="noopener" href="http://microservices.io/patterns/client-side-discovery.html">客户端服务发现模式</a>和<a target="_blank" rel="noopener" href="http://microservices.io/patterns/server-side-discovery.html">服务端服务发现模式</a>两种</p><h3 id="客户端服务发现"><a class="header-anchor" href="#客户端服务发现">¶</a>客户端服务发现</h3><div class="alert success no-icon"><p>在客户端需要向服务发出请求时，客户端<strong>首先通过询问服务注册中心来获取服务实例的位置</strong>（服务注册中心知道所有服务实例的位置），随后根据服务注册中心的响应进行服务的访问，下图显示了此模式的结构</p></div><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/client-side-discovery.jpg" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/client-side-discovery.jpg" alt=""></a></div><p>✨RPC 远程调用框架核心设计思想在于<strong>注册中心</strong>，使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)，目前常用的注册中心架构如下图：</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/3956561052b9dc3909f16f1ff26d01bb.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/3956561052b9dc3909f16f1ff26d01bb.png" alt=""></a></div><p>❓什么是服务注册中心？</p><div class="alert success no-icon"><p>服务注册中心就是<strong>服务的登记处</strong>，类似于生活中的社区登记处，用于记录整个系统中所有服务的位置，服务注册中心的位置时固定不变的，客户端通过访问服务注册中心查询到动态变化服务的位置。当服务漂移之后，服务会主动将目前所在位置通报给服务注册中心，服务注册中心随后在内部更改服务的位置，确保下次客户端能够正确获得服务漂移之后的位置</p></div><p>服务发现依赖于服务注册表，系统中每个服务实例启动时，会将自己的网络位置信息发送到服务注册表，服务注册表利用心跳机制即时更新。实例关闭或者服务注册表检测到实例心跳超时情况下，实例信息就会从服务注册表移出</p><h3 id="服务器端服务发现"><a class="header-anchor" href="#服务器端服务发现">¶</a>服务器端服务发现</h3><div class="alert success no-icon"><p>当向服务发出请求时，客户端通过运行在众所周知的位置的负载均衡器（<code>Router</code>）发出请求，路由器查询可能内置于负载均衡器中的服务注册表，并将请求转发给可用的服务实例，下图显示了此模式的结构</p></div><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/server-side-discovery.jpg" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/server-side-discovery.jpg" alt=""></a></div><p>🆚服务器端服务与客户端服务发现的异同</p><div class="alert success no-icon"><ul><li><p>与客户端发现相比，客户端代码更加简单，因为它不必处理发现，相反客户端只是向负载均衡器发出请求，随后还需要根据负载均衡器返回的结果，在客户端再一次请求真正的服务</p></li><li><p>除非服务端服务发现是云环境的一部分，否则路由器必须是另一个必须安装和配置的系统组件。它还需要复制以提高可用性和容量，路由器必须支持必要的通信协议（例如 HTTP、gRPC、Thrift 等），需要比使用客户端发现进行更多的网络跳数；客户端服务发现就没有这种限制</p></li></ul></div><h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3><div class="alert info no-icon"><p>对于两种不同类似的服务发现，主要区别在于：<strong>服务发现和负载均衡策略是由使用方自己实现还是作为一项服务来供使用方调用</strong></p><p>客户端发现模式是由服务请求方负责发现所有可用实例在网络中的具体位置，并根据具体的 Balance 策略将请求路由到具体的实例处理。而服务端发现模式则是请求方把请求经由 Load Balancer，Load Balancer 查询服务注册表后根据自己的 Balance 策略将请求路由到目标服务的一台具体实例上进行处理</p></div><h2 id="Eureka-概述"><a class="header-anchor" href="#Eureka-概述">¶</a>Eureka 概述</h2><div class="alert success no-icon"><p>Eureka 是一种客户端服务发现模式，提供 Server 和 Client 两个组件。Eureka Server 作为服务注册表的角色，提供 REST API 管理服务实例的注册和查询。<code>POST</code>请求用于服务注册，<code>PUT</code>请求用于实现心跳机制，<code>DELETE</code>请求服务注册表移除实例信息，<code>GET</code>请求查询服务注册表来获取所有的可用实例。Eureka Client 是 Eureka 客户端，除了方便集成外，还提供了比较简单的<code>Round-Robin Balance</code>，配合使用 <code>Netflix Ribbon</code>，可以实现更加复杂的基于流量、资源占用情况、请求失败等因素的 Banlance 策略，为系统提供更可靠的弹性保证</p></div><p>Eureka 最初在 Netflix 主要用于 AWS 云上的服务发现，以实现服务器的负载均衡和容错。Eureka 也适用于基于 Docker 等虚拟化计数的微服务架构环境中，Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务治理。</p><h3 id="Eureka-的服务注册与发现"><a class="header-anchor" href="#Eureka-的服务注册与发现">¶</a>Eureka 的服务注册与发现</h3><p>之前阐述过，进行服务注册与发现时，存在一个<strong>注册中心</strong>，当服务器启动的时候，各个服务提供者会把将当前服务器的信息（比如<strong>服务地址通讯地址</strong>等以别名方式）<strong>注册到注册中心上</strong>。<strong>服务消费者使用该别名的方式去注册中心上获取到实际的服务通讯地址</strong>，获取到通讯地址后，就可以进行 RPC 调用</p><div class="alert success no-icon"><p>✨Eureka 是一个 AP 的系统，具备高可用性和分区容错性。每个 Eureka Client 本地都有一份它最新获取到的服务注册表的缓存信息，即使所有的 Eureka Server 都挂掉了，依然可以根据本地缓存的服务信息正常工作</p></div><p>Eureka Server 没有基于 <code>quorum</code> 机制实现，而是采用 <code>p2p</code> 的去中心化结构，这样相比于<code>zookeeper</code>，集群不需要保证至少 $((n+1)/2)$台 Server 存活才能正常工作，增强了可用性；但是这种结构注定了 Eureka 不可能有 zookeeper 那样的一致性保证，因为 Client 缓存更新不及时或 Server 间同步失败等原因，都会导致 Client 访问不到新注册的服务或者访问到过期的服务</p><blockquote><p><strong>Quorum</strong> 机制，是一种分布式系统中常用的，用来保证数据冗余和最终一致性的投票算法，其主要数学思想来源于鹊巢原理，由于不是本文重点，所以不在这里进行阐述</p></blockquote><p>当 Eureka Server 节点间某次信息同步失败时，同步失败的操作会在客户端下次心跳发起时再次同步；如果 Eureka Server 和 Eureka Client 间有网络分区存在，Eureka Server 会进入<strong>自我保护模式</strong>，不再把过期服务从服务注册表移除(这种情况下客户端有可能获取已经停止的服务，配合使用<code>Hystrix</code>通过熔断机制来容错和降级，弥补基于客户端服务发现的时效性缺点)</p><h3 id="Eureka-组件"><a class="header-anchor" href="#Eureka-组件">¶</a>Eureka 组件</h3><p>🆚Eureka 包含两个组件:<strong>Eureka Server</strong> 和 <strong>Eureka Client</strong>，下面主要介绍两者的区别</p><div class="alert success no-icon"><p><strong>Eureka Server</strong>提供服务注册服务，各个微服务节点通过配置启动后，会在 EurekaServer 中进行注册，这样 EurekaServer 中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到</p><p><strong>Eureka Client</strong>通过注册中心进行访问，它是一个 Java 客户端，用于简化 Eureka Server 的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，客户端将会向 Eureka Server 发送心跳(默认周期为 30 秒)。如果 Eureka Server 在多个心跳周期内没有接收到某个节点的心跳，EurekaServer 将会从服务注册表中把这个服务节点移除（默认 90 秒)</p></div><h2 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h2><p>Eureka 可以和 Spring Cloud 无缝集成，本小节开始阐述 Eureka 常用操作。</p><h3 id="服务端（Eureka-Server）"><a class="header-anchor" href="#服务端（Eureka-Server）">¶</a>服务端（Eureka Server）</h3><div class="alert warning no-icon"><p>添加组件依赖</p></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- eureka-server --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其他依赖，主要是Spring Cloud及Spring Cloud Alibaba的依赖 --&gt;</span></span><br></pre></td></tr></table></figure><div class="alert warning no-icon"><p>组件配置（Eureka 的配置）</p></div><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Eureka在Spring boot 项目中的配置文件</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6868</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#false表示不向注册中心注册自己。</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#false表示自己就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址。</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><div class="alert success no-icon"><p><code>defaultZone</code>是一个魔数字符串默认值，作用是给没有指定<code>Zone</code>的客户端一个默认的<code>Eureka</code>地址，客户端可以在配置文件中指定当前服务属于哪一个<code>Zone</code>，如果没有指定，则属于默认<code>Zone</code></p></div><p>默认的应用名(Service ID)和端口号分别对应配置信息中的<code>$&#123;spring.application.name&#125;</code>和<code>$&#123;server.port&#125;</code>参数</p><div class="alert warning no-icon"><p><code>Spring Boot</code>启动类</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication()</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceRegistry</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      SpringApplication.run(ServiceRegistry.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后就可以启动服务，访问<code>http://localhost:6868</code>就可以查看<code>Eureka</code>服务页面，由于只有服务端没有客户端所以看不到任何注册的服务，接下来介绍如何增加客户端</p><h3 id="客户端"><a class="header-anchor" href="#客户端">¶</a>客户端</h3><div class="alert warning no-icon"><p>添加组件依赖，这里增加的是客户端 Eureka 依赖而不是服务端</p></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--eureka client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="alert success no-icon"><p>组件配置（Eureka 客户端的配置）</p></div><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:6868/eureka</span></span><br></pre></td></tr></table></figure><div class="alert warning no-icon"><p><code>Spring Boot</code>启动类</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication()</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span>	<span class="comment">//客户端配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompanyApplication</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      SpringApplication.run(CompanyApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@EnableEurekaClient</code>注解后，当前应用会同时变成 Eureka 服务端(它会注册自身)和 Eureka 客户端(可以查询当前服务列表)，与此相关的配置都在以<code>eureka.instance.*</code>开头的参数下，下图是启动 Eureka 后，访问当前系统内已注册的服务（由于存在网络分区所以默认开启的自我保护模式）</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/image-20211109170317330.png" alt=""></p><p>画面中的那一段英文，表示的就是当前 Eureka 开启了自我保护模式，具体的自我保护机制在后面会有一小节内容进行介绍</p><blockquote><p>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</p><div class="alert info no-icon"><p>📓不要在<code>@PostConstruct</code>或<code>@Scheduled</code>方法中使用<code>EurekaClient</code>。在<code>ApplicationContext</code>还没有完全启动时使用该对象会发生错误</p></div></blockquote><h2 id="Eureka-集群"><a class="header-anchor" href="#Eureka-集群">¶</a>Eureka 集群</h2><div class="alert warning no-icon"><p>微服务 RPC 远程服务调用最核心的就是高可用性，试想你的注册中心只有一个，万一它出故障了，会导致整个为服务环境不可用，所以需要搭建 Eureka 注册中心集群，实现<strong>负载均衡+故障容错</strong>。</p></div><p>完成 Eureka 集群的实现非常简单，就是通过将两个 Eureka 服务做到：<strong>互相注册，互相守望</strong>即可做到 Eureka 集群的高可用</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/14570c4b7c4dd8653be6211da2675e45.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/14570c4b7c4dd8653be6211da2675e45.png" alt=""></a></div><p>⛵使用步骤</p><div class="alert success no-icon"><ol><li>先启动 Eureka 注主册中心</li><li>启动<strong>服务提供者</strong> payment 支付服务</li><li>服务启动后会把自身信息(服务地址以别名方式注朋进 eureka)</li><li>消费者 order 服务在需要调用接口时，<strong>使用服务别名去注册中心获取服务的远程地址</strong></li><li>消费者获得调用地址后，底层实际是利用 HttpClient 技术实现远程调用</li><li>消费者会将服务地址后会缓存在本地 JVM 内存中，默认每间隔 30 秒更新一次服务调用地址</li></ol></div><p>默认已经将<code>eureka7002.com</code> 和 <code>eureka7001.com</code> 映射到了本地<code>host</code>文件，映射地址就是<code>127.0.0.1</code></p><figure class="highlight yaml"><figcaption><span>Eureka 集群 1 配置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 7001 微服务配置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">instance:</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="string">eureka7001.com</span> <span class="comment">#eureka 服务端的实例名称</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#false 表示不向注册中心注册自己。</span></span><br><span class="line"><span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment">#false 表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line"><span class="attr">service-url:</span> <span class="comment">#集群指向其它 eureka</span></span><br><span class="line"><span class="attr">defaultZone:</span> <span class="string">http://eureka7002.com:7002/eureka/</span> <span class="comment">#单机就是 7001 自己</span></span><br><span class="line"><span class="comment">#defaultZone: http://eureka7001.com:7001/eureka/</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>Eureka 集群 2 配置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 7002 微服务配置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">7002</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">instance:</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="string">eureka7002.com</span> <span class="comment">#eureka 服务端的实例名称</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#false 表示不向注册中心注册自己。</span></span><br><span class="line"><span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment">#false 表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line"><span class="attr">service-url:</span> <span class="comment">#集群指向其它 eureka</span></span><br><span class="line"><span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/</span> <span class="comment">#单机就是 7002 自己</span></span><br><span class="line"><span class="comment">#defaultZone: http://eureka7002.com:7002/eureka/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时由于拥有了两个微服务注册中心，所以每一个客户端都需要更改注册中心的位置信息</p><figure class="highlight yaml"><figcaption><span>支付微服务需要增加的配置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">client:</span> <span class="comment">#表示是否将自己注册进 Eurekaserver 默认为 true。</span></span><br><span class="line"><span class="attr">register-with-eureka:</span> <span class="literal">true</span> <span class="comment">#是否从 EurekaServer 抓取已有的注册信息，默认为 true。单节点无所谓，集群必须设置为 true 才能配合 ribbon 使用负载均衡</span></span><br><span class="line"><span class="attr">fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line"><span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,</span> <span class="string">http://eureka7002.com:7002/eureka</span></span><br></pre></td></tr></table></figure><ol><li>先要启动 EurekaServer，7001/7002 服务</li><li>再要启动服务提供者 provider，8001</li><li>再要启动消费者</li></ol><p>在使用过程中，遇到如下问题：</p><div class="alert success no-icon"><ul><li>HTTP 可以启动，但是使用 HTTPS 就会出错（服务注册失败）不知道为什么？</li></ul></div><h2 id="服务发现（Discovery）"><a class="header-anchor" href="#服务发现（Discovery）">¶</a>服务发现（Discovery）</h2><p>对于注册进 eureka 里面的微服务，可以通过<strong>服务发现</strong>来获得该服务的信息</p><figure class="highlight java"><figcaption><span>Eureka 客户端启动类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span><span class="comment">//添加该注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentMain001</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>Eureka 客户端 Controller文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/discovery&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">discovery</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; services = discoveryClient.getServices();</span><br><span class="line">        <span class="keyword">for</span> (String element : services) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;*****element: &quot;</span>+element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取服务别名为 CLOUD-PAYMENT-SERVICE 的服务地址</span></span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (ServiceInstance instance : instances) &#123;</span><br><span class="line">            log.info(instance.getServiceId()+<span class="string">&quot;\t&quot;</span>+instance.getHost()+<span class="string">&quot;\t&quot;</span>+instance.getPort()+<span class="string">&quot;\t&quot;</span>+instance.getUri());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.discoveryClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Eureka-自我保护"><a class="header-anchor" href="#Eureka-自我保护">¶</a>Eureka 自我保护</h2><p>自我保护模式通常在一组客户端和 Eureka Server 之间存在网络分区场景下使用，一旦进入保护模式，Eureka Server 将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是<strong>不会注销任何微服务</strong>。默认<code>Eureka</code>开启了自我保护模式，进入首页的红字就是提示开启了保护模式</p><p>❓什么是自我保护模式</p><div class="alert success no-icon"><p>默认情况下，如果 Eureka Server 在一定时间内（默认时间为：90 秒）没有接收到某个微服务实例的心跳，Eureka Server 将会注销该实例。但是当网络分区故障发生时(例如：延时、卡顿、拥挤)，微服务客户端与 Eureka Server 之间无法正常通信，以上行为可能变得非常危险。因为微服务本身其实是健康的，此时本不应该注销这个微服务，错误的删除可能导致服务的丢失。Eureka 通过<strong>自我保护模式</strong>来解决这个问题，做到 AP 分布式系统。</p></div><p>当 Eureka Server 节点在短时间内丢失过多客户端时(可能发生了网络分区故障)，那么这个节点就会进入自我保护模式，<strong>在自我保护模式中，Eureka Server 会保护服务注册表中的信息，不再注销任何服务实例</strong>，自我保护默认是开启的，也可以通过使用<code>eureka.server.enable-self-preservation = false</code>禁用自我保护模式关闭</p><div class="alert success no-icon"><p>自我保护模式的设计哲学就是：宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例</p></div><div class="alert info no-icon"><p>📓综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是<strong>宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留）也不盲目注销任何健康的微服务</strong>；使用自我保护模式，可以让 Eureka 集群更加的健壮、稳定</p></div><figure class="highlight yaml"><figcaption><span>Eureka Client 心跳检测与持续时间配置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">instance:</span></span><br><span class="line"><span class="attr">instance-id:</span> <span class="string">payment8001</span></span><br><span class="line"><span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment"># #开发时没置小些，保证服务关闭后注册中心能即使剔除服务</span></span><br><span class="line"><span class="comment">#Eureka 客户端向服务端发送心跳的时间间隔，单位为秒(默认是 30 秒)</span></span><br><span class="line"><span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">1</span></span><br><span class="line"><span class="comment">#Eureka 服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是 90 秒)，超时将剔除服务</span></span><br><span class="line"><span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><div class="alert info no-icon"><p>🎶最好不要修改 30 秒的默认心跳间隔，因为 Server 会使用这个时间数值来判断是否出现了大面积故障</p></div><h2 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h2><p>接下来记录 Eureka 其他功能</p><h3 id="Eureka-Server-的身份验证"><a class="header-anchor" href="#Eureka-Server-的身份验证">¶</a>Eureka Server 的身份验证</h3><p>如果客户端的<code>eureka.client.serviceUrl.defaultZone</code>参数值(即 Eureka Server 的地址)中包含<code>HTTP Basic Authentication</code>信息，如<code>http://user:password@localhost:8761/eureka</code>，那么客户端就会自动使用该用户名、密码信息与 Eureka 服务端进行验证。如果需要更复杂的验证逻辑，必须注册一个<code>DiscoveryClientOptionalArgs</code>组件，并将<code>ClientFilter</code>组件注入，在这里定义的逻辑会在每次客户端向服务端发起请求时执行。由于 Eureka 的限制，Eureka 不支持单节点身份验证</p><h3 id="状态页和健康信息指示器"><a class="header-anchor" href="#状态页和健康信息指示器">¶</a>状态页和健康信息指示器</h3><p>Eureka 应用的状态页和健康信息默认的 url 为：<code>/info</code>和<code>/health</code>，这与<code>Spring Boot Actuator</code>中对应的 Endpoint 是重复的，因此必须进行修改，修改后的配置文件如下：</p><figure class="highlight yaml"><figcaption><span>Eureka 服务端状态页和健康信息器配置文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">instance:</span></span><br><span class="line"><span class="attr">statusPageUrlPath:</span> <span class="string">$&#123;management.context-path&#125;/info</span></span><br><span class="line"><span class="attr">healthCheckUrlPath:</span> <span class="string">$&#123;management.context-path&#125;/health</span></span><br></pre></td></tr></table></figure><h3 id="使用-HTTPS"><a class="header-anchor" href="#使用-HTTPS">¶</a>使用 HTTPS</h3><p>可以通过指定<code>EurekaInstanceConfig</code>类中的<code>eureka.instance.[nonSecurePortEnabled,securePortEnabled]=[false,true]</code>属性来指定是否使用 HTTPS。当配置使用 HTTPS 时，Eureka Server 会返回以<code>https</code>开头的服务地址。即使配置了使用 HTTPS，Eureka 的主页依然是以普通 HTTP 方式访问的，需要手动添加一些配置来将这些页面也通过 HTTPS 保护起来</p><figure class="highlight yaml"><figcaption><span>Eureka Service 配置文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">instance:</span></span><br><span class="line"><span class="attr">statusPageUrl:</span> <span class="string">https://$&#123;eureka.hostname&#125;/info</span></span><br><span class="line">    <span class="attr">healthCheckUrl:</span> <span class="string">https://$&#123;eureka.hostname&#125;/health</span></span><br><span class="line"><span class="attr">homePageUrl:</span> <span class="string">https://$&#123;eureka.hostname&#125;/</span></span><br></pre></td></tr></table></figure><p>🎶<code>eureka.hostname</code>是 Eureka 原生属性，只有新版本的 Eureka 才支持该属性，也可以使用 Spring EL 表达式代替<code>$&#123;eureka.instance.hostName&#125;</code></p><h3 id="健康检查"><a class="header-anchor" href="#健康检查">¶</a>健康检查</h3><p>默认情况下，Eureka 通过客户端发来的心跳包来判断客户端是否在线。如果不显式指定，客户端在心跳包中不会包含当前应用的健康数据。这意味着只要客户端启动时完成了服务注册，那么该客户端在主动注销之前在 Eureka 中的状态会永远是<code>UP</code>状态。我们可以通过配置修改这一默认行为，即在客户端发送心跳包时会带上自己的健康信息。这样做的后果是只有当该服务的状态是<code>UP</code>时才能被访问，其它的任何状态都会导致该服务不能被调用</p><figure class="highlight yaml"><figcaption><span>Eureka Service 配置文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line"><span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>如果想对健康检查有更细粒度的控制，可以自己实现<code>com.netflix.appinfo.HealthCheckHandler</code>接口，做到自定义健康检查机制</p><h3 id="Eureka-元数据说明"><a class="header-anchor" href="#Eureka-元数据说明">¶</a>Eureka 元数据说明</h3><p>了解 Eureka 的元数据，就可以添加一些自定义的数据以适应特定的业务场景。像主机名、IP 地址、端口号、状态页 url 和健康检查 url 都是 Eureka 定义的标准元数据。这些元数据会被保存在 Eureka Server 的注册信息中，客户端会读取这些数据来向需要调用的服务直接发起连接。可以使用以<code>eureka.instance.metadataMap</code>开头的参数来添加自定义的元数据，所有客户端都会读取到该信息。通过这种方式你能给客户端自定义一些行为</p><h3 id="使用-Spring-的-DiscoveryClient-对象"><a class="header-anchor" href="#使用-Spring-的-DiscoveryClient-对象">¶</a>使用 Spring 的 DiscoveryClient 对象</h3><p>没有必要直接使用 Netflix 原生的<code>EurekaClient</code>对象，在此基础上做一些封装使用起来会更方便。Spring Cloud 支持<code>Feign</code>和<code>Spring RestTmpelate</code>，它们都可以使用服务的逻辑名而不是 URL 地址来查询服务。也可以使用 Spring 提供的<code>DiscoveryClient</code>对象访问远程服务，从而代码就不会与 Eureka 紧耦合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">serviceUrl</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(<span class="string">&quot;STORES&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="literal">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>).getUri();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="伙伴感知"><a class="header-anchor" href="#伙伴感知">¶</a>伙伴感知</h3><p>Eureka Server 可以通过运行多个实例并相互指定为<strong>伙伴</strong>的方式来达到更高的高可用性。实际上这就是默认设置，只需要指定伙伴的地址就可以了，这也就是之前说的 Eureka 集群方式</p><h2 id="swig￼46"><a class="header-anchor" href="#swig￼46">¶</a><figure class="highlight yaml"><figcaption><span>Eureka Server伙伴感知配置文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">profiles:</span> <span class="string">peer1</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">instance:</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="string">peer1</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">serviceUrl:</span></span><br><span class="line"><span class="attr">defaultZone:</span> <span class="string">http://peer2/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">profiles:</span> <span class="string">peer2</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">instance:</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="string">peer2</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">serviceUrl:</span></span><br><span class="line"><span class="attr">defaultZone:</span> <span class="string">http://peer1/eureka/</span></span><br></pre></td></tr></table></figure></h2><p>在上面这个例子中，通过使用不同<code>profile</code>配置的方式可以在本地运行两个 Eureka Server。可以通过修改<code>/etc/host</code>文件，使用上述配置在本地测试伙伴感特性。可以同时启动多个 Eureka Server, 并通过伙伴配置使之围成一圈(相邻两个 Server 互为伙伴)，这些 Server 中的注册信息都是同步的。如果伙伴在物理上是分开的，那么系统原则上可以承受脑裂类型的故障</p><h3 id="Eureka-的高可用"><a class="header-anchor" href="#Eureka-的高可用">¶</a>Eureka 的高可用</h3><p>Eureka 把所有注册信息都放在<strong>内存</strong>中，所有注册过的客户端都会向 Eureka 发送心跳包来保持连接。客户端会有一份本地注册信息的缓存，这样就不需要每次远程调用时都向 Eureka 查询注册信息。默认情况下，Eureka 服务端自身也是个客户端，所以需要指定一个 Eureka Server 的 URL 作为&quot;伙伴&quot;(peer)。如果没有提供这个地址，Eureka Server 也能正常启动工作，但是在日志中会有大量关于找不到 peer 的错误信息</p><h3 id="为什么注册一个服务这么慢"><a class="header-anchor" href="#为什么注册一个服务这么慢">¶</a>为什么注册一个服务这么慢?</h3><p>服务的注册涉及到心跳连接，默认为每 30 秒一次。只有当 Eureka 服务端和客户端本地缓存中的服务元数据相同时这个服务才能被其它客户端发现，这需要 3 个心跳周期。可以通过参数<code>eureka.instance.leaseRenewalIntervalInSeconds</code>调整这个时间间隔来加快这个过程。在生产环境中最好使用默认值，因为 Eureka 内部的某些计算依赖于该时间间隔</p><h3 id="Standalone-模式"><a class="header-anchor" href="#Standalone-模式">¶</a>Standalone 模式</h3><p>只要 Eureka Server 进程不会挂掉，这种集 Server 和 Client 于一身的模式能让 Standalone 部署的 Eureka Server 非常容易进行灾难恢复。在 Standalone 模式中，可以通过下面的配置来关闭查找伙伴的行为</p><figure class="highlight yaml"><figcaption><span>Eureka Service Standlone 配置文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8761</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">instance:</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">registerWithEureka:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">fetchRegistry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">serviceUrl:</span></span><br><span class="line"><span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><p>🎶<code>serviceUrl</code>中的地址的主机名要与本地主机名相同</p><h3 id="使用-IP-地址"><a class="header-anchor" href="#使用-IP-地址">¶</a>使用 IP 地址</h3><p>有些时候可能更倾向于直接使用 IP 地址定义服务而不是使用主机名。把<code>eureka.instance.preferIpAddress</code>参数设为<code>true</code>时，客户端在注册时就会使用自己的 ip 地址而不是主机名</p><h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2><p><a target="_blank" rel="noopener" href="http://docs.springcloud.cn/user-guide/eureka/">官方中文文档</a><br><a target="_blank" rel="noopener" href="https://martian101.github.io/2017/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-Eureka%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/">微服务之服务发现 Eureka 的介绍与使用</a><br><a target="_blank" rel="noopener" href="http://docs.springcloud.cn/user-guide/eureka/">Eureka 学习文档资料</a></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/" data-tooltip="随机算法" aria-label="上一篇: 随机算法"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/" data-tooltip="程序的内存布局" aria-label="下一篇: 程序的内存布局"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/" data-tooltip="随机算法" aria-label="上一篇: 随机算法"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/" data-tooltip="程序的内存布局" aria-label="下一篇: 程序的内存布局"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>