<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>服务的状态 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="状态"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n有状态服务和无状态服务是两种不同的服务架构，两者的不同之处在于对于服务状态的处理，本文将主要记录：什么是状态？不同的状态会对服务产生什么样的影响、以及为什么如今都倡导无状态服务？\n\n¶概述\n状态化的判断是指两个来自相同发起者的请求在服务器端是否具备上下文关系。基于此，有/无状态的应用程序特点如下：\n\n无状态应用程序或进程是不保存或引用有关先前操作的信息的东西。每次它都像第一次一样从头开始执行每个操作，并使用 CDN 或 Web 服务器的功能来处理每个短期请求。\n\n例如，有人在搜索引擎中搜索问题并按下了 Enter 按钮。如果搜索操作由于某种原因被中断或关闭，您必须重新进行刚刚的搜索操作，因为没有为您之前的请求保存数据。\n\n\n有状态应用程序会记住用户的特定详细信息，例如个人资料、首选项和用户操作。这些信息被视为系统的「 状态 」\n\n例如：在网购时，每次您选择一个商品并将其添加到您的购物车时，您都会将它与之前添加的商品一起添加，并最终导航到结帐页面，每次添加新商品时，不会丢失之前的任何信息\n\n简而言之，无状态服务不会记录服务状态，不同请求之间也是没有任何关系；而有状态服务则刚好相反，不同的请求之间是有关联关系的。判断一个服务状态性最简单的标识就是：两个来自相同发起者的请求在服务端是否具有上下文关系\nRedHat 对于应用的状态具有下列的见解：\nThe state of an application (or anything else, really) is its condition or quality of being at a given moment in time–its state of being. Whether something is stateful or stateless depends on how long the state of interaction with it is being recorded and how that information needs to be stored.\n应用（或其他任何事物）的状态是指它在特定时间的状况或品质，即当前应用的一种存在属性（运行中或宕机了）。要判断一个应用是有状态还是无状态的，取决于和这个应用交互的过程中，当前这种交互状态维持的时间以及是否需要在这个过程中需要存储的信息\nRedHat云原生下应用的状态\n¶服务的状态\n下文将详细介绍有状态服务与无状态服务的定义，两者的区别。讨论为什么如今大家都呼吁无状态服务，对于现有的有状态服务如何无状态化？\n¶有状态服务\n有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，随后根据用户身份对请求执行不同的处理流程，典型的设计就是 web 应用中的 session。使用 Session 来维系登录用户的上下文信息。此时就算使用无状态的 http 协议，最终也会由于 session 的介入将此变为有状态服务\n\n例如，用户登录案例：用户登录后，我们把登录者的信息保存在服务端 session 中，并且给用户一个 cookie ，它对应着服务器存储的 session。在下次请求时，用户请求携带 cookie 访问服务，服务器就能识别到对应 session，从而找到用户的信息\n\n\n😣 如今大家普遍不喜欢使用有状态服务，就是因为有状态服务存在以下的缺点：\n\n服务端保存大量数据，增加服务端压力\n服务端保存用户状态，无法进行水平扩展\n客户端请求依赖服务端，多次请求必须访问同一台服务器\n\n\n尽管有状态服务存在许多缺陷，但是有状态服务仍然存在一些优点：\n有状态服务可以做到较好的数据局部性（可通过函数传递范例来实现）、高可用和强并发模式。当状态是共享的跨调用时，开发是容易的，由于不需要额外的持久存储，通常有状态能够做到低延时优化\n\n¶有状态服务的数据局部性\n数据局部性是指每个请求都会被路由到可以操作数据的机器上。当一个请求做到时第一次命中了数据存储，之后处理数据的请求离开了服务，将来来自内存中的数据可以让类似的请求更快的找到同样的服务。如此进行的结果就是能够达到低延时响应，毋需再去访问数据存储。这就是「 函数传递范例 」，是有状态服务和无状态服务区别的关键所在\n\n¶有状态服务的强一致性\n有状态的服务通常会导致服务的强一致性。有状态的服务可以构建一种粘性的链接，也就是说客户端的请求总是会被路由到最初为之提供服务的服务器主机上。以此方式实现的服务，可以增加 AP 系统的一致性力度。这种强一致性模式包括线性随机访问内存和读你所写（Read your Write）。Werner Vogels 在他的文章中总结了这些内容\n无状态的服务很容易的通过给后端添加服务器和前端的负载均衡实现横向的扩展。此类应用拥有叫做「 数据运送范例 」的方式，就是数据被请求时是来自后端的数据存储为请求提供，在未来的请求中，若相同的数据被请求时，是不会去关心这些请求是从哪个服务实例来的，因为服务实例是无状态的.McCaffrey 谈到在通信频繁的应用中这种架构简直是一种浪费，因为这些应用要在服务端与客户端之间频繁的通信，而且在此类应用中有状态的服务显然是一种更好的选择\n¶有状态应用的粘性连接\n粘性连接可以使用持久性的连接来实现，但是会带来负载在后端分布不均的问题，这就会导致客户端捆绑到服务器，而有些服务器不能得到充分利用，最终导致部分服务器负载过多。其中一个减轻此种后端压力的方法就是一旦达到某个阀值就拒绝再来的请求（提前拒绝请求）。\n非粘性的服务还可以通过路由的逻辑来实现，这可以使得任何的客户端通过获得正确的路由来找到任何的服务器。此实现会带来两个问题，路由到集群成员（谁在我的集群中？）和工作分布（谁来做？）。集群成员可以是静态的也可以是动态的。后者可以通过使用 gossip 协议和共识系统来实现。工作分布则有更多的实现机制－随机替代、一致性哈希、以及分布式哈希表\nMcCaffrey 在他的演讲中列出了一些构建有状态服务的陷阱，其中包括没有绑定的数据结构导致的内存问题、类似长期的垃圾回收暂停和重载状态时出现的内存管理问题等。状态重载会在恢复和部署新代码时发生，这两者都会像第一次从数据库中获取数据那样付出高昂的代价。\n¶图解有状态服务\n程序做的事情本质上就是数据的移动和组合，以此来达到我们所期望的结果。其中如何移动、如何组合是由「 算法 」来定的。任何一个「 结果 」都是通过一系列的「 行动 」将最开始的「 原料 」进行加工、转化得来。\n\n比如，你将常温的水，通过倒入水壶、通电加热等工作后将常温的水变成了 100 度的水，这是常见的烧水过程。这个过程需要好几道行动才能得到结果。\n\n这个时候如果想降低这几道行动的成本，天然的想法就是提炼出反复要做的事情，将各个独立的行动并行化。在程序中的实现就是将一部分数据放到一个「暂存区」中以提供给相关的行动共用\n\n但是如此一来，就导致了需要增加一道关系，以表示每一个行动与哪一个「暂存区」关联。一旦拥有了关联关系，此时行动就变成了「有状态」\n\n共用同一个「暂存区」的多个行动所处的环境经常被称作「上下文」。「暂存区」里存的是「数据」，所以可以理解为有数据就等价于有状态。「数据」在程序中的作用范围分为「局部」和「全局」（对应局部变量和全局变量），因此「状态」其实也可以分为两种，一种是局部的「会话状态」，一种是全局的「资源状态」\n因为有些服务端不单单负责运算，还会提供其自身范围内的「数据」出去，这些「数据」属于服务端完整的一部分，被称作「资源」。所以，理论上「资源」可以被每个「会话」来使用，因此是全局的状态\n与「有状态」相反的是「无状态」，「无状态」意味着每次加工所需的原料全部由外界提供，服务端内部不做任何的「暂存区」。并且请求可以提交到服务端的任意副本节点上，处理结果都是完全一样的\n有一类方法天生是「无状态」，就是负责表达移动和组合的「 算法 」。因为它的本质就是：接收「 原料 」「 加工 」并返回「 成果 」\n如果想获得更好的伸缩性以及容错性，就需要尽量将「有状态」的处理机制改造成「无状态」的处理机制\n¶有状态服务的无状态化处理\n⛵ 「有状态」的处理过程是可以改造成「无状态」的处理过程对，具体的改造步骤如下：\n\n状态信息前置，丰富入参，将处理需要的数据尽可能都通过上游的客户端放到入参中传过来\n\n\n\n这种方案的弊端会让网络数据包的体积更大一些\n\n客户端与服务端的交互中如果涉及到多次交互，则需要来回传递后续服务端处理中所需的数据，以避免需要在服务端暂存。例子如下图，图中橙色表示请求，绿色表示响应\n\n\n\n通过上述两步改造的目的都是为了尽量少出现类似下面的代码：\n123int func()&#123;    return i++;&#125;\n而是多出现这样的代码：\n123int func(i)&#123;    return i+1;&#125;\n要更好的做好「无状态」化的工作，基本依赖于在架构设计或者项目设计中的合理分层。尽量将会话状态相关的处理上浮到最前面的层，因为只有最前面的层才与系统使用者接触，如此一来，其它的下层就可以将「无状态」作为一个普遍性的标准去做。与此同时，由于会话状态集中在最前面的层，所以哪怕真的状态丢失了，重建状态的成本相对也小很多。比如三层架构的话，保证 BLL(业务逻辑层) 和 DAL（数据访问层） 都不要有状态，代码的可维护性大大提高\n在这里，提到做分层的目的是为了说明，只有将 IO 密集型程序和 CPU 密集型程序分离，才是通往「无状态」真正的出路。一旦分离后，CPU 密集型的程序自然就是「无状态」了.如此也能更好的做「弹性扩容」。因为常见的需要「弹性扩容」的场景一般指的就是 CPU 负荷过大的时候\n\n如果前面的都不合适，可以将共享存储作为降级预案来运用，如远程缓存、数据库等。然后当状态丢失的时候可以从这些共享存储中恢复\n\n\n所以，最理想的状态存放点，要么在最前端，要么在最底层的存储层\n\n任何事物都是有两面性的，正如前面提到的，我们并不是要所有的业务处理都改造成「无状态」，而只是挑其中的一部分。最终还是看价值，看性价比。例如，将一个以状态为核心的即时聊天工具的所有处理过程都改造成「无状态」的，就有点得不偿失了\n\n¶运行有状态工作负载的挑战\n运行有状态工作负载有多种挑战：\n\n资源隔离：目前市场上的许多容器编排解决方案仍然只涉及一种尽力而为的资源分配方法，例如 CPU、内存和存储。这可能适用于无状态微服务，但对于有状态微服务来说，这可能是一种灾难性的方法，客户交易或数据由于性能不可靠而丢失\n持久存储：每个有状态数据服务可能需要或支持不同类型的存储类型（例如块设备或分布式文件系统），并且确定有状态服务的后备存储类型可能具有挑战性\n\n\n¶无状态服务\n无状态服务对于客户端的单次请求的处理，不依赖于其他请求，处理一次请求的信息都包含在该请求里。最典型的就是通过 cookie 保存 token 的方式传输请求数据。最终，客户端每次请求都携带自描述信息，服务端通过这些信息识别客户端身份，在服务端本地并不保存任何客户端请求者信息。就算有多个服务端，它们对同一个请求响应的结果也是完全一致的。\n\n\n✨无状态服务特点\n\n客户端请求不依赖服务端的信息，任何多次请求不需要必须访问到同一台服务\n服务端的集群和状态对客户端透明\n服务端可以任意的迁移和伸缩\n减小服务端存储压力\n\n\n无状态服务的实例可能会因为一些原因停止或者重新创建（如扩容时）。这时，这些停止的实例里的所有信息（除日志和监控数据外）都将丢失(重启容器即会丢失)。因此如果您的容器实例里需要保留重要的信息，并希望随时可以备份以便于以后可以恢复的话，那么建议您创建有状态服务。\n❓ 为什么网上主流的观点都在说要将方法多做成「无状态」的呢？\n\n\n一方面，因为我们更习惯于编写「有状态」的代码，但是「有状态」不利于系统的易伸缩性和可维护性。在分布式系统中，「有状态」意味着一个用户的请求必须被提交到保存有其相关状态信息的服务器上，否则这些请求可能无法被其他机器理解，导致服务器端无法对用户请求进行自由调度，如此对分布式集群的水平扩展非常不友好。\n\n\n另一方面，有状态服务也导致了容错性不好，倘若保有用户信息的服务器宕机，那么该用户最近的所有交互操作将无法被透明地移送至备用服务器上，除非该服务器时刻与主服务器同步全部用户的状态信息。\n\n\n\n¶无状态服务是如何工作的\n无状态架构意味着应用程序依赖于第三方存储，因为它不会在内存或磁盘上存储任何类型的状态。它请求的所有数据都必须从其他有状态服务（数据库）中获取或数据本身就存在于 CRUD 请求中\n\n对于无状态应用，任何一个请求首先会发送到负载均衡器上，随后负载均衡器将请求负载到无状态服务的任何一个副本上，因为服务中的所有数据都存储在其他地方（通常是具有持久存储的数据库）所以不同副本上对于请求执行相同逻辑。由于状态信息与每个请求一起发送到服务器，服务器通过该服务器继续为请求提供服务。Load-balancer 不需要担心将请求路由到同一台服务器，真正实现了负载均衡。 其中 JSON Web Token (JWT) 广泛用于创建无状态应用程序\n然而对于有状态应用是不同的，当有状态应用程序中的并发用户数量增加时，添加更多运行相同程序的服务器（横向扩展），并使用负载平衡器在这些服务器之间均匀分配负载。但是由于每个服务器「 记住 」每个登录用户的状态，因此有必要将负载均衡器配置为「粘性模式 」。粘性模式下，负载均衡器将每个用户的请求发送到响应该用户先前请求的同一台服务器。这违背了负载均衡的目的，此时就算对系统进行了水平扩展，也会由于粘性负载的关系，整个系统的负载并不均衡。\n✨ 以下是无状态应用程序的 5 个主要优点：\n\n消除创建/使用会话的开销（减少服务端的内存使用、消除会话国旗问题）\n横向扩展以满足现代用户的需求\n按需添加/删除应用程序的新实例\n它允许跨各种应用程序的一致性\n无状态使应用程序更易于使用和可维护\n\n\n¶无状态应用程序的最佳实践\n无状态应用不惜一切代价避免 session，主要是以下几点原因：\n\nsession 为系统增加了不必要的复杂性，但为系统带来的价值却非常少。session 重现错误十分困难，由于所有内容都存储在服务器端，因此很难修复与会话相关的错误。\n会话无法扩展。如果应用程序的负载呈指数增长，应当将请求负载到不同的服务器。如果使用会话，需要将所有会话复制到所有服务器。该系统变得非常复杂且容易出错。\n\n\n如此也并不是说会话就是一个很糟糕的技术，会话仅对特定用例有用，例如 FTP（文件传输协议）。对于共享 Dropbox 等用例，有状态会话会增加额外的开销，而无状态则是完美的方式。会话功能使用 cookie 复制，在客户端缓存\n¶为什么无状态服务很重要\n如今倡导无状态简而言之就是为了让系统得到一种特性：伸缩性（scaliability）\n❓ 以前有状态应用程序运行良好，为什么还需要无状态应用程序？\n有状态的应用程序适合规模较小的应用程序，应对于复杂的系统有状态架构存在一些问题。首先，当用户在服务器上引用一个状态时，用户打开了很多不完整的会话和交易发生，在 Stateful 系统中，客户端计算出的状态，系统应该让连接保持多久？如何在服务器端验证客户端是否崩溃或与会话断开连接？在维护文档更改和回滚的同时如何跟踪用户的操作？这些都是有状态应用程序带来的难题。因此，想要回避这些难题，最好使用无状态服务。\n\nFacebook 不断使用无状态服务。当服务器使用 Facebook API 请求最近消息的列表时，它会发出一个带有令牌和日期的 GET 请求。响应独立于任何服务器状态，一切都以缓存的形式存储在客户端的机器上。类似地，调用 POST 命令，在不考虑服务器状态的情况下，在标头中传递带有授权/身份验证数据的复杂主体与上一个、当前和下一个请求没有关系。在无状态中，客户端不会等待来自服务器的同步。\nREST 是设计、架构和开发现代 API 的主流方式，值得注意的是：REST 就是一种典型的无状态架构。\n\n¶如何采用无状态应用程序\n⛵ 以下是采用无状态应用程序的 5 个步骤\n\n适应和开发新应用程序。采用无状态应用程序起初可能是一项艰巨的任务，因为它是一种新范式。但是，通过正确的思维方式，可以在不保持任何状态的情况下适应和开发新的应用程序。\n使用微服务开发应用程序。在此步骤中，将出于部署目的进行容器化。容器最擅长运行无状态工作负载。当需要管理的多个容器增加时，可以考虑切换到 Kubernetes 等云编排和管理工具来运行大量容器\n容器化微服务应用程序。从资源点找到运行安全的容器的最佳位置，并维护应用程序的高可用性\n将存储附加到无状态临时文件。附加到无状态的存储是短暂的。组织必须从无状态容器开始，因为它们更容易适应这种类型的架构，并且与单体应用程序分离并独立扩展\n应用 REST 哲学。后端应该使用 REST 设计模式来构建应用程序。REST 哲学不是维护状态，只是在客户端稍微维护 cookie 和本地存储\n\n\n¶总结\n🆚 无状态服务和有状态服务主要有以下区别\n\n\n实例数量：无状态服务可以有一个或多个实例，因此支持两种服务容量调节模式；有状态服务只能有一个实例，不允许创建多个实例，因此也不支持服务容量调节模式\n\n\n存储卷：无状态服务可以有存储卷，也可以没有，即使有也无法备份存储卷里面的数据；有状态服务必须要有存储卷，并且在创建服务时，必须指定给该存储卷分配的磁盘空间大小\n\n\n数据存储：无状态服务运行过程中的所有数据（除日志和监控数据）都存在容器实例里的文件系统中，如果实例停止或者删除，则这些数据都将丢失，无法找回；而对于有状态服务，凡是已经挂载了存储卷的目录下的文件内容都可以随时进行备份，备份的数据可以下载，也可以用于恢复新的服务。但对于没有挂载卷的目录下的数据，仍然是无法备份和保存的，如果实例停止或者删除，这些非挂载卷里的文件内容同样会丢失。\n\n\n\n无状态服务是指该服务的实例可以将一部分数据随时进行备份，并且在创建一个新的有状态服务时，可以通过备份恢复这些数据，以达到数据持久化的目的。有状态服务只能有一个实例，因此不支持「 自动服务容量调节 」。一般来说，数据库服务或者需要在本地文件系统存储配置文件或其它永久数据的应用程序可以创建使用有状态服务。要想创建有状态服务，必须满足几个前提：\n\n待创建的服务镜像（image）的 Dockerfile 中必须定义了存储卷（Volume），因为只有存储卷所在目录里的数据可以被备份\n创建服务时，必须指定给该存储卷分配的磁盘空间大小。\n如果创建服务的同时需要从之前的一个备份里恢复数据，那么还要指明该存储卷用哪个备份恢复。\n\n\n有状态应用和流程是可以周而复始、反复发生的应用和流程，例如网上银行或电子邮件。这些操作是在先前的事务背景下执行的，当前事务可能会受到先前事务的影响。正因如此，有状态应用在每次处理用户的请求时都会使用相同的服务器。如果有状态事务被中断，其上下文和历史记录会被存储下来，这样就可以或多或少地从上次中断的地方继续。有状态应用会跟踪诸如窗口位置、设置首选项和近期活动等内容。我们可以把有状态事务视为与同一个人进行的定期对话。\n有状态和无状态应用程序在互联网中无处不在，但是现代大部分软件是以无状态方式构建的，这是因为可伸缩性是如今大型系统非常重要的一个因素\n\n¶无状态和有状态的容器管理\n有状态现在已成为容器存储的主体，因此现在的问题从要不要使用有状态容器，变成了该如何使用这些有状态容器？\n最初，容器被构建为无状态，因为这比较符合其便携、灵活的特性。但随着容器的广泛使用，人们开始对现有的有状态应用进行容器化处理（重新设计和重新封装，以实现容器的便捷扩缩容）。究竟是使用有状态还是无状态容器，要取决于构建哪种类型的应用以及用途。如果只是临时需要信息（快速而短暂），无状态便是解决之道。但如果应用需要更多的内存来存储从一个会话到下一个会话的操作，则应用采用有状态方式\n\n正因为这个原因，有状态应用越来越像无状态应用，无状态应用向有状态应用靠近的趋势，如：存在一个无状态的应用，它不需要长期存储，但允许服务器使用 Cookie 来跟踪同一客户端的请求。尽管无状态应用程序以不同的方式工作，但它们不会在服务器上存储任何状态。\n它们使用 DB 来存储所有信息。DB 是有状态的，即它具有附加的持久存储。通常，用户请求使用凭据登录，LB 后面的任何服务器都会处理该请求，生成一个 auth 令牌，将其存储在 DB 中，然后将令牌返回给前端的客户端。下一个请求与令牌一起发送，现在，无论哪个服务器处理请求，它都会将令牌与数据库中的信息进行匹配，并授予用户登录权限。每个请求都是独立的，与前一个或下一个请求没有任何联系，就像 REST 一样。尽管无状态应用程序有一个额外的调用 DB 的开销，但这些应用程序在水平扩展方面非常出色，这对于可能拥有数百万用户的现代应用程序至关重要。\n¶无状态主从集群设计\n构建单机服务非常简单，但如果单机服务可靠性或性能不足，就需要多机器共同承担某项服务。集群化包含以下四种情况：\n\n\n\n集群格式\n含义\n\n\n\n\n无状态主备集群\n仅有一台主机完成任务，且没有本地状态，其余从机机器待命，一旦主机宕机，从机选主成为主机\n\n\n有状态主备集群\n仅有一台主机完成任务，有本地状态，其余从机机器待命，一旦主机宕机，从机选主成为主机\n\n\n无状态的主从集群\n所有机器没有本地状态，理论上机器可以无限叠加，共同向外界提供同一服务。\n\n\n有状态的主从集群\n所有机器都有本地状态，共同向外界提供同一服务。一旦某台机器宕机，需要主机协调其他从机代理其本地状态的任务\n\n\n\n¶结论\n有时您必须构建有状态的服务，这不会自动损害您进行 SaaS 开发的准备。但是，您需要确保对有状态服务进行某种扩展，并计划备份和快速灾难恢复。虽然这几乎总是可能的，但工作量可能比在无状态微服务上获得更好结果所需的工作要多得多。\n¶附录\nRedHat\nStateful and Stateless Applications Best Practices and Advantages\n分布式系统中的“无状态”和“有状态”详解\n构建可伸缩的有状态服务\n【高可用架构】理解有状态服务和无状态服务\nService statelessness principle\n无状态服务 VS 有状态服务\nPRAM consistency\nService statelessness principle\n分布式基础 5-无状态主从集群设计\n","dateCreated":"2022-02-23T09:18:39+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2022-02-23T09:18:39+00:00","description":"经常听到什么有状态服务，无状态服务，这些概念究竟想要表达什么含义？","headline":"服务的状态","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81/","keywords":"操作系统"}</script><meta name="description" content="经常听到什么有状态服务，无状态服务，这些概念究竟想要表达什么含义？"><meta property="og:type" content="blog"><meta property="og:title" content="服务的状态"><meta property="og:url" content="https://pineapple-man.github.io/%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="经常听到什么有状态服务，无状态服务，这些概念究竟想要表达什么含义？"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/stateful-and-stateless-applications.webp"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/image-20211102194134064.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/state1.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/state2.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/state3.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/state4.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/state5.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/state6.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/state7.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/image-20211102194130571.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/xenonstack-how-stateless-applications-works.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/xenonstack-stateful-vs-stateless.webp"><meta property="article:published_time" content="2022-02-23T09:18:39.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.007Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="操作系统"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/stateful-and-stateless-applications.webp"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">服务的状态</h1><div class="post-meta"><time datetime="2022-02-23T09:18:39+00:00">2月 23, 2022 </time><span>发布在 </span><a class="category-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 7.6k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 69 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text">服务的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1"><span class="toc-text">有状态服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-text">有状态服务的数据局部性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">有状态服务的强一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E5%BA%94%E7%94%A8%E7%9A%84%E7%B2%98%E6%80%A7%E8%BF%9E%E6%8E%A5"><span class="toc-text">有状态应用的粘性连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1"><span class="toc-text">图解有状态服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%97%A0%E7%8A%B6%E6%80%81%E5%8C%96%E5%A4%84%E7%90%86"><span class="toc-text">有状态服务的无状态化处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%89%E7%8A%B6%E6%80%81%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-text">运行有状态工作负载的挑战</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1"><span class="toc-text">无状态服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-text">无状态服务是如何工作的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">无状态应用程序的最佳实践</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E5%BE%88%E9%87%8D%E8%A6%81"><span class="toc-text">为什么无状态服务很重要</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%87%87%E7%94%A8%E6%97%A0%E7%8A%B6%E6%80%81%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">如何采用无状态应用程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E5%92%8C%E6%9C%89%E7%8A%B6%E6%80%81%E7%9A%84%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-text">无状态和有状态的容器管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4%E8%AE%BE%E8%AE%A1"><span class="toc-text">无状态主从集群设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-text">结论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol><p><strong>有状态服务</strong>和<strong>无状态服务</strong>是两种不同的服务架构，两者的不同之处在于对于服务状态的处理，本文将主要记录：什么是状态？不同的状态会对服务产生什么样的影响、以及为什么如今都倡导无状态服务？<br><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/stateful-and-stateless-applications.webp" alt=""></p><h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><p>状态化的判断是指两个来自相同发起者的请求在服务器端是否具备上下文关系。基于此，有/无状态的应用程序特点如下：</p><div class="alert success no-icon"><ul><li>无状态应用程序或进程是不保存或引用有关先前操作的信息的东西。每次它都像第一次一样从头开始执行每个操作，并使用 CDN 或 Web 服务器的功能来处理每个短期请求。</li></ul><div class="alert warning no-icon"><p>例如，有人在搜索引擎中搜索问题并按下了 Enter 按钮。如果搜索操作由于某种原因被中断或关闭，您必须重新进行刚刚的搜索操作，因为没有为您之前的请求保存数据。</p></div><ul><li>有状态应用程序会记住用户的特定详细信息，例如个人资料、首选项和用户操作。这些信息被视为系统的「 状态 」</li></ul><div class="alert warning no-icon"><p>例如：在网购时，每次您选择一个商品并将其添加到您的购物车时，您都会将它与之前添加的商品一起添加，并最终导航到结帐页面，每次添加新商品时，不会丢失之前的任何信息</p></div></div><p>简而言之，无状态服务<strong>不会记录服务状态</strong>，<strong>不同请求之间也是没有任何关系</strong>；而有状态服务则刚好相反，<strong>不同的请求之间是有关联关系的</strong>。判断一个服务状态性最简单的标识就是：两个来自相同发起者的请求在服务端是否具有上下文关系</p><p>RedHat 对于应用的状态具有下列的见解：</p><blockquote><p>The state of an application (or anything else, really) is its condition or quality of being at a given moment in time–its state of being. Whether something is stateful or stateless depends on how long the state of interaction with it is being recorded and how that information needs to be stored.</p><p>应用（或其他任何事物）的状态是指它在特定时间的状况或品质，即当前应用的一种存在属性（运行中或宕机了）。要判断一个应用是有状态还是无状态的，取决于和这个应用交互的过程中，当前这种交互状态维持的时间以及是否需要在这个过程中需要存储的信息</p><footer><strong>RedHat</strong><cite><a target="_blank" rel="noopener" href="https://www.redhat.com/zh/topics/cloud-native-apps/stateful-vs-stateless">云原生下应用的状态</a></cite></footer></blockquote><h2 id="服务的状态"><a class="header-anchor" href="#服务的状态">¶</a>服务的状态</h2><p>下文将详细介绍<strong>有状态服务</strong>与<strong>无状态服务</strong>的定义，两者的区别。讨论为什么如今大家都呼吁无状态服务，对于现有的有状态服务如何无状态化？</p><h3 id="有状态服务"><a class="header-anchor" href="#有状态服务">¶</a>有状态服务</h3><div class="alert success no-icon"><p>有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，随后根据用户身份对请求执行不同的处理流程，典型的设计就是 web 应用中的 session。使用 Session 来维系登录用户的上下文信息。此时就算使用无状态的 http 协议，最终也会由于 session 的介入将此变为有状态服务</p></div><div class="alert warning no-icon"><p>例如，用户登录案例：用户登录后，我们把登录者的信息保存在服务端 session 中，并且给用户一个 cookie ，它对应着服务器存储的 session。在下次请求时，用户请求携带 cookie 访问服务，服务器就能识别到对应 session，从而找到用户的信息</p></div><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/image-20211102194134064.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/image-20211102194134064.png" alt=""></a></div><p>😣 如今大家普遍不喜欢使用有状态服务，就是因为有状态服务存在以下的缺点：</p><div class="alert info no-icon"><ul><li>服务端保存大量数据，增加服务端压力</li><li>服务端保存用户状态，无法进行水平扩展</li><li>客户端请求依赖服务端，多次请求必须访问同一台服务器</li></ul></div><p>尽管有状态服务存在许多缺陷，但是有状态服务仍然存在一些优点：</p><div class="alert info no-icon"><p>有状态服务可以做到较好的数据局部性（可通过函数传递范例来实现）、高可用和强并发模式。当状态是共享的跨调用时，开发是容易的，由于不需要额外的持久存储，通常有状态能够做到低延时优化</p></div><h4 id="有状态服务的数据局部性"><a class="header-anchor" href="#有状态服务的数据局部性">¶</a>有状态服务的数据局部性</h4><div class="alert success no-icon"><p>数据局部性是指每个请求都会被路由到可以操作数据的机器上。当一个请求做到时第一次命中了数据存储，之后处理数据的请求离开了服务，将来来自内存中的数据可以让类似的请求更快的找到同样的服务。如此进行的结果就是能够达到低延时响应，毋需再去访问数据存储。这就是「 函数传递范例 」，是有状态服务和无状态服务区别的关键所在</p></div><h4 id="有状态服务的强一致性"><a class="header-anchor" href="#有状态服务的强一致性">¶</a>有状态服务的强一致性</h4><p>有状态的服务通常会导致服务的强一致性。有状态的服务可以构建一种粘性的链接，也就是说客户端的请求总是会被路由到最初为之提供服务的服务器主机上。以此方式实现的服务，可以增加 AP 系统的一致性力度。这种强一致性模式包括<strong>线性随机访问内存</strong>和<strong>读你所写</strong>（Read your Write）。Werner Vogels 在他的文章中总结了<a target="_blank" rel="noopener" href="https://www.allthingsdistributed.com/2008/12/eventually_consistent.html">这些内容</a></p><p>无状态的服务很容易的通过给后端添加服务器和前端的负载均衡实现横向的扩展。此类应用拥有叫做「 数据运送范例 」的方式，就是数据被请求时是来自后端的数据存储为请求提供，在未来的请求中，若相同的数据被请求时，是不会去关心这些请求是从哪个服务实例来的，因为服务实例是无状态的.McCaffrey 谈到在<strong>通信频繁</strong>的应用中这种架构简直是一种浪费，因为这些应用要在服务端与客户端之间频繁的通信，而且在此类应用中有状态的服务显然是一种更好的选择</p><h4 id="有状态应用的粘性连接"><a class="header-anchor" href="#有状态应用的粘性连接">¶</a>有状态应用的粘性连接</h4><p>粘性连接可以使用持久性的连接来实现，但是会带来负载在后端分布不均的问题，这就会导致客户端捆绑到服务器，而有些服务器不能得到充分利用，最终导致部分服务器负载过多。其中一个减轻此种<a target="_blank" rel="noopener" href="http://mechanical-sympathy.blogspot.in/2012/05/apply-back-pressure-when-overloaded.html">后端压力</a>的方法就是一旦达到某个阀值就拒绝再来的请求（提前拒绝请求）。</p><p>非粘性的服务还可以通过路由的逻辑来实现，这可以使得任何的客户端通过获得正确的路由来找到任何的服务器。此实现会带来两个问题，路由到集群成员（谁在我的集群中？）和工作分布（谁来做？）。集群成员可以是静态的也可以是动态的。后者可以通过使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Gossip_protocol"> gossip 协议</a>和<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Consensus_(computer_science)">共识</a>系统来实现。工作分布则有更多的实现机制－随机替代、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Consistent_hashing">一致性哈希</a>、以及分布式哈希表</p><p>McCaffrey 在他的演讲中列出了一些构建有状态服务的陷阱，其中包括<strong>没有绑定的数据结构导致的内存问题</strong>、类似<strong>长期的垃圾回收暂停</strong>和<strong>重载状态时出现的内存管理问题</strong>等。状态重载会在恢复和部署新代码时发生，这两者都会像第一次从数据库中获取数据那样付出高昂的代价。</p><h4 id="图解有状态服务"><a class="header-anchor" href="#图解有状态服务">¶</a>图解有状态服务</h4><p>程序做的事情本质上就是<strong>数据的移动和组合</strong>，以此来达到我们所期望的结果。其中如何移动、如何组合是由「 算法 」来定的。任何一个「 结果 」都是通过一系列的「 行动 」将最开始的「 原料 」进行加工、转化得来。</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/state1.png" alt=""></p><p>比如，你将常温的水，通过<strong>倒入水壶</strong>、<strong>通电加热</strong>等工作后将常温的水变成了 100 度的水，这是常见的烧水过程。这个过程需要好几道行动才能得到结果。</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/state2.png" alt=""></p><p>这个时候如果想降低这几道行动的成本，天然的想法就是提炼出反复要做的事情，将各个独立的行动并行化。在程序中的实现就是将一部分数据放到一个「暂存区」中以提供给相关的行动共用</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/state3.png" alt=""></p><p>但是如此一来，就导致了需要增加一道关系，以表示每一个行动与哪一个「暂存区」<strong>关联</strong>。一旦拥有了关联关系，此时行动就变成了「有状态」</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/state4.png" alt=""></p><p>共用同一个「暂存区」的多个行动所处的环境经常被称作「上下文」。「暂存区」里存的是「数据」，所以可以理解为有数据就等价于有状态。「数据」在程序中的作用范围分为「局部」和「全局」（对应局部变量和全局变量），因此「状态」其实也可以分为两种，一种是局部的「会话状态」，一种是全局的「资源状态」</p><p>因为有些服务端不单单负责运算，还会提供其自身范围内的「数据」出去，这些「数据」属于服务端完整的一部分，被称作「资源」。所以，理论上「资源」可以被每个「会话」来使用，因此是全局的状态</p><p>与「有状态」相反的是「无状态」，「无状态」意味着每次加工所需的原料全部由外界提供，服务端内部不做任何的「暂存区」。并且请求可以提交到服务端的任意副本节点上，处理结果都是完全一样的</p><p>有一类方法天生是「无状态」，就是负责表达移动和组合的「 算法 」。因为它的本质就是：接收「 原料 」「 加工 」并返回「 成果 」</p><p>如果想获得更好的伸缩性以及容错性，<span class="highlight-text red">就需要尽量将「有状态」的处理机制改造成「无状态」的处理机制</span></p><h4 id="有状态服务的无状态化处理"><a class="header-anchor" href="#有状态服务的无状态化处理">¶</a>有状态服务的无状态化处理</h4><p>⛵ 「有状态」的处理过程是可以改造成「无状态」的处理过程对，具体的改造步骤如下：</p><div class="alert success no-icon"><ol><li>状态信息前置，丰富入参，将处理需要的数据尽可能都通过上游的客户端放到入参中传过来</li></ol></div><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/state5.png" alt=""></p><p>这种方案的弊端会让<strong>网络数据包的体积更大一些</strong></p><div class="alert success no-icon"><ol start="2"><li>客户端与服务端的交互中如果涉及到多次交互，则需要来回传递后续服务端处理中所需的数据，以避免需要在服务端暂存。例子如下图，图中橙色表示请求，绿色表示响应</li></ol></div><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/state6.png" alt=""></p><p>通过上述两步改造的目的都是为了尽量少出现类似下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而是多出现这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(i)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要更好的做好「无状态」化的工作，基本依赖于在架构设计或者项目设计中的合理分层。尽量将会话状态相关的处理上浮到最前面的层，因为只有最前面的层才与系统使用者接触，如此一来，其它的下层就可以将「无状态」作为一个普遍性的标准去做。与此同时，由于会话状态集中在最前面的层，所以哪怕真的状态丢失了，重建状态的成本相对也小很多。比如三层架构的话，保证 BLL(业务逻辑层) 和 DAL（数据访问层） 都不要有状态，代码的可维护性大大提高</p><p>在这里，提到做分层的目的是为了说明，只有将 IO 密集型程序和 CPU 密集型程序分离，才是通往「无状态」真正的出路。一旦分离后，CPU 密集型的程序自然就是「无状态」了.如此也能更好的做「弹性扩容」。因为常见的需要「弹性扩容」的场景一般指的就是 CPU 负荷过大的时候</p><div class="alert success no-icon"><ol start="3"><li>如果前面的都不合适，可以将共享存储作为降级预案来运用，如远程缓存、数据库等。然后当状态丢失的时候可以从这些共享存储中恢复</li></ol></div><p>所以，最理想的状态存放点，要么在最前端，要么在最底层的存储层</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/state7.png" alt=""></p><div class="alert info no-icon"><p>任何事物都是有两面性的，正如前面提到的，我们并不是要所有的业务处理都改造成「无状态」，而只是挑其中的一部分。最终还是看价值，看性价比。例如，将一个以状态为核心的即时聊天工具的所有处理过程都改造成「无状态」的，就有点得不偿失了</p></div><h4 id="运行有状态工作负载的挑战"><a class="header-anchor" href="#运行有状态工作负载的挑战">¶</a>运行有状态工作负载的挑战</h4><p>运行有状态工作负载有多种挑战：</p><div class="alert success no-icon"><ul><li>资源隔离：目前市场上的许多容器编排解决方案仍然只涉及一种尽力而为的资源分配方法，例如 CPU、内存和存储。这可能适用于无状态微服务，但对于有状态微服务来说，这可能是一种灾难性的方法，客户交易或数据由于性能不可靠而丢失</li><li>持久存储：每个有状态数据服务可能需要或支持不同类型的存储类型（例如块设备或分布式文件系统），并且确定有状态服务的后备存储类型可能具有挑战性</li></ul></div><h3 id="无状态服务"><a class="header-anchor" href="#无状态服务">¶</a>无状态服务</h3><div class="alert success no-icon"><p>无状态服务对于客户端的单次请求的处理，不依赖于其他请求，处理一次请求的信息都包含在该请求里。最典型的就是通过 cookie 保存 token 的方式传输请求数据。最终，客户端每次请求都携带自描述信息，服务端通过这些信息识别客户端身份，在服务端本地并不保存任何客户端请求者信息。就算有多个服务端，它们对同一个请求响应的结果也是完全一致的。</p></div><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/image-20211102194130571.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/image-20211102194130571.png" alt=""></a></div><p>✨无状态服务特点</p><div class="alert info no-icon"><ul><li>客户端请求不依赖服务端的信息，任何多次请求不需要必须访问到同一台服务</li><li>服务端的集群和状态对客户端透明</li><li>服务端可以任意的迁移和伸缩</li><li>减小服务端存储压力</li></ul></div><p>无状态服务的实例可能会因为一些原因停止或者重新创建（如扩容时）。这时，这些停止的实例里的所有信息（除日志和监控数据外）都将丢失(重启容器即会丢失)。因此如果您的容器实例里需要保留重要的信息，并希望随时可以备份以便于以后可以恢复的话，那么建议您创建有状态服务。</p><p>❓ 为什么网上主流的观点都在说要将方法多做成「无状态」的呢？</p><div class="alert success no-icon"><ul><li><p>一方面，因为我们更习惯于编写「有状态」的代码，但是「有状态」不利于系统的易伸缩性和可维护性。在分布式系统中，「有状态」意味着一个用户的请求必须被提交到保存有其相关状态信息的服务器上，否则这些请求可能无法被其他机器理解，导致服务器端无法对用户请求进行自由调度，如此对分布式集群的水平扩展非常不友好。</p></li><li><p>另一方面，有状态服务也导致了容错性不好，倘若保有用户信息的服务器宕机，那么该用户最近的所有交互操作将无法被透明地移送至备用服务器上，除非该服务器时刻与主服务器同步全部用户的状态信息。</p></li></ul></div><h4 id="无状态服务是如何工作的"><a class="header-anchor" href="#无状态服务是如何工作的">¶</a>无状态服务是如何工作的</h4><p>无状态架构意味着应用程序依赖于第三方存储，因为它不会在内存或磁盘上存储任何类型的状态。它请求的所有数据都必须从其他有状态服务（数据库）中获取或数据本身就存在于 CRUD 请求中</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/xenonstack-how-stateless-applications-works.png" alt=""></p><p>对于无状态应用，任何一个请求首先会发送到负载均衡器上，随后负载均衡器将请求负载到无状态服务的任何一个副本上，因为服务中的所有数据都存储在其他地方（通常是具有持久存储的数据库）所以不同副本上对于请求执行相同逻辑。由于状态信息与每个请求一起发送到服务器，服务器通过该服务器继续为请求提供服务。Load-balancer 不需要担心将请求路由到同一台服务器，真正实现了负载均衡。 其中 JSON Web Token (JWT) 广泛用于创建无状态应用程序</p><p>然而对于有状态应用是不同的，当有状态应用程序中的并发用户数量增加时，添加更多运行相同程序的服务器（横向扩展），并使用负载平衡器在这些服务器之间均匀分配负载。但是由于每个服务器「 记住 」每个登录用户的状态，因此有必要将负载均衡器配置为「粘性模式 」。粘性模式下，负载均衡器将每个用户的请求发送到响应该用户先前请求的同一台服务器。这违背了负载均衡的目的，此时就算对系统进行了水平扩展，也会由于粘性负载的关系，整个系统的负载并不均衡。</p><p>✨ 以下是无状态应用程序的 5 个主要优点：</p><div class="alert info no-icon"><ul><li>消除创建/使用会话的开销（减少服务端的内存使用、消除会话国旗问题）</li><li>横向扩展以满足现代用户的需求</li><li>按需添加/删除应用程序的新实例</li><li>它允许跨各种应用程序的一致性</li><li>无状态使应用程序更易于使用和可维护</li></ul></div><h4 id="无状态应用程序的最佳实践"><a class="header-anchor" href="#无状态应用程序的最佳实践">¶</a>无状态应用程序的最佳实践</h4><p>无状态应用不惜一切代价避免 session，主要是以下几点原因：</p><div class="alert success no-icon"><ul><li>session 为系统增加了不必要的复杂性，但为系统带来的价值却非常少。session 重现错误十分困难，由于所有内容都存储在服务器端，因此很难修复与会话相关的错误。</li><li>会话无法扩展。如果应用程序的负载呈指数增长，应当将请求负载到不同的服务器。如果使用会话，需要将所有会话复制到所有服务器。该系统变得非常复杂且容易出错。</li></ul></div><p>如此也并不是说会话就是一个很糟糕的技术，会话仅对特定用例有用，例如 FTP（文件传输协议）。对于共享 Dropbox 等用例，有状态会话会增加额外的开销，而无状态则是完美的方式。会话功能使用 cookie 复制，在客户端缓存</p><h4 id="为什么无状态服务很重要"><a class="header-anchor" href="#为什么无状态服务很重要">¶</a>为什么无状态服务很重要</h4><p>如今倡导无状态简而言之就是为了让系统得到一种特性：伸缩性（scaliability）</p><p>❓ 以前有状态应用程序运行良好，为什么还需要无状态应用程序？</p><div class="alert success no-icon"><p>有状态的应用程序适合规模较小的应用程序，应对于复杂的系统有状态架构存在一些问题。首先，当用户在服务器上引用一个状态时，用户打开了很多不完整的会话和交易发生，在 Stateful 系统中，客户端计算出的状态，系统应该让连接保持多久？如何在服务器端验证客户端是否崩溃或与会话断开连接？在维护文档更改和回滚的同时如何跟踪用户的操作？这些都是有状态应用程序带来的难题。因此，想要回避这些难题，最好使用无状态服务。</p></div><p>Facebook 不断使用无状态服务。当服务器使用 Facebook API 请求最近消息的列表时，它会发出一个带有令牌和日期的 GET 请求。响应独立于任何服务器状态，一切都以缓存的形式存储在客户端的机器上。类似地，调用 POST 命令，在不考虑服务器状态的情况下，在标头中传递带有授权/身份验证数据的复杂主体与上一个、当前和下一个请求没有关系。在无状态中，客户端不会等待来自服务器的同步。</p><div class="alert info no-icon"><p>REST 是设计、架构和开发现代 API 的主流方式，值得注意的是：REST 就是一种典型的无状态架构。</p></div><h4 id="如何采用无状态应用程序"><a class="header-anchor" href="#如何采用无状态应用程序">¶</a>如何采用无状态应用程序</h4><p>⛵ 以下是采用无状态应用程序的 5 个步骤</p><div class="alert success no-icon"><ol><li>适应和开发新应用程序。采用无状态应用程序起初可能是一项艰巨的任务，因为它是一种新范式。但是，通过正确的思维方式，可以在不保持任何状态的情况下适应和开发新的应用程序。</li><li>使用微服务开发应用程序。在此步骤中，将出于部署目的进行容器化。容器最擅长运行无状态工作负载。当需要管理的多个容器增加时，可以考虑切换到 Kubernetes 等云编排和管理工具来运行大量容器</li><li>容器化微服务应用程序。从资源点找到运行安全的容器的最佳位置，并维护应用程序的高可用性</li><li>将存储附加到无状态临时文件。附加到无状态的存储是短暂的。组织必须从无状态容器开始，因为它们更容易适应这种类型的架构，并且与单体应用程序分离并独立扩展</li><li>应用 REST 哲学。后端应该使用 REST 设计模式来构建应用程序。REST 哲学不是维护状态，只是在客户端稍微维护 cookie 和本地存储</li></ol></div><h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3><p>🆚 无状态服务和有状态服务主要有以下区别</p><div class="alert success no-icon"><ul><li><p>实例数量：无状态服务可以有一个或多个实例，因此支持两种服务容量调节模式；有状态服务只能有一个实例，不允许创建多个实例，因此也不支持服务容量调节模式</p></li><li><p>存储卷：无状态服务可以有存储卷，也可以没有，即使有也无法备份存储卷里面的数据；有状态服务必须要有存储卷，并且在创建服务时，必须指定给该存储卷分配的磁盘空间大小</p></li><li><p>数据存储：无状态服务运行过程中的所有数据（除日志和监控数据）都存在容器实例里的文件系统中，如果实例停止或者删除，则这些数据都将丢失，无法找回；而对于有状态服务，凡是已经挂载了存储卷的目录下的文件内容都可以随时进行备份，备份的数据可以下载，也可以用于恢复新的服务。但对于没有挂载卷的目录下的数据，仍然是无法备份和保存的，如果实例停止或者删除，这些非挂载卷里的文件内容同样会丢失。</p></li></ul></div><p>无状态服务是指该服务的实例可以将一部分数据随时进行备份，并且在创建一个新的有状态服务时，可以通过备份恢复这些数据，以达到数据持久化的目的。有状态服务只能有一个实例，因此不支持「 自动服务容量调节 」。一般来说，数据库服务或者需要在本地文件系统存储配置文件或其它永久数据的应用程序可以创建使用有状态服务。要想创建有状态服务，必须满足几个前提：</p><div class="alert success no-icon"><ul><li>待创建的服务镜像（image）的 Dockerfile 中必须定义了存储卷（Volume），因为只有存储卷所在目录里的数据可以被备份</li><li>创建服务时，必须指定给该存储卷分配的磁盘空间大小。</li><li>如果创建服务的同时需要从之前的一个备份里恢复数据，那么还要指明该存储卷用哪个备份恢复。</li></ul></div><p>有状态应用和流程是可以周而复始、反复发生的应用和流程，例如网上银行或电子邮件。这些操作是在先前的事务背景下执行的，当前事务可能会受到先前事务的影响。正因如此，有状态应用在每次处理用户的请求时<strong>都会使用相同的服务器</strong>。如果有状态事务被中断，其上下文和历史记录会被存储下来，这样就可以或多或少地从上次中断的地方继续。有状态应用会跟踪诸如窗口位置、设置首选项和近期活动等内容。我们可以把有状态事务视为与同一个人进行的定期对话。</p><p>有状态和无状态应用程序在互联网中无处不在，但是现代大部分软件是以无状态方式构建的，这是因为可伸缩性是如今大型系统非常重要的一个因素</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/xenonstack-stateful-vs-stateless.webp" alt=""></p><h2 id="无状态和有状态的容器管理"><a class="header-anchor" href="#无状态和有状态的容器管理">¶</a>无状态和有状态的容器管理</h2><p>有状态现在已成为容器存储的主体，因此现在的问题从要不要使用有状态容器，变成了该如何使用这些有状态容器？</p><div class="alert success no-icon"><p>最初，容器被构建为无状态，因为这比较符合其便携、灵活的特性。但随着容器的广泛使用，人们开始对现有的有状态应用进行容器化处理（重新设计和重新封装，以实现容器的便捷扩缩容）。究竟是使用有状态还是无状态容器，要取决于构建哪种类型的应用以及用途。如果只是临时需要信息（快速而短暂），无状态便是解决之道。但如果应用需要更多的内存来存储从一个会话到下一个会话的操作，则应用采用有状态方式</p></div><p>正因为这个原因，有状态应用越来越像无状态应用，无状态应用向有状态应用靠近的趋势，如：存在一个无状态的应用，它不需要长期存储，但允许服务器使用 Cookie 来跟踪同一客户端的请求。尽管无状态应用程序以不同的方式工作，但它们不会在服务器上存储任何状态。</p><p>它们使用 DB 来存储所有信息。DB 是有状态的，即它具有附加的持久存储。通常，用户请求使用凭据登录，LB 后面的任何服务器都会处理该请求，生成一个 auth 令牌，将其存储在 DB 中，然后将令牌返回给前端的客户端。下一个请求与令牌一起发送，现在，无论哪个服务器处理请求，它都会将令牌与数据库中的信息进行匹配，并授予用户登录权限。每个请求都是独立的，与前一个或下一个请求没有任何联系，就像 REST 一样。尽管无状态应用程序有一个额外的调用 DB 的开销，但这些应用程序在水平扩展方面非常出色，这对于可能拥有数百万用户的现代应用程序至关重要。</p><h2 id="无状态主从集群设计"><a class="header-anchor" href="#无状态主从集群设计">¶</a>无状态主从集群设计</h2><p>构建单机服务非常简单，但如果单机服务可靠性或性能不足，就需要多机器共同承担某项服务。集群化包含以下四种情况：</p><table><thead><tr><th style="text-align:center">集群格式</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">无状态主备集群</td><td style="text-align:center">仅有一台主机完成任务，且没有本地状态，其余从机机器待命，一旦主机宕机，从机选主成为主机</td></tr><tr><td style="text-align:center">有状态主备集群</td><td style="text-align:center">仅有一台主机完成任务，有本地状态，其余从机机器待命，一旦主机宕机，从机选主成为主机</td></tr><tr><td style="text-align:center">无状态的主从集群</td><td style="text-align:center">所有机器没有本地状态，理论上机器可以无限叠加，共同向外界提供同一服务。</td></tr><tr><td style="text-align:center">有状态的主从集群</td><td style="text-align:center">所有机器都有本地状态，共同向外界提供同一服务。一旦某台机器宕机，需要主机协调其他从机代理其本地状态的任务</td></tr></tbody></table><h2 id="结论"><a class="header-anchor" href="#结论">¶</a>结论</h2><p>有时您必须构建有状态的服务，这不会自动损害您进行 SaaS 开发的准备。但是，您需要确保对有状态服务进行某种扩展，并计划备份和快速灾难恢复。虽然这几乎总是可能的，但工作量可能比在无状态微服务上获得更好结果所需的工作要多得多。</p><h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2><p><a target="_blank" rel="noopener" href="https://www.redhat.com/zh/topics/cloud-native-apps/stateful-vs-stateless">RedHat</a><br><a target="_blank" rel="noopener" href="https://www.xenonstack.com/insights/stateful-and-stateless-applications">Stateful and Stateless Applications Best Practices and Advantages</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/universsky2015/article/details/105677992">分布式系统中的“无状态”和“有状态”详解</a><br><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/2015/12/scaling-stateful-services/">构建可伸缩的有状态服务</a><br><a target="_blank" rel="noopener" href="http://liaojiacan.me/2019/05/27/%E3%80%90%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E3%80%91%E7%90%86%E8%A7%A3%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1/index.html">【高可用架构】理解有状态服务和无状态服务</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Service_statelessness_principle">Service statelessness principle</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010472499/article/details/53888480">无状态服务 VS 有状态服务</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/PRAM_consistency">PRAM consistency</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Service_statelessness_principle">Service statelessness principle</a><br><a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_7d1968e20102xaej.html">分布式基础 5-无状态主从集群设计</a></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E4%BC%A0%E8%BE%93%E5%B1%82%E6%8A%80%E6%9C%AF/" data-tooltip="传输层技术" aria-label="上一篇: 传输层技术"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/mysql-%E4%B8%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/" data-tooltip="MySQL(七) 数据库索引" aria-label="下一篇: MySQL(七) 数据库索引"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E4%BC%A0%E8%BE%93%E5%B1%82%E6%8A%80%E6%9C%AF/" data-tooltip="传输层技术" aria-label="上一篇: 传输层技术"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/mysql-%E4%B8%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/" data-tooltip="MySQL(七) 数据库索引" aria-label="下一篇: MySQL(七) 数据库索引"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>