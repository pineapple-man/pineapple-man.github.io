<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>MySQL(六) 数据库事务 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="数据库事务"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n开发人员和数据库打交道时，总是会用到事务，其中最经典的例子就是转账。转账逻辑具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，如果单独看待转账这个需求，需要保证的是转账前后，用户的余额必须保证是一致的即可；另一方面，事务同样也是 MySQL 等关系型数据库区别于 NoSQL 的重要方面，是保证数据一致性的重要手段。本文主要了解 MySQL 中事务的实现原理以及相关的事务并发控制协议理论。\n¶概述\n❓为什么需要事务？\n\n事务（Transaction）是数据库区别于文件系统的重要特性之一，在文件系统中，如果你正在写文件，但是操作系统突然崩溃、宕机了，这个文件就很有可能被破坏。虽然有一些机制可以把文件恢复到某个时间点，但是如果需要保证两个文件同步，这个文件系统可能就显得无能为力了\n数据库引入事务的主要目的：事务会把数据库从一种一致状态转换为另一种一致状态。再数据库提交工作时，可以确保其要么所有修改都已经保存了，要么所有修改都不保存\n\n\n简而言之，通过事务能够保证数据库中的一组操作，要么全部成功，要么全部失败，在 MySQL 中，事务支持是在引擎层实现的。由于 MySQL 的引擎是可插拔式的，所以并不是所有的引擎都支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 会被 InnoDB 取代的原因之一。\n🤔 一个数据库有了 ACID 能怎么样？\n如果一个数据库系统具备了 ACID 特性，能够使得应用程序开发人员能够将注意力集中在单个事务上,而不必考虑并发和容错等问题。所以，拥有了事务的数据库，说到底还是为了方便业务开发人员进行业务开发。\n\n📓 按照严格的标准，只有同时满足 ACID 特性才是事务；但是在各大数据库厂商的实现中，真正满足 ACID 的事务少之又少，例如：\n\nMySQL 的 NDB Cluster 事务不满足持久性和隔离性\nInnoDB 默认事务隔离级别是可重复读，不满足隔离性\nOracle 默认的事务隔离级别为 READ COMMITTED，不满足隔离性\n\n\n👴 因此与其说 ACID 是事务必须满足的条件，不如说它们是衡量事务的四个维度\n¶事务的 ACID 特性\n如果一个数据库声称支持事务，那么该数据库必须要具备 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）四个特性，各个特性具体含义将在下面进行阐述。\n\n¶原子性(Atomicity)\n原子性是指事务包含的所有操作要么全部成功执行，要么全部执行失败并回滚。其中事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。具体而言，原子性是指一个事务是一个不可分割的工作单位。通过原子性能够保证，事务中的 sql 语句要么都做，要么都不做；如果事务中一个 sql 语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态\nMySQL 的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等。InnoDB 存储引擎提供了两种事务日志：redo log&amp;undo log，其中redo log用于保证事务持久性；undo log则是事务原子性和隔离性实现的基础\n实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的 sql 语句。InnoDB 能够实现回滚，靠的就是 undo log。当事务对数据库进行修改时，InnoDB 会生成对应的 undo log，如果事务执行失败或调用了 rollback，导致事务需要回滚，便可以利用 undo lo g 中的信息将数据回滚到修改之前的样子\n\nundo log属于逻辑日志，它记录的是 sql 执行相关的信息，当发生回滚时，InnoDB 会根据undo log的内容做与之相反的工作，执行语句大致如下：\n\n对于每个insert，回滚时会执行delete\n对于每个delete，回滚时会执行insert\n对于每个update，回滚时会执行一个相反的update，把数据改回去\n\n\n以 update 操作为例：当事务执行 update 时，其生成的 undo log 中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到 update 之前的状态\n\n¶一致性(Consistency)\n一致性是指任何一个数据库事务的执行，应该让数据库保持在一致状态，并不会改变数据库原本的一致性约束\n对于转账例子而言，假设用户 A 和用户 B 两者的钱加起来一共是 1000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 1000，这就是事务的一致性。\n\n\nACID 中的「一致性」，是对于整个数据库的「一致」状态的维持。抽象来看，对数据库每进行一次事务操作，它的状态就发生一次变化。这相当于把数据库看成了状态机，只要数据库的起始状态是「一致」的，并且每次事务操作都能保持「一致性」，那么数据库就能始终保持在「一致」的状态上 (Consistency Preservation)。\n所谓状态是不是「一致」，其实是由业务层规定的。比如转账的例子，“转账前后账户总额保持不变”，这个规定只对于「转账」这个特定的业务场景有效。如果换一个业务场景，「一致」的概念就不是这样规定了。所以说，ACID 中的「一致性」，其实是体现了业务逻辑上的合理性，并不是由数据库本身的技术特性所决定的。\n\n\n一致性时事务追求的最终目标，ACID 中的原子性、持久性和个理性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。实现一致性的措施包括如下几点：\n\n保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证\n数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等\n应用层面进行保障，例如转账操作只扣转账者的余额，没有增加接受者的余额，无论数据库实现的多么完美，也没有办法达到一致的状态\n\n\n¶隔离性(Isolation)\n数据库能够提供给多个用户并发访问，当多个用户同时操作同一张表时，数据库就会为每一个用户开启的事务，避免其他事务的操作对自身事务的影响。通过事务的隔离特性，能够保证多个并发事务之间不会互相影响。隔离性在数据库系统中是由隔离级别来表现的，这也是本文接下来详细介绍的重点。\n通过事务的隔离特性，就是想要做到这样一种结果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。\n\n既然隔离性追求的是并发情形下事务之间互不干扰，简单考虑的话，事务的隔离性主要可以分为两个方面：\n\n(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性\n(一个事务)写操作对(另一个事务)读操作的影响：MVCC 保证隔离性\n\n\n¶持久性(Durability)\n持久性是指一旦一个事务提交后，事务所做的修改将会永久的保存在数据库上，即使数据库系统出现宕机等其他故障，已经完成的事务操作也不会丢失。\n例如：我们在使用 JDBC 操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。\n\n其实，持久性是一个有点模糊的概念，因为实际上持久性也分很多不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。并且不可能有能做到 100% 的持久性保证的策略，故障恢复的错误率难免会发生。\nInnoDB 作为 MySQL 的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘 IO，效率会很低。为此，InnoDB 提供了缓存(Buffer Pool)，Buffer Pool 中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从 Buffer Pool 中读取，如果 Buffer Pool 中没有，则从磁盘读取后放入 Buffer Pool；当向数据库写入数据时，会首先写入 Buffer Pool，Buffer Pool 中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。\nBuffer Pool 的使用大大提高了读写数据的效率，但是也带了新的问题：如果 MySQL 宕机，而此时 Buffer Pool 中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。\n于是，redo log 被引入来解决这个问题：当数据修改时，除了修改 Buffer Pool 中的数据，还会在 redo log 记录这次操作；当事务提交时，会调用 fsync 接口对 redo log 进行刷盘。如果 MySQL 宕机，重启时可以读取 redo log 中的数据，对数据库进行恢复。redo log 采用的是 WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到 Buffer Pool，保证了数据不会因 MySQL 宕机而丢失，从而满足了持久性要求。\n既然 redo log 也需要在事务提交时将日志写入磁盘，为什么它比直接将 Buffer Pool 中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：\n\n刷脏是随机 IO，因为每次修改的数据位置随机，但写 redo log 是追加操作，属于顺序 IO。\n刷脏是以数据页（Page）为单位的，MySQL 默认页大小是 16KB，一个 Page 上一个小修改都要整页写入；而 redo log 中只包含真正需要写入的部分，无效 IO 大大减少。\n\n\n¶隔离性与隔离级别\n当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了「 隔离级别 」的概念。并且随着隔离级别不断的提升，一条简单的 SQL 语句的执行效率会逐渐下降，因此很多时候，开发人员都是在隔离级别和执行效率之间寻找一个平衡点。\n\n\n\n隔离问题\n含义\n\n\n\n\n脏读\n一个事务读取到了另外一个事务未提交的数据\n\n\n不可重复读\n同一个事务中，多次读取到的数据不一致\n\n\n幻读\n一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据\n\n\n\n❓ 既然幻读和不可重复读都是前后两次读取到的内容不一致，那么这两者到底有什么不同尼？\n幻读和不可重复读都是读取了另一条已经提交的事务,不同的是：不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体。\n\n不可重复读的重点是修改，同一个事务，两次读取到的数据不一样。\n幻读的重点在于新增或删除，同样的条件下，第一次和第二次读出来的记录数是不一样的\n\n\nSQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ），具体的含义如下表\n\n\n\n隔离级别\n含义\n\n\n\n\n读未提交（read uncommitted）\n一个事务还没提交时，它做的变更就能被别的事务看到\n\n\n读提交（read committed）\n一个事务提交之后，它做的变更才会被其他事务看到\n\n\n可重复读（repeatable read）\n一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的\n\n\n串行化（serializable ）\n对于同一行记录，「 写 」会加「 写锁 」，「 读 」会加「 读锁 」。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行\n\n\n\n其中「 读提交 」和「 可重复读 」比较难理解，这里用一个例子说明这几种隔离级别。\n假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行两个事务的行为\n12mysql&gt; create table T(c int) engine=InnoDB;insert into T(c) values(1);\n\n现在就可以查看在不同的隔离级别下，事务 A 会有哪些不同的返回结果，也就是图里面 V1、V2 与 V3 的返回值分别是什么。\n\n若隔离级别是「 读未提交 」， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。\n若隔离级别是「 读提交 」，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。\n若隔离级别是「 可重复读 」，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。\n若隔离级别是「 串行化 」，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。\n\n\n在实现事务的隔离级别时，数据库中会创建一个视图，访问的时候以示图的逻辑结果为准。\n\n在 「 可重复读 」隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图；\n在 「 读提交 」隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的；\n在 「 读未提交 」隔离级别下直接返回记录上的最新值，没有视图概念；\n在 「串行化 」隔离级别下直接用加锁的方式来避免并行访问\n\n所以，在不同隔离界别下，数据库的行为是不同的。Oracle 数据库的默认隔离级别是 「 读提交 」，因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，一定要记得将 MySQL 的隔离级别设置为「 读提交 」\n修改 MySQL 隔离级别配置的方式是，将启动参数transaction-isolation的值设置成READ-COMMITTED，首先可以通过show variables来查看当前的值\n1234567891011mysql&gt; show variables like &#x27;transaction_isolation&#x27;;+-----------------------+----------------+| Variable_name | Value |+-----------------------+----------------+| transaction_isolation | READ-COMMITTED |+-----------------------+----------------+\n\n📓 这四种隔离级别都有着各自存在的道理，并没有那种隔离级别一定比另一种隔离级别要好的情况，都是根据自己的业务情况来确定事务的隔离级别。\n❓ 什么时候需要可重复读的场景？\n假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。这时候使用「 可重复读 」隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。\n\n¶事务隔离的实现\n🎯 本小节将详细展示在可重复读隔离级别下，事务隔离具体是如何实现？\n在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。\n假设一个值从 1 按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。\n\n当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到\n同时，即使现在有另一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。\n\n❓ 有了回滚日志可以方便事务执行撤销操作，但是这些回滚日志要保留到什么时候？什么时候应该删除这些回滚日志？\n当然是在系统不需要的时候删除这些回滚日志，数据库系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志就会被删除。简单的一点就是：当系统里没有比这个回滚日志更早的 read-view 的时候，就可以考虑删除此回滚日志\n\n基于以上的原因，也可以解释，为什么在开发中不建议使用长事务。长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库\n¶数据库事务的启动方式\n开发过程中当然应该避免使用长事务，其实很多时候业务开发人员并不是有意使用长事务，通常都是由于误用所致。总结来说，MySQL 的事务启动方式有以下几种：\n\n显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback\nset autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接\n\n\n有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。因此，总好使用 set autocommit=1, 通过显式语句的方式来启动事务。\n\n❓ 如何避免长事务对业务的影响？\n可以从应用开发端和数据库端进行解决。首先对于应用开发端而言，想要避免长事务有以下方法：\n\n确认是否使用了set autocommit = 0，这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1\n确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉\n业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间\n\n其次，对于数据库端而言，有以下几种方式避免长事务：\n\n监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警/或者 kill；\n使用 Percona 的 pt-kill 工具；\n在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题\n如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便\n\n\n¶事务模型\n\n\n\n\n状态\n含义\n\n\n\n\n活动的\n初始状态,事务执行时处于这个状态\n\n\n部分提交的\n最后一条语句执行后\n\n\n失败的\n发现正常的执行不能继续进行,必须进行回滚\n\n\n中止的\n事务回滚并且数据库已恢复到事务开始执行前到状态后\n\n\n提交的\n成功完成\n\n\n\n撤销已提交事务所造成的影响的唯一方法是执行一个补偿事务，这也是回滚能够成功的原因。\n¶数据库的事务\n之前都是一些理论知识中对于事务的描述，解析来主要关注于 MySQL 中如何使用事务控制语言（TCL，Transaction Control Language）进行 MySQL 中的事务操作。\n¶MySQL 中的事务\nMySQL 中的事务主要分为两种:隐式事务及显示事务，其中隐式事务没有明显的开始和结束的标记(INSERT,UPDATE,DELETE 语句本身就是一个事务)；显示事务具有明显的开启和结束的标记\n¶事务的创建\nMySQL 系统默认启用隐式事务:每执行一条 SQL 语句，都是一个单独的事务。如果需要在一个事务中包含多条 SQL 语句，那么需要先关闭隐式事务.\n\n将自动提交功能为禁用\n\n123show variables LIKe &#x27;autocommit&#x27;;\t#查看当前数据库是否为隐式事务set autocommit=0;\t#将事务设置为显示事务SHOW VARIABLES LIKE &#x27;autocommit&#x27;;\t#再次查看当前事务类型\n\n使用显示事务进行操作\n\n开启事务：start transaction；\n结束事务：commit或rollback。\n在执行 SQL 语句之前，先执行strat transaction，这就开启了一个事务（事务的起点），然后可以去执行多条 SQL 语句，最后要结束事务，commit 表示提交，即事务中的多条 SQL 语句所做出的影响会持久化到数据库中。或者 rollback，表示回滚，即回滚到事务的起点，之前做的所有操作都被撤消了！也可以打断点，此时事务回滚不再是回滚到起点，而是回滚到断点处\n12345678#创建事务要用到的表CREATE TABLE account(\tid INT PRIMARY KEY AUTO_INCREMENT,\tNAME VARCHAR(30),    balance NUMERIC(10.2));INSERT INTO account(NAME,balance) VALUES(&#x27;fanbingbing&#x27;, 100000);INSERT INTO account(NAME,balance) VALUES(&#x27;lichen&#x27;, 100000);\n演示事务执行失败\n案例一：回滚 事务执行失败！\n1234START TRANSACTION;UPDATE account SET balance=balance-10000 WHERE id=1;UPDATE account SET balance=balance+10000 WHERE id=2;ROLLBACK;\n案例二：退出 mysql 客户端 事务执行失败！\n123START TRANSACTION;UPDATE account SET balance=balance-10000 WHERE id=1;UPDATE account SET balance=balance+10000 WHERE id=2;\n演示事务执行成功\n1234START TRANSACTION;UPDATE account SET balance=balance-10000 WHERE id=1;UPDATE account SET balance=balance+10000 WHERE id=2;COMMIT;\n\n¶数据库的隔离级别\n通过设置事务的隔离级别可以解决脏读、不可重复读或幻读等问题。\n\nREAD UNCOMMITTED\nREAD COMMITTED可以避免脏读\nREPEATABLE READ可以避免脏读、不可重复读和一部分幻读\nSERIALIZABLE可以避免脏读、不可重复读和幻读常见的事务隔离界别操作，\n\n设置隔离级别：\n\n1set session|global  transaction isolation level 隔离级别名;\n\n查看隔离级别：\n\n1select @@tx_isolation;\n\n\n\n¶附录\n事务的四大特性以及隔离级别\n深入理解 MySQL 事务\n事务的并发控制协议理论&amp;MySQL 源码分析\n","dateCreated":"2022-02-22T05:09:18+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2022-02-22T05:09:18+00:00","description":"本文主要讲述 MySQL 中的事务相关概念","headline":"MySQL(六) 数据库事务","image":["https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/mysql-%E5%85%AD-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/mysql-%E5%85%AD-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/","keywords":"MySQL","thumbnailUrl":"https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql.jpg"}</script><meta name="description" content="本文主要讲述 MySQL 中的事务相关概念"><meta property="og:type" content="blog"><meta property="og:title" content="MySQL(六) 数据库事务"><meta property="og:url" content="https://pineapple-man.github.io/mysql-%E5%85%AD-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="本文主要讲述 MySQL 中的事务相关概念"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql-%E4%BA%8B%E5%8A%A1.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%A1%88%E4%BE%8B.webp"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97.webp"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql-%E6%B4%BB%E5%8A%A8%E7%8A%B6%E6%80%81%20(active).png"><meta property="article:published_time" content="2022-02-22T05:09:18.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.007Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="MySQL"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql-%E4%BA%8B%E5%8A%A1.png"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql.jpg"><meta class="swiftype" name="image" data-type="enum" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql.jpg"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-left"><h1 class="post-title">MySQL(六) 数据库事务</h1><div class="post-meta"><time datetime="2022-02-22T05:09:18+00:00">2月 22, 2022 </time><span>发布在 </span><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 6.6k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 62 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84-ACID-%E7%89%B9%E6%80%A7"><span class="toc-text">事务的 ACID 特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7-Atomicity"><span class="toc-text">原子性(Atomicity)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7-Consistency"><span class="toc-text">一致性(Consistency)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7-Isolation"><span class="toc-text">隔离性(Isolation)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7-Durability"><span class="toc-text">持久性(Durability)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">隔离性与隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">事务隔离的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">数据库事务的启动方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="toc-text">事务模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1"><span class="toc-text">数据库的事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1"><span class="toc-text">MySQL 中的事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">事务的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">数据库的隔离级别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol><p>开发人员和数据库打交道时，总是会用到事务，其中最经典的例子就是转账。转账逻辑具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，如果单独看待转账这个需求，需要保证的是转账前后，用户的余额必须保证是一致的即可；另一方面，事务同样也是 MySQL 等关系型数据库区别于 NoSQL 的重要方面，是保证数据一致性的重要手段。本文主要了解 MySQL 中事务的实现原理以及相关的事务并发控制协议理论。</p><h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><p>❓为什么需要事务？</p><div class="alert success no-icon"><ul><li>事务（Transaction）是数据库区别于文件系统的重要特性之一，在文件系统中，如果你正在写文件，但是操作系统突然崩溃、宕机了，这个文件就很有可能被破坏。虽然有一些机制可以把文件恢复到某个时间点，但是如果需要保证两个文件同步，这个文件系统可能就显得无能为力了</li><li>数据库引入事务的主要目的：事务会把数据库从一种一致状态转换为另一种一致状态。再数据库提交工作时，可以确保其要么所有修改都已经保存了，要么所有修改都不保存</li></ul></div><p>简而言之，通过事务能够保证数据库中的一组操作，要么全部成功，要么全部失败，在 MySQL 中，事务支持是在引擎层实现的。由于 MySQL 的引擎是可插拔式的，所以并不是所有的引擎都支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 会被 InnoDB 取代的原因之一。</p><p>🤔 一个数据库有了 ACID 能怎么样？</p><div class="alert success no-icon"><p>如果一个数据库系统具备了 ACID 特性，能够使得应用程序开发人员能够将注意力集中在单个事务上,而不必考虑<strong>并发</strong>和<strong>容错</strong>等问题。所以，拥有了事务的数据库，说到底还是为了方便业务开发人员进行业务开发。</p></div><p>📓 按照严格的标准，只有同时满足 ACID 特性才是事务；但是在各大数据库厂商的实现中，真正满足 ACID 的事务少之又少，例如：</p><div class="alert warning no-icon"><ul><li>MySQL 的 NDB Cluster 事务不满足持久性和隔离性</li><li>InnoDB 默认事务隔离级别是可重复读，不满足隔离性</li><li>Oracle 默认的事务隔离级别为 READ COMMITTED，不满足隔离性</li></ul></div><p>👴 因此与其说 ACID 是事务必须满足的条件，不如说它们是衡量事务的四个维度</p><h2 id="事务的-ACID-特性"><a class="header-anchor" href="#事务的-ACID-特性">¶</a>事务的 ACID 特性</h2><p>如果一个数据库声称支持事务，那么该数据库必须要具备 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）四个特性，各个特性具体含义将在下面进行阐述。</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql-%E4%BA%8B%E5%8A%A1.png" alt=""></p><h3 id="原子性-Atomicity"><a class="header-anchor" href="#原子性-Atomicity">¶</a>原子性(Atomicity)</h3><p>原子性是指<font style="color:red;font-weight:700">事务包含的所有操作要么全部成功执行，要么全部执行失败并回滚</font>。其中事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。具体而言，原子性是指一个事务是一个不可分割的工作单位。通过原子性能够保证，事务中的 sql 语句要么都做，要么都不做；如果事务中一个 sql 语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态</p><p>MySQL 的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等。InnoDB 存储引擎提供了两种事务日志：<code>redo log</code>&amp;<code>undo log</code>，其中<code>redo log</code>用于保证事务持久性；<code>undo log</code>则是事务原子性和隔离性实现的基础</p><div class="alert info no-icon"><p>实现原子性的关键，是<strong>当事务回滚时能够撤销所有已经成功执行的 sql 语句</strong>。InnoDB 能够实现回滚，靠的就是 undo log。当事务对数据库进行修改时，InnoDB 会生成对应的 undo log，<strong>如果事务执行失败或调用了 rollback，导致事务需要回滚，便可以利用 undo lo g 中的信息将数据回滚到修改之前的样子</strong></p></div><p><code>undo log</code>属于逻辑日志，它记录的是 sql 执行相关的信息，当发生回滚时，InnoDB 会根据<code>undo log</code>的内容做与之相反的工作，执行语句大致如下：</p><div class="alert info no-icon"><ul><li>对于每个<code>insert</code>，回滚时会执行<code>delete</code></li><li>对于每个<code>delete</code>，回滚时会执行<code>insert</code></li><li>对于每个<code>update</code>，回滚时会执行一个相反的<code>update</code>，把数据改回去</li></ul></div><div class="alert warning no-icon"><p>以 update 操作为例：当事务执行 update 时，其生成的 undo log 中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到 update 之前的状态</p></div><h3 id="一致性-Consistency"><a class="header-anchor" href="#一致性-Consistency">¶</a>一致性(Consistency)</h3><p>一致性是指任何一个数据库事务的执行，应该让数据库保持在<strong>一致</strong>状态，并不会改变数据库原本的一致性约束</p><div class="alert warning no-icon"><p>对于转账例子而言，假设用户 A 和用户 B 两者的钱加起来一共是 1000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 1000，这就是事务的一致性。</p></div><div class="alert success no-icon"><ul><li>ACID 中的「一致性」，是对于整个数据库的「一致」状态的维持。抽象来看，对数据库每进行一次事务操作，它的状态就发生一次变化。这相当于把数据库看成了状态机，只要数据库的起始状态是「一致」的，并且每次事务操作都能保持「一致性」，那么数据库就能始终保持在「一致」的状态上 (Consistency Preservation)。</li><li>所谓状态是不是「一致」，其实是由业务层规定的。比如转账的例子，“转账前后账户总额保持不变”，这个规定只对于「转账」这个特定的业务场景有效。如果换一个业务场景，「一致」的概念就不是这样规定了。所以说，ACID 中的「一致性」，其实是体现了业务逻辑上的合理性，并不是由数据库本身的技术特性所决定的。</li></ul></div><p>一致性时事务追求的最终目标，ACID 中的原子性、持久性和个理性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。实现一致性的措施包括如下几点：</p><div class="alert info no-icon"><ul><li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证</li><li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等</li><li>应用层面进行保障，例如转账操作只扣转账者的余额，没有增加接受者的余额，无论数据库实现的多么完美，也没有办法达到一致的状态</li></ul></div><h3 id="隔离性-Isolation"><a class="header-anchor" href="#隔离性-Isolation">¶</a>隔离性(Isolation)</h3><p>数据库能够提供给多个用户并发访问，当多个用户同时操作同一张表时，数据库就会为每一个用户开启的事务，避免其他事务的操作对自身事务的影响。通过事务的隔离特性，能够保证多个并发事务之间不会互相影响。<font style="color:red;font-weight:700">隔离性在数据库系统中是由隔离级别来表现的</font>，这也是本文接下来详细介绍的重点。</p><div class="alert warning no-icon"><p>通过事务的隔离特性，就是想要做到这样一种结果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p></div><p>既然隔离性追求的是并发情形下事务之间互不干扰，简单考虑的话，事务的隔离性主要可以分为两个方面：</p><div class="alert success no-icon"><ol><li>(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性</li><li>(一个事务)写操作对(另一个事务)读操作的影响：MVCC 保证隔离性</li></ol></div><h3 id="持久性-Durability"><a class="header-anchor" href="#持久性-Durability">¶</a>持久性(Durability)</h3><p>持久性是指一旦一个事务提交后，事务所做的修改将会永久的保存在数据库上，即使数据库系统出现宕机等其他故障，已经完成的事务操作也不会丢失。</p><div class="alert warning no-icon"><p>例如：我们在使用 JDBC 操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p></div><p>其实，持久性是一个有点模糊的概念，因为实际上持久性也分很多不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。并且不可能有能做到 100% 的持久性保证的策略，故障恢复的错误率难免会发生。</p><p>InnoDB 作为 MySQL 的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘 IO，效率会很低。为此，InnoDB 提供了缓存(Buffer Pool)，Buffer Pool 中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从 Buffer Pool 中读取，如果 Buffer Pool 中没有，则从磁盘读取后放入 Buffer Pool；当向数据库写入数据时，会首先写入 Buffer Pool，Buffer Pool 中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。</p><p>Buffer Pool 的使用大大提高了读写数据的效率，但是也带了新的问题：如果 MySQL 宕机，而此时 Buffer Pool 中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</p><p>于是，redo log 被引入来解决这个问题：当数据修改时，除了修改 Buffer Pool 中的数据，还会在 redo log 记录这次操作；当事务提交时，会调用 fsync 接口对 redo log 进行刷盘。如果 MySQL 宕机，重启时可以读取 redo log 中的数据，对数据库进行恢复。redo log 采用的是 WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到 Buffer Pool，保证了数据不会因 MySQL 宕机而丢失，从而满足了持久性要求。</p><p>既然 redo log 也需要在事务提交时将日志写入磁盘，为什么它比直接将 Buffer Pool 中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：</p><div class="alert success no-icon"><ul><li>刷脏是随机 IO，因为每次修改的数据位置随机，但写 redo log 是追加操作，属于顺序 IO。</li><li>刷脏是以数据页（Page）为单位的，MySQL 默认页大小是 16KB，一个 Page 上一个小修改都要整页写入；而 redo log 中只包含真正需要写入的部分，无效 IO 大大减少。</li></ul></div><h2 id="隔离性与隔离级别"><a class="header-anchor" href="#隔离性与隔离级别">¶</a>隔离性与隔离级别</h2><p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了「 隔离级别 」的概念。并且随着隔离级别不断的提升，一条简单的 SQL 语句的执行效率会逐渐下降，因此很多时候，开发人员都是在隔离级别和执行效率之间寻找一个平衡点。</p><table><thead><tr><th style="text-align:center">隔离问题</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">脏读</td><td style="text-align:center">一个事务读取到了另外一个事务未提交的数据</td></tr><tr><td style="text-align:center">不可重复读</td><td style="text-align:center">同一个事务中，多次读取到的数据不一致</td></tr><tr><td style="text-align:center">幻读</td><td style="text-align:center">一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据</td></tr></tbody></table><p>❓ 既然幻读和不可重复读都是前后两次读取到的内容不一致，那么这两者到底有什么不同尼？</p><div class="alert success no-icon"><p>幻读和不可重复读都是读取了另一条已经提交的事务,不同的是：不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体。</p><ul><li>不可重复读的重点是修改，同一个事务，两次读取到的数据不一样。</li><li>幻读的重点在于新增或删除，同样的条件下，第一次和第二次读出来的记录数是不一样的</li></ul></div><p>SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ），具体的含义如下表</p><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">读未提交（read uncommitted）</td><td style="text-align:center">一个事务还没提交时，它做的变更就能被别的事务看到</td></tr><tr><td style="text-align:center">读提交（read committed）</td><td style="text-align:center">一个事务提交之后，它做的变更才会被其他事务看到</td></tr><tr><td style="text-align:center">可重复读（repeatable read）</td><td style="text-align:center">一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的</td></tr><tr><td style="text-align:center">串行化（serializable ）</td><td style="text-align:center">对于同一行记录，「 写 」会加「 写锁 」，「 读 」会加「 读锁 」。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</td></tr></tbody></table><p>其中「 读提交 」和「 可重复读 」比较难理解，这里用一个例子说明这几种隔离级别。</p><div class="alert warning no-icon"><p>假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行两个事务的行为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> T(c <span class="type">int</span>) engine<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T(c) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%A1%88%E4%BE%8B.webp" alt=""></p><p>现在就可以查看在不同的隔离级别下，事务 A 会有哪些不同的返回结果，也就是图里面 V1、V2 与 V3 的返回值分别是什么。</p><ul><li>若隔离级别是「 读未提交 」， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。</li><li>若隔离级别是「 读提交 」，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。</li><li>若隔离级别是「 可重复读 」，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li><li>若隔离级别是「 串行化 」，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。</li></ul></div><p>在实现事务的隔离级别时，数据库中会创建一个视图，访问的时候以示图的逻辑结果为准。</p><ul><li>在 「 可重复读 」隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图；</li><li>在 「 读提交 」隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的；</li><li>在 「 读未提交 」隔离级别下直接返回记录上的最新值，没有视图概念；</li><li>在 「串行化 」隔离级别下直接用加锁的方式来避免并行访问</li></ul><p>所以，在不同隔离界别下，数据库的行为是不同的。Oracle 数据库的默认隔离级别是 「 读提交 」，因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，一定要记得将 MySQL 的隔离级别设置为「 读提交 」</p><div class="alert warning no-icon"><p>修改 MySQL 隔离级别配置的方式是，将启动参数<code>transaction-isolation</code>的值设置成<code>READ-COMMITTED</code>，首先可以通过<code>show variables</code>来查看当前的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+----------------+</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+----------------+</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> transaction_isolation <span class="operator">|</span> READ<span class="operator">-</span>COMMITTED <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+----------------+</span></span><br></pre></td></tr></table></figure></div><p>📓 这四种隔离级别都有着各自存在的道理，并没有那种隔离级别一定比另一种隔离级别要好的情况，都是根据自己的业务情况来确定事务的隔离级别。</p><p>❓ 什么时候需要可重复读的场景？</p><div class="alert warning no-icon"><p>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。这时候使用「 可重复读 」隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p></div><h2 id="事务隔离的实现"><a class="header-anchor" href="#事务隔离的实现">¶</a>事务隔离的实现</h2><p>🎯 本小节将详细展示在可重复读隔离级别下，事务隔离具体是如何实现？</p><p>在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><div class="alert warning no-icon"><p>假设一个值从 1 按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97.webp" alt=""></p><p>当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到</p><p>同时，即使现在有另一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。</p></div><p>❓ 有了回滚日志可以方便事务执行撤销操作，但是这些回滚日志要保留到什么时候？什么时候应该删除这些回滚日志？</p><div class="alert warning no-icon"><p>当然是在系统不需要的时候删除这些回滚日志，数据库系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志就会被删除。简单的一点就是：当系统里没有比这个回滚日志更早的 read-view 的时候，就可以考虑删除此回滚日志</p></div><p>基于以上的原因，也可以解释，为什么在开发中不建议使用长事务。长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库</p><h2 id="数据库事务的启动方式"><a class="header-anchor" href="#数据库事务的启动方式">¶</a>数据库事务的启动方式</h2><p>开发过程中当然应该避免使用长事务，其实很多时候业务开发人员并不是有意使用长事务，通常都是由于误用所致。总结来说，MySQL 的事务启动方式有以下几种：</p><div class="alert success no-icon"><ul><li>显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback</li><li>set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接</li></ul></div><div class="alert danger no-icon"><p>有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。因此，总好使用 set autocommit=1, 通过显式语句的方式来启动事务。</p></div><p>❓ 如何避免长事务对业务的影响？</p><div class="alert success no-icon"><p>可以从应用开发端和数据库端进行解决。首先对于应用开发端而言，想要避免长事务有以下方法：</p><ol><li>确认是否使用了<code>set autocommit = 0</code>，这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1</li><li>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉</li><li>业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间</li></ol><p>其次，对于数据库端而言，有以下几种方式避免长事务：</p><ol><li>监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警/或者 kill；</li><li>使用 Percona 的 pt-kill 工具；</li><li>在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题</li><li>如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便</li></ol></div><h2 id="事务模型"><a class="header-anchor" href="#事务模型">¶</a>事务模型</h2><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql-活动状态 (active).png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql-活动状态 (active).png" alt=""></a></div><table><thead><tr><th style="text-align:center">状态</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">活动的</td><td style="text-align:center">初始状态,事务执行时处于这个状态</td></tr><tr><td style="text-align:center">部分提交的</td><td style="text-align:center">最后一条语句执行后</td></tr><tr><td style="text-align:center">失败的</td><td style="text-align:center">发现正常的执行不能继续进行,<strong>必须进行回滚</strong></td></tr><tr><td style="text-align:center">中止的</td><td style="text-align:center">事务回滚并且数据库已恢复到事务开始执行前到状态后</td></tr><tr><td style="text-align:center">提交的</td><td style="text-align:center">成功完成</td></tr></tbody></table><p>撤销已提交事务所造成的影响的唯一方法是执行一个补偿事务，这也是回滚能够成功的原因。</p><h2 id="数据库的事务"><a class="header-anchor" href="#数据库的事务">¶</a>数据库的事务</h2><p>之前都是一些理论知识中对于事务的描述，解析来主要关注于 MySQL 中如何使用事务控制语言（TCL，Transaction Control Language）进行 MySQL 中的事务操作。</p><h3 id="MySQL-中的事务"><a class="header-anchor" href="#MySQL-中的事务">¶</a>MySQL 中的事务</h3><p>MySQL 中的事务主要分为两种:<code>隐式事务</code>及<code>显示事务</code>，其中隐式事务没有明显的开始和结束的标记(INSERT,UPDATE,DELETE 语句本身就是一个事务)；显示事务具有明显的开启和结束的标记</p><h3 id="事务的创建"><a class="header-anchor" href="#事务的创建">¶</a>事务的创建</h3><p>MySQL 系统默认启用隐式事务:每执行一条 SQL 语句，都是一个单独的事务。如果需要在一个事务中包含多条 SQL 语句，那么需要先关闭隐式事务.</p><ol><li>将自动提交功能为禁用</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">LIKe</span> <span class="string">&#x27;autocommit&#x27;</span>;	#查看当前数据库是否为隐式事务</span><br><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">0</span>;	#将事务设置为显示事务</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;autocommit&#x27;</span>;	#再次查看当前事务类型</span><br></pre></td></tr></table></figure><ol start="2"><li>使用显示事务进行操作</li></ol><p>开启事务：<code>start transaction</code>；</p><p>结束事务：<code>commit</code>或<code>rollback</code>。</p><p>在执行 SQL 语句之前，先执行<code>strat transaction</code>，这就开启了一个事务（事务的起点），然后可以去执行多条 SQL 语句，最后要结束事务，commit 表示提交，即事务中的多条 SQL 语句所做出的影响会持久化到数据库中。或者 rollback，表示回滚，即回滚到事务的起点，之前做的所有操作都被撤消了！也可以打断点，此时事务回滚不再是回滚到起点，而是回滚到断点处</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#创建事务要用到的表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> account(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    balance <span class="type">NUMERIC</span>(<span class="number">10.2</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account(NAME,balance) <span class="keyword">VALUES</span>(<span class="string">&#x27;fanbingbing&#x27;</span>, <span class="number">100000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account(NAME,balance) <span class="keyword">VALUES</span>(<span class="string">&#x27;lichen&#x27;</span>, <span class="number">100000</span>);</span><br></pre></td></tr></table></figure><div class="alert warning no-icon"><p>演示事务执行失败<br>案例一：回滚 事务执行失败！</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance<span class="operator">=</span>balance<span class="number">-10000</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance<span class="operator">=</span>balance<span class="operator">+</span><span class="number">10000</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p>案例二：退出 mysql 客户端 事务执行失败！</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance<span class="operator">=</span>balance<span class="number">-10000</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance<span class="operator">=</span>balance<span class="operator">+</span><span class="number">10000</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>演示事务执行成功</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance<span class="operator">=</span>balance<span class="number">-10000</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance<span class="operator">=</span>balance<span class="operator">+</span><span class="number">10000</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></div><h3 id="数据库的隔离级别"><a class="header-anchor" href="#数据库的隔离级别">¶</a>数据库的隔离级别</h3><p>通过设置事务的隔离级别可以解决脏读、不可重复读或幻读等问题。</p><ol><li><code>READ UNCOMMITTED</code></li><li><code>READ COMMITTED</code>可以避免脏读</li><li><code>REPEATABLE READ</code>可以避免脏读、不可重复读和一部分幻读</li><li><code>SERIALIZABLE</code>可以避免脏读、不可重复读和幻读<div class="alert warning no-icon"><p>常见的事务隔离界别操作，</p><ul><li>设置隔离级别：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> session<span class="operator">|</span><span class="keyword">global</span>  transaction isolation level 隔离级别名;</span><br></pre></td></tr></table></figure><ul><li>查看隔离级别：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@tx_isolation</span>;</span><br></pre></td></tr></table></figure></div></li></ol><h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fjdingsd/p/5273008.html">事务的四大特性以及隔离级别</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kismetv/p/10331633.html">深入理解 MySQL 事务</a><br><a target="_blank" rel="noopener" href="https://nxwz51a5wp.feishu.cn/docs/doccn9j1QIJp2f81Ty8Q2JHtEbg">事务的并发控制协议理论&amp;MySQL 源码分析</a></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/MySQL/" rel="tag">MySQL</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/cwru-%E6%95%B0%E6%8D%AE%E9%9B%86/" data-tooltip="CWRU 数据集" aria-label="上一篇: CWRU 数据集"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/fcrackzip-%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" data-tooltip="fcrackzip 工具的使用" aria-label="下一篇: fcrackzip 工具的使用"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/cwru-%E6%95%B0%E6%8D%AE%E9%9B%86/" data-tooltip="CWRU 数据集" aria-label="上一篇: CWRU 数据集"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/fcrackzip-%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" data-tooltip="fcrackzip 工具的使用" aria-label="下一篇: fcrackzip 工具的使用"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>