<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>go 命令记录 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="Go命令"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n本文大部分内容来自于网络摘录，如果想要查看原文，请直接通过附录访问\n\n\n¶概述\nGo 有非常多的命令，本文想要将平时使用到的命令都列举在这里，以发方便后续查看\n¶go build 命令\ngo build命令用于编译我们指定的源码文件或代码包以及它们的依赖包\n\n¶go build 编译当前目录\n如果我们在执行 go build 命令后不跟任何代码包，那么命令将试图编译当前目录所对应的代码包。\n例如，我们想编译某个项目中的logging代码包。其中一个方法是进入logging目录并直接执行下列命令就会编译当前目录下的所有命令码源文件\n1pineapple-man@localhost:~/golang/project/src/logging$ go build\n\n上面提出了一个名词：命令码源文件，在 Go 语言的源码文件有三大类，即：命令源码文件、库源码文件和测试源码文件。他们的功用各不相同，而写法也各有各的特点。\n\n命令源码文件总是作为可执行的程序的入口。命令源码文件总应该属于 main 代码包，且在其中有无参数声明、无结果声明的 main 函数。单个命令源码文件可以被单独编译，也可以被单独安装（可能需要设置环境变量 GOBIN）。当然，命令源码文件也可以被单独运行。\n库源码文件一般用于集中放置各种待被使用的程序实体（全局常量、全局变量、接口、结构体、函数等等）。\n测试源码文件主要用于对前两种源码文件中的程序实体的功能和性能进行测试。另外，后者也可以用于展现前两者中程序的使用方法。\n\n\n¶go build 编译指定目录\n另一种编译logging包的方法是：在任意目录下，通过指定logging目录做到编译的目的\n12# 假设当前在 #GOPATH/src 目录下pineapple-man@localhost:~/golang/project/src$ go build logging\n这种编译方法可以正常执行是因为已经在环境变量GOPATH中加入了 goc2p 项目的根目录（即~/golang/goc2p/）。这时，goc2p 项目的根目录就成为了一个工作区目录。只有这样，Go 语言才能正确识别我们提供的 goc2p 项目中某个代码包的导入路径。\n而代码包的导入路径是指，相对于 Go 语言自身的源码目录（即$GOROOT/src）或我们在环境变量 GOPATH 中指定的某个目录的 src 子目录下的子路径。例如，这里的代码包 logging 的绝对路径是~/golang/goc2p/src/logging。而不论 goc2p 项目的根文件夹被放在哪儿，logging 包的导入路径都是 logging。显而易见，我们在称呼一个代码包的时候总是以其导入路径作为其称谓。\n\n¶go build 编译指定多个源文件\ngo build 还可以同时编译指定的多个 Go 源码文件\n12pineapple-man@localhost:~/golang/goc2p/src$ go build \\    logging/base.go  logging/console_logger.go logging/tag.go\n但是，使用这种方法会有一个限制。作为参数的多个 Go 源码文件必须在同一个目录中。也就是说，如果想用这种方法既编译 logging 包又编译 basic 包是不可能的。但是在需要的时候，那些被编译目标依赖的代码包会被 go build 命令自动的编译。\n例如：如果有一个导入路径为 app 的代码包，同时依赖了 logging 包和 basic 包。那么在执行 go build app 的时候，该命令就会自动的在编译 app 包之前去检查 loggin g 包和 basic 包的编译状态。如果发现它们的编译结果文件不是最新的，那么该命令就会先去的编译这两个代码包，然后再编译 app 包\n\ngo build 命令在编译只包含库源码文件的代码包（或者同时编译多个代码包）时，只会做检查行的编译，而不会输出任何结果文件。\n一方面，go build 既不能编译包含 「 多个命令源码文件的包 」，也不能同时编译 「 多个命令源码文件 」。因为，如果把多个命令源码文件作为一个整体看待，那么每个文件中的 main 函数就属于重名函数，在编译时会抛出重复定义错误。\n\n假如，在 goc2p 项目的代码包 cmd（此代码包仅用于示例目的，并不会永久存在于该项目中）中包含有两个命令源码文件：showds.go 和 initpkg_demo.go，那么我们在使用 go build 命令同时编译它们时就会失败。示例如下：\n1234pineapple-man@localhost:~/golang/goc2p/src/cmd$ go build showds.go initpkg_demo.go# command-line-arguments./initpkg_demo.go:19: main redeclared in this block        previous declaration at ./showds.go:56\n🎶 需要注意命令给出的提示有command-line-arguments,在这个位置上原本应该显示的是作为编译目标的源码文件所属的代码包的导入路径。但是，这里显示的并不是它们所属的代码包的导入路径 cmd。这是因为，命令程序在分析参数的时候如果发现第一个参数是 Go 源码文件而不是代码包，则会在内部生成一个「 虚拟代码包 」。这个虚拟代码包的导入路径和名称都会是command-line-arguments。在其他基于编译流程的命令程序中也有与之一致的操作，比如go install命令和go run命令。\n\n另一方面，如果我们编译的多个属于 main 包的源码文件中没有 main 函数的声明，那么就会使编译器立即报出「 未定义 main 函数声明 」的错误并中止编译。也就是说，在我们同时编译多个 main 包的源码文件时，要保证其中有且仅有一个 main 函数声明，否则编译是无法成功的。\n如果我们有多个声明为属于 main 包的源码文件，且其中只有一个文件声明了 main 函数的话，那么是可以使用go build命令同时编译它们的。在这种情况下，不包含 main 函数声明的那几个源码文件会被视为库源码文件。如此编译后的结果文件的名称将会与我们指定的编译目标中最左边的那个源码文件的主文件名相同。\n¶额外参数\n除了让 Go 语言编译器自行决定可执行文件的名称，还可以自定义输出文件名称。示例如下：\n123pineapple-man@localhost:~/golang/goc2p/src/basic/pkginit$ go build -o initpkg initpkg_demo.gopineapple-man@localhost:~/golang/goc2p/src/basic/pkginit$ lsinitpkg    initpkg_demo.go\n使用-o标记可以指定输出文件（在这个示例中指的是可执行文件）的名称。它是最常用的一个 go build 命令标记。但需要注意的是，当使用标记-o 的时候，不能同时对多个代码包进行编译。\n\n标记-i会使 go build 命令安装那些编译目标依赖的且还未被安装的代码包。这里的安装意味着产生与代码包对应的归档文件，并将其放置到当前工作区目录的 pkg 子目录的相应子目录中。在默认情况下，这些代码包是不会被安装的。\n\n除此之外，还有一些标记不但受到 go build 命令的支持，而且对于后面会提到的 go install、go run、go test 等命令同样是有效的。下表列出了其中比较常用的标记。\n\n.tg  {border-collapse:collapse;border-color:#9ABAD9;border-spacing:0;margin:0px auto;}\n.tg td{background-color:#EBF5FF;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#444;\n  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{background-color:#409cff;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#fff;\n  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-sx1p{font-weight:bold;position:-webkit-sticky;position:sticky;text-align:center;top:-1px;vertical-align:middle;\n  will-change:transform}\n.tg .tg-nrix{text-align:center;vertical-align:middle}\n\n\n\n  \n    标记名称\n    标记描述\n  \n\n\n  \n    -a\n    强行对所有涉及到的代码包（包含标准库中的代码包）进行重新构建，即使它们已经是最新的了。\n  \n  \n    -n\n    打印编译期间所用到的其它命令，但是并不真正执行它们。\n  \n  \n    -p n\n    指定编译过程中执行各任务的并行数量（确切地说应该是并发数量）。在默认情况下，该数量等于CPU的逻辑核数。但是在darwin/arm平台（即iPhone和iPad所用的平台）下，该数量默认是1。\n  \n  \n    -race\n    开启竞态条件的检测。不过此标记目前仅在linux/amd64、freebsd/amd64、darwin/amd64和windows/amd64平台下受到支持。\n  \n  \n    -v\n    打印出那些被编译的代码包的名字。\n  \n  \n    -work\n    打印出编译时生成的临时工作目录的路径，并在编译结束时保留它。在默认情况下，编译结束时会删除该目录。\n  \n  \n    -x\n    打印编译期间所用到的其它命令。注意它与-n标记的区别。\n  \n\n\n执行 go build 命令的计算机如果拥有多个逻辑 CPU 核心，那么编译代码包的顺序可能会存在一些不确定性。但是，它一定会满足这样的约束条件：「 依赖代码包 -&gt; 当前代码包 -&gt; 触发代码包 」\n¶buildmode\n在 go build 和 go install 命令中，我们可以指定 -buildmode 参数来让编译器构建出特定的对象文件。通过命令 go help buildmode，可以看到其支持的选项：\n12345678-buildmode=archive-buildmode=c-archive-buildmode=c-shared-buildmode=default-buildmode=shared-buildmode=exe-buildmode=pie-buildmode=plugin\n¶plugin\n\nbuild the listed main packages,plus all packages that they import,into a Go plugin.Package not named main are ignored\n\n它将 package main 编译为一个 go 插件，并可在运行时动态加载\n1234567891011package mainimport &quot;fmt&quot;type greeting stringfunc (g greeting) Greet() &#123;\tfmt.Println(&quot;hello world&quot;)&#125;var Greeter greeting\n随后将其编译成为一个 go 插件\n1go build -buildmode=plugin -o greeter.so greeter.go\n最终再使用 golang 官方的 plugin 库来载入这个插件\n12345678910111213141516171819202122232425262728293031323334package mainimport (\t&quot;fmt&quot;\t&quot;os&quot;\t&quot;plugin&quot;)type Greeter interface &#123;\tGreet()&#125;func main() &#123;  //载入插件\tplug, err := plugin.Open(&quot;./greeter.so&quot;)\tif err != nil &#123;\t\tfmt.Println(err)\t\tos.Exit(1)\t&#125;  //在插件中寻找对应的方法\tsymGreeter, err := plug.Lookup(&quot;Greeter&quot;)\tif err != nil &#123;\t\tfmt.Println(err)\t\tos.Exit(1)\t&#125;\tvar greeter Greeter\tgreeter, ok := symGreeter.(Greeter)\tif !ok &#123;\t\tfmt.Println(err)\t\tos.Exit(1)\t&#125;\tgreeter.Greet()&#125;\n¶go install\n命令 go install 用于编译并安装指定的代码包及它们的依赖包。当指定的代码包的依赖包还没有被编译和安装时，该命令会先去处理依赖包，随后再安装。\n\n与 go build 命令一样，传给 go install 命令的代码包参数应该以导入路径的形式提供。并且，go build 命令的绝大多数标记也都可以用于 go install 命令。实际上，go install 命令只比 go build 命令多做了一件事，即：安装编译后的结果文件到指定目录\n¶安装代码包\n如果 go install 命令后跟的代码包中仅包含库源码文件，那么 go install 命令会把「 编译后的结果 」文件保存在源码文件所在工作区的 pkg 目录下。对于仅包含库源码文件的代码包来说，这个结果文件就是将对应的代码包归档文件（也叫静态链接库文件，名称以.a 结尾）\n相比之下，我们在使用 go build 命令对仅包含库源码文件的代码包进行编译时，是不会在当前工作区的 src 目录以及 pkg 目录下产生任何结果文件的。结果文件会出于编译的目的被生成在临时目录中，但并不会使当前工作区目录产生任何变化。\n如果我们在执行 go install 命令时不后跟任何代码包参数，那么命令将试图编译当前目录所对应的代码包。如果指定了需要安装的代码包，首先会对指定代码包先编译，随后会将编译的结果安装到默认目录($GOPATH/pkg)下\n\n例如，在代码包 pkgtool 对应的目录下安装 cnet/ctcp，下面命令中我们使用了一个目录相对路径\n12pineapple-man@localhost:~/golang/goc2p/src/pkgtool$ go install -a -v -work ../cnet/ctcpWORK=/tmp/go-build083178213\n\n实际上，这种提供代码包位置的方式被叫做本地代码包路径方式，也是被所有 Go 命令接受的一种方式，这包括之前已经介绍过的 go build 命令。但是需要注意的是，本地代码包路径只能以目录相对路径的形式呈现，而不能使用目录绝对路径 。请看下面的示例：\n12pineapple-man@localhost:~/golang/goc2p/src/cnet/ctcp$ go install -v -work ~/golang/goc2p/src/cnet/ctcpcan&#x27;t load package: package /home/pineapple-man/golang/goc2p/src/cnet/ctcp: import &quot;/home/pineapple-man/golang/goc2p/src/cnet/ctcp&quot;: cannot import absolute path\n以目录绝对路径的形式提供代码包位置是不会被 Go 命令认可的。这是由于 Go 认为本地代码包路径的表示只能以./或../开始，再或者直接为.或..，而代码包的代码导入路径又不允许以/开始。所以，这种用绝对路径表示代码包位置的方式也就不能被支持了，这个规则适用于所有 go 命令。\n¶安装命令源码文件\n除了安装代码包之外，go install 命令还可以安装命令源码文件。\n\n12pineapple-man@localhost:~/golang/goc2p/src$ go install helper/ds/showds.gogo install: no install location for .go files listed on command line (GOBIN not set)\n在环境变量 GOPATH 中包含多个工作区目录路径时，我们需要在编译命令源码文件前先对环境变量 GOBIN 进行设置。实际上，这个环境变量所指的目录路径就是命令程序生成的结果文件的存放目录。go install 命令会把相应的可执行文件放置到这个目录中。\n由于命令 go build 在编译库源码文件后不会产生任何结果文件，所以自然也不用会在意结果文件的存放目录。在该命令编译单一的命令源码文件或者包含一个命令源码文件和多个库源码文件时，在结果文件存放目录无效的情况下会将结果文件（也就是可执行文件）存放到执行该命令时所在的目录下。因此，即使环境变量 GOBIN 的值无效，我们在执行 go build 命令时也不会见到这个错误提示信息。\n然而，go install 命令中一个很重要的步骤就是将结果文件（归档文件或者可执行文件）存放到相应的目录中。所以，go install 命令在安装命令源码文件时，如果环境变量 GOBIN 的值无效，则它会在最后检查结果文件存放目录的时候发现这一问题，并打印与上述示例所示内容类似的错误提示信息，最后直接退出。\n\n而且，在我们为环境变量 GOBIN 设置了正确的值之后，这个错误提示信息仍然可能会出现。这是因为，只有在安装命令源码文件的时候，命令程序才会将环境变量 GOBIN 的值作为结果文件的存放目录。而在安装库源码文件时，在命令程序内部的代表结果文件存放目录路径的那个变量不会被赋值。最后，命令程序会发现它依然是个无效的空值。所以，命令程序会同样返回一个关于「 无安装位置 」的错误。这就引出一个结论，我们只能使用安装代码包的方式来安装库源码文件，而不能在 go install 命令罗列并安装它们。另外，go install 命令目前无法接受标记-o 以自定义结果文件的存放位置。这也从侧面说明了go install 命令不支持针对库源码文件的安装操作。\n¶go get\n命令go get可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。在上面这个示例中\n\n为了分离自己与第三方的代码，我们会设置两个或更多的工作区。我们现在有一个目录路径为/home/pineapple-man/golang/lib 的工作区，并且它是环境变量 GOPATH 值中的第一个目录路径。注意，环境变量 GOPATH 中包含的路径不能与环境变量 GOROOT 的值重复。好了，如果我们使用 go get 命令下载和安装代码包，那么这些代码包都会被安装在上面这个工作区中。我们暂且把这个工作区叫做 Lib 工作区。\n另一方面，如果我们想把一个项目上传到 Github 网站（或其他代码托管网站）上并被其他人使用的话，那么我们就应该把这个项目当做一个代码包来看待。其实我们在之前已经提到过原因，go get 命令会将项目下的所有子目录和源码文件存放到第一个工作区的 src 目录下，而 src 目录下的所有子目录都会是某个代码包导入路径的一部分或者全部。也就是说，我们应该直接在项目目录下存放子代码包和源码文件，并且直接存放在项目目录下的源码文件所声明的包名应该与该项目名相同（除非它是命令源码文件）。这样做可以让其他人使用 go get 命令从 Github 站点上下载你的项目之后直接就能使用它。\n¶远程导入路径分析\n实际上，go get 命令所做的动作也被叫做代码包远程导入，而传递给该命令的作为代码包导入路径的那个参数又被叫做代码包远程导入路径\ngo get 命令不仅可以从像 Github 这样著名的代码托管站点上下载代码包，还可以从任何命令支持的代码版本控制系统（英文为 Version Control System，简称为 VCS）检出代码包。任何代码托管站点都是通过某个或某些代码版本控制系统来提供代码上传下载服务的。所以，更严格地讲，go get 命令所做的是从代码版本控制系统的远程仓库中检出/更新代码包并对其进行编译和安装。\n对于已存在于本地工作区的代码包，除非要求强行更新代码包，否则 go get 命令不会进行重复下载。如果想要强行更新代码包，可以在执行 go get 命令时加入-u 标记。\n¶go clean\n执行 go clean 命令会删除掉执行其它命令时产生的一些文件和目录，包括：\n\n在使用 go build 命令时在当前代码包下生成的与包名同名或者与 Go 源码文件同名的可执行文件。在 Windows 下，则是与包名同名或者 Go 源码文件同名且带有“.exe”后缀的文件\n如果执行 go clean 命令时带有标记-i，则会同时删除安装当前代码包时所产生的结果文件。如果当前代码包中只包含库源码文件，则结果文件指的就是在工作区的 pkg 目录的相应目录下的归档文件。如果当前代码包中只包含一个命令源码文件，则结果文件指的就是在工作区的 bin 目录下的可执行文件。\n如果执行 go clean 命令时带有标记-r，则还包括当前代码包的所有依赖包的上述目录和文件。\n\n\n¶go doc &amp; godoc\ngo doc 命令可以打印附于 Go 语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。\n\n¶go run\ngo run 命令用于运行命令源码文件\n\ngo run 命令可以编译并运行命令源码文件。由于它其中包含了编译动作，因此它也可以接受所有可用于 go build 命令的标记。除了标记之外，go run 命令只接受 Go 源码文件作为参数，而不接受代码包。与 go build 命令和 go install 命令一样，go run 命令也不允许多个命令源码文件作为参数，即使它们在同一个代码包中也是如此。\n¶附录\ngo 命令教程\n","dateCreated":"2022-04-27T11:46:56+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2022-04-27T11:46:56+00:00","description":"使用 Java 时完全没怎么在意 Java 命令的形式，但是最近在进行 go 开发时，却发现需要使用很多的 Go 命令，在这里记录一下","headline":"go 命令记录","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/go-%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/go-%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/","keywords":"GO"}</script><meta name="description" content="使用 Java 时完全没怎么在意 Java 命令的形式，但是最近在进行 go 开发时，却发现需要使用很多的 Go 命令，在这里记录一下"><meta property="og:type" content="blog"><meta property="og:title" content="go 命令记录"><meta property="og:url" content="https://pineapple-man.github.io/go-%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="使用 Java 时完全没怎么在意 Java 命令的形式，但是最近在进行 go 开发时，却发现需要使用很多的 Go 命令，在这里记录一下"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-04-27T11:46:56.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.015Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="GO"><meta name="twitter:card" content="summary"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">go 命令记录</h1><div class="post-meta"><time datetime="2022-04-27T11:46:56+00:00">4月 27, 2022 </time><span>发布在 </span><a class="category-link" href="/categories/Go/">Go</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 5.3k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 52 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><blockquote><p>本文大部分内容来自于网络摘录，如果想要查看原文，请直接通过<a href="#%E9%99%84%E5%BD%95">附录</a>访问</p></blockquote><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-build-%E5%91%BD%E4%BB%A4"><span class="toc-text">go build 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#go-build-%E7%BC%96%E8%AF%91%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95"><span class="toc-text">go build 编译当前目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-build-%E7%BC%96%E8%AF%91%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95"><span class="toc-text">go build 编译指定目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-build-%E7%BC%96%E8%AF%91%E6%8C%87%E5%AE%9A%E5%A4%9A%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-text">go build 编译指定多个源文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E5%8F%82%E6%95%B0"><span class="toc-text">额外参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#buildmode"><span class="toc-text">buildmode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#plugin"><span class="toc-text">plugin</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-install"><span class="toc-text">go install</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E4%BB%A3%E7%A0%81%E5%8C%85"><span class="toc-text">安装代码包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6"><span class="toc-text">安装命令源码文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-get"><span class="toc-text">go get</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E5%AF%BC%E5%85%A5%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90"><span class="toc-text">远程导入路径分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-clean"><span class="toc-text">go clean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-doc-godoc"><span class="toc-text">go doc &amp; godoc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-run"><span class="toc-text">go run</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol><h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><p>Go 有非常多的命令，本文想要将平时使用到的命令都列举在这里，以发方便后续查看</p><h2 id="go-build-命令"><a class="header-anchor" href="#go-build-命令">¶</a><code>go build</code> 命令</h2><div class="alert info no-icon"><p><code>go build</code>命令用于编译我们指定的源码文件或代码包以及它们的依赖包</p></div><h3 id="go-build-编译当前目录"><a class="header-anchor" href="#go-build-编译当前目录">¶</a><code>go build</code> 编译当前目录</h3><p>如果我们在执行 go build 命令后不跟任何代码包，那么命令将试图编译当前目录所对应的代码包。</p><div class="alert warning no-icon"><p>例如，我们想编译某个项目中的<code>logging</code>代码包。其中一个方法是进入<code>logging</code>目录并直接执行下列命令就会编译当前目录下的所有<strong>命令码源文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pineapple-man@localhost:~/golang/project/src/logging$ go build</span><br></pre></td></tr></table></figure></div><p>上面提出了一个名词：<strong>命令码源文件</strong>，在 Go 语言的源码文件有三大类，即：命令源码文件、库源码文件和测试源码文件。他们的功用各不相同，而写法也各有各的特点。</p><div class="alert success no-icon"><ul><li>命令源码文件总是作为可执行的程序的入口。命令源码文件总应该属于 main 代码包，且在其中有无参数声明、无结果声明的 main 函数。单个命令源码文件可以被单独编译，也可以被单独安装（可能需要设置环境变量 GOBIN）。当然，命令源码文件也可以被单独运行。</li><li>库源码文件一般用于集中放置各种待被使用的程序实体（全局常量、全局变量、接口、结构体、函数等等）。</li><li>测试源码文件主要用于对前两种源码文件中的程序实体的功能和性能进行测试。另外，后者也可以用于展现前两者中程序的使用方法。</li></ul></div><h3 id="go-build-编译指定目录"><a class="header-anchor" href="#go-build-编译指定目录">¶</a><code>go build</code> 编译指定目录</h3><p>另一种编译<code>logging</code>包的方法是：在任意目录下，通过指定<code>logging</code>目录做到编译的目的</p><div class="alert warning no-icon"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设当前在 #GOPATH/src 目录下</span></span><br><span class="line">pineapple-man@localhost:~/golang/project/src$ go build logging</span><br></pre></td></tr></table></figure><p>这种编译方法可以正常执行是因为已经在环境变量<code>GOPATH</code>中加入了 goc2p 项目的根目录（即~/golang/goc2p/）。这时，goc2p 项目的根目录就成为了一个工作区目录。只有这样，Go 语言才能正确识别我们提供的 goc2p 项目中某个代码包的导入路径。</p><p>而代码包的导入路径是指，相对于 Go 语言自身的源码目录（即$GOROOT/src）或我们在环境变量 GOPATH 中指定的某个目录的 src 子目录下的子路径。例如，这里的代码包 logging 的绝对路径是~/golang/goc2p/src/logging。而不论 goc2p 项目的根文件夹被放在哪儿，logging 包的导入路径都是 logging。显而易见，我们在称呼一个代码包的时候总是以其导入路径作为其称谓。</p></div><h3 id="go-build-编译指定多个源文件"><a class="header-anchor" href="#go-build-编译指定多个源文件">¶</a><code>go build</code> 编译指定多个源文件</h3><p>go build 还可以同时编译指定的多个 Go 源码文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pineapple-man@localhost:~/golang/goc2p/src$ go build \</span><br><span class="line">    logging/base.go  logging/console_logger.go logging/tag.go</span><br></pre></td></tr></table></figure><p>但是，使用这种方法会有一个限制。作为参数的多个 Go 源码文件必须在同一个目录中。也就是说，如果想用这种方法既编译 logging 包又编译 basic 包是不可能的。但是在需要的时候，那些被编译目标依赖的代码包会被 go build 命令自动的编译。</p><div class="alert warning no-icon"><p>例如：如果有一个导入路径为 app 的代码包，同时依赖了 logging 包和 basic 包。那么在执行 go build app 的时候，该命令就会自动的在编译 app 包之前去检查 loggin g 包和 basic 包的编译状态。如果发现它们的编译结果文件不是最新的，那么该命令就会先去的编译这两个代码包，然后再编译 app 包</p></div><p><code>go build</code> 命令在编译只包含库源码文件的代码包（或者同时编译多个代码包）时，只会做检查行的编译，而不会输出任何结果文件。</p><div class="alert info no-icon"><p>一方面，go build 既不能编译包含 「 多个命令源码文件的包 」，也不能同时编译 「 多个命令源码文件 」。因为，如果把多个命令源码文件作为一个整体看待，那么每个文件中的 main 函数就属于重名函数，在编译时会抛出重复定义错误。</p></div><div class="alert warning no-icon"><p>假如，在 goc2p 项目的代码包 cmd（此代码包仅用于示例目的，并不会永久存在于该项目中）中包含有两个命令源码文件：showds.go 和 initpkg_demo.go，那么我们在使用 go build 命令同时编译它们时就会失败。示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pineapple-man@localhost:~/golang/goc2p/src/cmd$ go build showds.go initpkg_demo.go</span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">./initpkg_demo.go:19: main redeclared <span class="keyword">in</span> this block</span><br><span class="line">        previous declaration at ./showds.go:56</span><br></pre></td></tr></table></figure><p>🎶 需要注意命令给出的提示有<code>command-line-arguments</code>,在这个位置上原本应该显示的是作为编译目标的源码文件所属的代码包的导入路径。但是，这里显示的并不是它们所属的代码包的导入路径 cmd。这是因为，命令程序在分析参数的时候如果发现第一个参数是 Go 源码文件而不是代码包，则会在内部生成一个「 虚拟代码包 」。这个虚拟代码包的导入路径和名称都会是<code>command-line-arguments</code>。在其他基于编译流程的命令程序中也有与之一致的操作，比如<code>go install</code>命令和<code>go run</code>命令。</p></div><p>另一方面，如果我们编译的多个属于 main 包的源码文件中没有 main 函数的声明，那么就会使编译器立即报出「 未定义 main 函数声明 」的错误并中止编译。也就是说，在我们同时编译多个 main 包的源码文件时，要保证其中有且仅有一个 main 函数声明，否则编译是无法成功的。</p><p>如果我们有多个声明为属于 main 包的源码文件，且其中只有一个文件声明了 main 函数的话，那么是可以使用<code>go build</code>命令同时编译它们的。在这种情况下，不包含 main 函数声明的那几个源码文件会被视为库源码文件。如此编译后的结果文件的名称将会与我们指定的编译目标中最左边的那个源码文件的主文件名相同。</p><h3 id="额外参数"><a class="header-anchor" href="#额外参数">¶</a>额外参数</h3><p>除了让 Go 语言编译器自行决定可执行文件的名称，还可以自定义输出文件名称。示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pineapple-man@localhost:~/golang/goc2p/src/basic/pkginit$ go build -o initpkg initpkg_demo.go</span><br><span class="line">pineapple-man@localhost:~/golang/goc2p/src/basic/pkginit$ <span class="built_in">ls</span></span><br><span class="line">initpkg    initpkg_demo.go</span><br></pre></td></tr></table></figure><div class="alert success no-icon"><p>使用<code>-o</code>标记可以指定输出文件（在这个示例中指的是可执行文件）的名称。它是最常用的一个 go build 命令标记。但需要注意的是，当使用标记-o 的时候，不能同时对多个代码包进行编译。</p></div><div class="alert success no-icon"><p>标记<code>-i</code>会使 go build 命令安装那些编译目标依赖的且还未被安装的代码包。这里的安装意味着产生与代码包对应的归档文件，并将其放置到当前工作区目录的 pkg 子目录的相应子目录中。在默认情况下，这些代码包是不会被安装的。</p></div><p>除此之外，还有一些标记不但受到 go build 命令的支持，而且对于后面会提到的 go install、go run、go test 等命令同样是有效的。下表列出了其中比较常用的标记。</p><style type="text/css">.tg{border-collapse:collapse;border-color:#9abad9;border-spacing:0;margin:0 auto}.tg td{background-color:#ebf5ff;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial,sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal}.tg th{background-color:#409cff;border-color:#9abad9;border-style:solid;border-width:1px;color:#fff;font-family:Arial,sans-serif;font-size:14px;font-weight:400;overflow:hidden;padding:10px 5px;word-break:normal}.tg .tg-sx1p{font-weight:700;position:-webkit-sticky;position:sticky;text-align:center;top:-1px;vertical-align:middle;will-change:transform}.tg .tg-nrix{text-align:center;vertical-align:middle}</style><table class="tg"><thead><tr><th class="tg-sx1p">标记名称</th><th class="tg-sx1p">标记描述</th></tr></thead><tbody><tr><td class="tg-nrix">-a</td><td class="tg-nrix">强行对所有涉及到的代码包（包含标准库中的代码包）进行重新构建，即使它们已经是最新的了。</td></tr><tr><td class="tg-nrix">-n</td><td class="tg-nrix">打印编译期间所用到的其它命令，但是并不真正执行它们。</td></tr><tr><td class="tg-nrix">-p n</td><td class="tg-nrix">指定编译过程中执行各任务的并行数量（确切地说应该是并发数量）。<br>在默认情况下，该数量等于CPU的逻辑核数。但是在<span style="color:#2d85ca;background-color:#f9f2f4">darwin/arm</span>平台（即iPhone和iPad所用的平台）下，该数量默认是<span style="color:#2d85ca;background-color:#f9f2f4">1</span>。</td></tr><tr><td class="tg-nrix">-race</td><td class="tg-nrix"><span style="font-weight:400;font-style:normal">开启竞态条件的检测。</span><br><span style="font-weight:400;font-style:normal">不过此标记目前仅在</span>linux/amd64、freebsd/amd64、darwin/amd64和windows/amd64平台下受到支持。</td></tr><tr><td class="tg-nrix">-v</td><td class="tg-nrix">打印出那些被编译的代码包的名字。</td></tr><tr><td class="tg-nrix">-work</td><td class="tg-nrix">打印出编译时生成的临时工作目录的路径，并在编译结束时保留它。在默认情况下，编译结束时会删除该目录。</td></tr><tr><td class="tg-nrix">-x</td><td class="tg-nrix">打印编译期间所用到的其它命令。注意它与<span style="color:#2d85ca;background-color:#f9f2f4">-n</span>标记的区别。</td></tr></tbody></table><p>执行 go build 命令的计算机如果拥有多个逻辑 CPU 核心，那么编译代码包的顺序可能会存在一些不确定性。但是，它一定会满足这样的约束条件：「 依赖代码包 -&gt; 当前代码包 -&gt; 触发代码包 」</p><h3 id="buildmode"><a class="header-anchor" href="#buildmode">¶</a><code>buildmode</code></h3><p>在 go build 和 go install 命令中，我们可以指定 -buildmode 参数来让编译器构建出特定的对象文件。通过命令 go help buildmode，可以看到其支持的选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-buildmode=archive</span><br><span class="line">-buildmode=c-archive</span><br><span class="line">-buildmode=c-shared</span><br><span class="line">-buildmode=default</span><br><span class="line">-buildmode=shared</span><br><span class="line">-buildmode=exe</span><br><span class="line">-buildmode=pie</span><br><span class="line">-buildmode=plugin</span><br></pre></td></tr></table></figure><h4 id="plugin"><a class="header-anchor" href="#plugin">¶</a>plugin</h4><blockquote><p>build the listed main packages,plus all packages that they import,into a Go plugin.Package not named main are ignored</p></blockquote><p>它将 package main 编译为一个 go 插件，并可在运行时动态加载</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> greeting <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g greeting)</span></span> Greet() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Greeter greeting</span><br></pre></td></tr></table></figure><p>随后将其编译成为一个 go 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -buildmode=plugin -o greeter.so greeter.go</span><br></pre></td></tr></table></figure><p>最终再使用 golang 官方的 plugin 库来载入这个插件</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;plugin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Greeter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Greet()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//载入插件</span></span><br><span class="line">	plug, err := plugin.Open(<span class="string">&quot;./greeter.so&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//在插件中寻找对应的方法</span></span><br><span class="line">	symGreeter, err := plug.Lookup(<span class="string">&quot;Greeter&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> greeter Greeter</span><br><span class="line">	greeter, ok := symGreeter.(Greeter)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	greeter.Greet()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="go-install"><a class="header-anchor" href="#go-install">¶</a><code>go install</code></h2><div class="alert info no-icon"><p>命令 go install 用于编译并安装指定的代码包及它们的依赖包。当指定的代码包的依赖包还没有被编译和安装时，该命令会先去处理依赖包，随后再安装。</p></div><p>与 go build 命令一样，传给 go install 命令的代码包参数应该以导入路径的形式提供。并且，go build 命令的绝大多数标记也都可以用于 go install 命令。实际上，go install 命令只比 go build 命令多做了一件事，即：<strong>安装编译后的结果文件到指定目录</strong></p><h3 id="安装代码包"><a class="header-anchor" href="#安装代码包">¶</a>安装代码包</h3><p>如果 go install 命令后跟的代码包中仅包含库源码文件，那么 go install 命令会把「 编译后的结果 」文件保存在源码文件所在工作区的 pkg 目录下。对于仅包含库源码文件的代码包来说，这个结果文件就是将对应的代码包归档文件（也叫静态链接库文件，名称以.a 结尾）</p><p>相比之下，我们在使用 go build 命令对仅包含库源码文件的代码包进行编译时，是不会在当前工作区的 src 目录以及 pkg 目录下产生任何结果文件的。结果文件会出于编译的目的被生成在临时目录中，但并不会使当前工作区目录产生任何变化。</p><div class="alert success no-icon"><p>如果我们在执行 go install 命令时不后跟任何代码包参数，那么命令将试图编译当前目录所对应的代码包。如果指定了需要安装的代码包，首先会对指定代码包先编译，随后会将编译的结果安装到默认目录($GOPATH/pkg)下</p></div><div class="alert warning no-icon"><p>例如，在代码包 pkgtool 对应的目录下安装 cnet/ctcp，下面命令中我们使用了一个目录相对路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pineapple-man@localhost:~/golang/goc2p/src/pkgtool$ go install -a -v -work ../cnet/ctcp</span><br><span class="line">WORK=/tmp/go-build083178213</span><br></pre></td></tr></table></figure></div><p>实际上，这种提供代码包位置的方式被叫做本地代码包路径方式，也是被所有 Go 命令接受的一种方式，这包括之前已经介绍过的 go build 命令。但是需要注意的是，<span class="highlight-text red">本地代码包路径只能以目录相对路径的形式呈现，而不能使用目录绝对路径 </span>。请看下面的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pineapple-man@localhost:~/golang/goc2p/src/cnet/ctcp$ go install -v -work ~/golang/goc2p/src/cnet/ctcp</span><br><span class="line">can<span class="string">&#x27;t load package: package /home/pineapple-man/golang/goc2p/src/cnet/ctcp: import &quot;/home/pineapple-man/golang/goc2p/src/cnet/ctcp&quot;: cannot import absolute path</span></span><br></pre></td></tr></table></figure><p>以目录绝对路径的形式提供代码包位置是不会被 Go 命令认可的。这是由于 Go 认为本地代码包路径的表示只能以<code>./</code>或<code>../</code>开始，再或者直接为<code>.</code>或<code>..</code>，而代码包的代码导入路径又不允许以<code>/</code>开始。所以，这种用绝对路径表示代码包位置的方式也就不能被支持了，这个规则适用于所有 go 命令。</p><h3 id="安装命令源码文件"><a class="header-anchor" href="#安装命令源码文件">¶</a>安装命令源码文件</h3><div class="alert success no-icon"><p>除了安装代码包之外，go install 命令还可以安装命令源码文件。</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pineapple-man@localhost:~/golang/goc2p/src$ go install helper/ds/showds.go</span><br><span class="line">go install: no install location <span class="keyword">for</span> .go files listed on <span class="built_in">command</span> line (GOBIN not <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><p>在环境变量 GOPATH 中包含多个工作区目录路径时，我们需要在编译命令源码文件前先对环境变量 GOBIN 进行设置。实际上，这个环境变量所指的目录路径就是命令程序生成的结果文件的存放目录。go install 命令会把相应的可执行文件放置到这个目录中。</p><p>由于命令 go build 在编译库源码文件后不会产生任何结果文件，所以自然也不用会在意结果文件的存放目录。在该命令编译单一的命令源码文件或者包含一个命令源码文件和多个库源码文件时，在结果文件存放目录无效的情况下会将结果文件（也就是可执行文件）存放到执行该命令时所在的目录下。因此，即使环境变量 GOBIN 的值无效，我们在执行 go build 命令时也不会见到这个错误提示信息。</p><div class="alert success no-icon"><p>然而，go install 命令中一个很重要的步骤就是将结果文件（归档文件或者可执行文件）存放到相应的目录中。所以，go install 命令在安装命令源码文件时，如果环境变量 GOBIN 的值无效，则它会在最后检查结果文件存放目录的时候发现这一问题，并打印与上述示例所示内容类似的错误提示信息，最后直接退出。</p></div><p>而且，在我们为环境变量 GOBIN 设置了正确的值之后，这个错误提示信息仍然可能会出现。这是因为，只有在安装命令源码文件的时候，命令程序才会将环境变量 GOBIN 的值作为结果文件的存放目录。而在安装库源码文件时，在命令程序内部的代表结果文件存放目录路径的那个变量不会被赋值。最后，命令程序会发现它依然是个无效的空值。所以，命令程序会同样返回一个关于「 无安装位置 」的错误。这就引出一个结论，我们只能使用安装代码包的方式来安装库源码文件，而不能在 go install 命令罗列并安装它们。另外，go install 命令目前无法接受标记-o 以自定义结果文件的存放位置。这也从侧面说明了<span class="highlight-text red">go install 命令不支持针对库源码文件的安装操作</span>。</p><h2 id="go-get"><a class="header-anchor" href="#go-get">¶</a><code>go get</code></h2><div class="alert success no-icon"><p>命令<code>go get</code>可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。在上面这个示例中</p></div><p>为了分离自己与第三方的代码，我们会设置两个或更多的工作区。我们现在有一个目录路径为/home/pineapple-man/golang/lib 的工作区，并且它是环境变量 GOPATH 值中的第一个目录路径。注意，环境变量 GOPATH 中包含的路径不能与环境变量 GOROOT 的值重复。好了，如果我们使用 go get 命令下载和安装代码包，那么这些代码包都会被安装在上面这个工作区中。我们暂且把这个工作区叫做 Lib 工作区。</p><p>另一方面，如果我们想把一个项目上传到 Github 网站（或其他代码托管网站）上并被其他人使用的话，那么我们就应该把这个项目当做一个代码包来看待。其实我们在之前已经提到过原因，go get 命令会将项目下的所有子目录和源码文件存放到第一个工作区的 src 目录下，而 src 目录下的所有子目录都会是某个代码包导入路径的一部分或者全部。也就是说，我们应该直接在项目目录下存放子代码包和源码文件，并且直接存放在项目目录下的源码文件所声明的包名应该与该项目名相同（除非它是命令源码文件）。这样做可以让其他人使用 go get 命令从 Github 站点上下载你的项目之后直接就能使用它。</p><h3 id="远程导入路径分析"><a class="header-anchor" href="#远程导入路径分析">¶</a>远程导入路径分析</h3><p>实际上，go get 命令所做的动作也被叫做代码包远程导入，而传递给该命令的作为代码包导入路径的那个参数又被叫做代码包远程导入路径</p><p>go get 命令不仅可以从像 Github 这样著名的代码托管站点上下载代码包，还可以从任何命令支持的代码版本控制系统（英文为 Version Control System，简称为 VCS）检出代码包。任何代码托管站点都是通过某个或某些代码版本控制系统来提供代码上传下载服务的。所以，更严格地讲，go get 命令所做的是从代码版本控制系统的远程仓库中检出/更新代码包并对其进行编译和安装。</p><p>对于已存在于本地工作区的代码包，除非要求强行更新代码包，否则 go get 命令不会进行重复下载。如果想要强行更新代码包，可以在执行 go get 命令时加入-u 标记。</p><h2 id="go-clean"><a class="header-anchor" href="#go-clean">¶</a><code>go clean</code></h2><div class="alert info no-icon"><p>执行 go clean 命令会删除掉执行其它命令时产生的一些文件和目录，包括：</p><ol><li>在使用 go build 命令时在当前代码包下生成的与包名同名或者与 Go 源码文件同名的可执行文件。在 Windows 下，则是与包名同名或者 Go 源码文件同名且带有“.exe”后缀的文件</li><li>如果执行 go clean 命令时带有标记-i，则会同时删除安装当前代码包时所产生的结果文件。如果当前代码包中只包含库源码文件，则结果文件指的就是在工作区的 pkg 目录的相应目录下的归档文件。如果当前代码包中只包含一个命令源码文件，则结果文件指的就是在工作区的 bin 目录下的可执行文件。</li><li>如果执行 go clean 命令时带有标记-r，则还包括当前代码包的所有依赖包的上述目录和文件。</li></ol></div><h2 id="go-doc-godoc"><a class="header-anchor" href="#go-doc-godoc">¶</a><code>go doc</code> &amp; <code>godoc</code></h2><div class="alert info no-icon"><p>go doc 命令可以打印附于 Go 语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。</p></div><h2 id="go-run"><a class="header-anchor" href="#go-run">¶</a><code>go run</code></h2><div class="alert info no-icon"><p><code>go run</code> 命令用于运行命令源码文件</p></div><p>go run 命令可以编译并运行命令源码文件。由于它其中包含了编译动作，因此它也可以接受所有可用于 go build 命令的标记。除了标记之外，go run 命令只接受 Go 源码文件作为参数，而不接受代码包。与 go build 命令和 go install 命令一样，go run 命令也不允许多个命令源码文件作为参数，即使它们在同一个代码包中也是如此。</p><h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2><p><a target="_blank" rel="noopener" href="https://wiki.jikexueyuan.com/project/go-command-tutorial/0.1.html">go 命令教程</a></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/GO/" rel="tag">GO</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" data-tooltip="二分查找" aria-label="上一篇: 二分查找"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/java-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" data-tooltip="Java 程序运行原理分析" aria-label="下一篇: Java 程序运行原理分析"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" data-tooltip="二分查找" aria-label="上一篇: 二分查找"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/java-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" data-tooltip="Java 程序运行原理分析" aria-label="下一篇: Java 程序运行原理分析"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>