<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>分布式 ID 生成系统解决方案 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="分布式 id 生成器"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n¶概述\n❓什么是全局分布式 ID？\n在业务数据量不大的时候，单库单表完全可以支撑现有业务（这个时候想怎么实现就怎么实现）；当数据进一步增大，MySQL 就需要进行主从同步读写分离；随着数据日渐增长，主从同步也扛不住了，就需要对数据库进行分库分表，但分库分表后需要有一个唯一ID来标识一条数据，数据库的自增 ID 显然不能满足需求（容易产生 ID 冲突），如：订单、优惠券需要有唯一 ID 做标识。此时一个能够生成全局唯一ID的系统是非常必要的，这个全局唯一 ID 生成器就叫分布式 ID 生成系统\n\n❓为什么需要用全局分布式 ID？\n在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识。如在美团点评的金融、支付、餐饮、酒店、猫眼电影等产品的系统中，数据日渐增长，对数据分库分表后需要有一个唯一 ID 来标识一条数据或消息，数据库的自增 ID 显然不能满足需求；如订单、骑手、优惠券也都需要有唯一 ID 做标识。\n美团技术团队Leaf——美团点评分布式ID生成系统\n❓全局分布式 ID 要完成哪些功能？\n\n\n全局唯一性：不能出现重复的 ID 号，既然是唯一标识，这是最基本的要求\n\n\n趋势递增：在 MySQL InnoDB 引擎中使用的是聚集索引，由于多数 RDBMS 使用 B-tree 的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能\n\n\n单调递增：保证下一个 ID 一定大于上一个 ID，例如事务版本号、IM 增量消息、排序等特殊需求\n\n\n信息安全：如果 ID 是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定 URL 即可；如果是订单号就更危险了，所以在一些应用场景下，会需要 ID 无规则、不规则\n\n\n高可用性：除了对 ID 号码自身的要求，业务还对 ID 号生成系统的可用性要求极高，如果 ID 生成系统瘫痪，故障可能广播到整个系统\n\n\n分片支持：可以控制 ShardingId。比如某一个用户的文章要放在同一个分片内，这样查询效率高，修改也容易\n\n\n\n📓一个 ID 生成系统应该做到以下几点：平均延迟和 TP999 延迟都要尽可能低；可用性 5 个 9；高 QPS\n¶分布式 ID 生成方式\n✨常见的存在以下九种分布式 ID 生成方式：\n\n¶UUID\nUUID(Universally Unique Identifier)的标准型式包含 32 个 16 进制数字，以连字号分为五段，形式为8-4-4-4-12的 36 个字符，示例：550e8400-e29b-41d4-a716-446655440000，到目前为止业界一共有 5 种方式生成 UUID，详情见 IETF 发布的 UUID 规范A Universally Unique IDentifier (UUID) URN Namespace\n1234public static void main(String[] args) &#123;       String uuid = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;);       System.out.println(uuid); &#125;\n🆚优缺点分析\n👍性能非常高：本地生成，没有网络消耗\n😣缺点比较多\n\n不易于存储：UUID 太长，16 字节 128 位，通常以 36 长度的字符串表示，很多场景不适用\n信息不安全：基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置\nUUID 是无序的。不是单调递增的，而现阶段主流的数据库主键索引都是选用的 B+树索引，对于无序长度过长的主键插入效率比较低，传输数据量大，不可读\nUUID 往往是使用字符串存储，查询的效率比较低。\n\n\nAll indexes other than the clustered index are known as secondary indexes. In InnoDB, each record in a secondary index contains the primary key columns for the row, as well as the columns specified for the secondary index. InnoDB uses this primary key value to search for the row in the clustered index.If the primary key is long, the secondary indexes use more space, so it is advantageous to have a short primary key\nMySQL官方对主键建议\n📓UUID 的生成非常简单，但是并不适用于实际的业务需求。用作订单号这样的字符串没有丝毫的意义，看不出和订单相关的有用信息；对于数据库查询也非常不利，并不是非常推荐使用 UUID 作为分布式 ID 生成器\n¶基于数据库自增 ID\n基于数据库的auto_increment自增 ID 完全可以充当分布式 ID。具体实现：需要一个单独的 MySQL 实例用来生成 ID，建表结构如下：\n1234567CREATE DATABASE `SEQ_ID`;CREATE TABLE SEQID.SEQUENCE_ID (    id bigint(20) unsigned NOT NULL auto_increment,    value char(10) NOT NULL default &#x27;&#x27;,    PRIMARY KEY (id),) ENGINE=MyISAM;insert into SEQUENCE_ID(value)  VALUES (&#x27;values&#x27;);\n🆚优缺点分析\n👍非常简单，利用现有数据库系统的功能实现，成本小，有 DBA 专业维护;ID 号单调自增，可以实现一些对 ID 有特殊要求的业务\n😣强依赖 DB，当 DB 异常时整个系统不可用，属于致命问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号;ID 发号性能瓶颈限制在单台 MySQL 的读写性能\n\n📓当我们需要一个 ID 的时候，向表中插入一条记录返回主键 ID，但这种方式有一个比较致命的缺点，访问量激增时 MySQL 本身就是系统的瓶颈，用它来实现分布式服务风险比较大，不推荐！\n\n¶基于数据库集群模式\n单点数据库方式不可取，对上边的方式做一些高可用优化，换成主从模式集群。害怕一个主节点挂掉没法用，那就做双主模式集群，也就是两个 Mysql 实例都能单独的生产自增 ID。那这样还会有个问题，两个 MySQL 实例的自增 ID 都从 1 开始，会生成重复的 ID，可以使用如下方式解决：\n1234567TicketServer1:auto-increment-increment = 2auto-increment-offset = 1TicketServer2:auto-increment-increment = 2auto-increment-offset = 2\n假设我们要部署 N 台机器，步长需设置为 N，每台的初始值依次为 0,1,2…N-1 那么整个架构就变成了如下图所示：\n\n❓如果集群后的性能还是扛不住高并发咋办？\n进行 MySQL 扩容增加节点，这是一个比较麻烦的事。从上图可以看出，水平扩展的数据库集群，有利于解决数据库单点压力的问题，同时为了 ID 生成特性，将自增步长按照机器数量来设置。\n增加第三台MySQL实例需要人工修改一、二两台MySQL实例的起始值和步长，把第三台机器的ID起始生成位置设定在比现有最大自增ID的位置远一些，但必须在一、二两台MySQL实例ID 还没有增长到第三台MySQL实例的起始ID值，否则自增ID就要出现重复了，必要时可能还需要停机修改\n\n🆚优缺点分析\n👍解决 DB 单点故障问题\n😣这种方案弊端仍然非常明显：\n\n系统水平扩展比较困难\nID 没有了单调递增的特性，只能趋势递增，这个缺点对于一般业务需求不是很重要，可以容忍\n数据库压力还是很大，每次获取 ID 都得读写一次数据库，只能靠堆机器来提高性能\n\n\n¶基于数据库的号段模式\n号段模式是当下分布式 ID 生成器的主流实现方式之一，号段模式可以理解为从数据库批量的获取自增 ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表 1000 个 ID，具体的业务服务将本号段，生成 1~1000 的自增 ID 并加载到内存。表结构如下：\n12345678CREATE TABLE id_generator (  id int(10) NOT NULL,  max_id bigint(20) NOT NULL COMMENT &#x27;当前最大id&#x27;,  step int(20) NOT NULL COMMENT &#x27;号段的布长&#x27;,  biz_type\tint(20) NOT NULL COMMENT &#x27;业务类型&#x27;,  version int(20) NOT NULL COMMENT &#x27;版本号&#x27;,  PRIMARY KEY (`id`))\n\n\n\n字段\n含义\n\n\n\n\nbiz_type\n代表不同业务类型\n\n\nmax_id\n当前最大的可用 id\n\n\nstep\n代表号段的长度\n\n\nversion\n是一个乐观锁，每次都更新 version，保证并发时数据的正确性\n\n\n\n例如：生成的 ID 在数据库表中存储为如下信息：\n\n\n\nid\nbiz_type\nmax_id\nstep\nversion\n\n\n\n\n1\n101\n1000\n2000\n0\n\n\n\n等这批号段 ID 用完，再次向数据库申请新号段，对max_id字段做一次update操作，update max_id= max_id + step，update 成功则说明新号段获取成功，新的号段范围是(max_id ,max_id +step]、\n1update id_generator set max_id = #&#123;max_id+step&#125;, version = version + 1 where version = # &#123;version&#125; and biz_type = XXX\n由于多业务端可能同时操作，所以采用版本号version乐观锁方式更新，这种分布式ID生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多\n¶基于 Redis 模式\nRedis也同样可以实现，原理就是利用redis的 incr命令实现 ID 的原子性自增\n1234127.0.0.1:6379&gt; set seq_id 1     // 初始化自增ID为1OK127.0.0.1:6379&gt; incr seq_id      // 增加1，并返回递增后的数值(integer) 2\n✨用redis实现需要注意一点，要考虑到 redis 持久化的问题。redis有两种持久化方式RDB和AOF\n\n\nRDB会定时将一个快照进行持久化，假如连续自增但redis没及时持久化，而这会 Redis 挂掉了，重启 Redis 后会出现 ID 重复的情况\n\n\nAOF会对每条写命令进行持久化，即使Redis挂掉了也不会出现 ID 重复的情况，但由于 incr 命令的特殊性，会导致Redis重启恢复的数据时间过长\n\n\n\n¶雪花算法\n\n雪花算法（Snowflake）是 twitter 公司内部分布式项目采用的 ID 生成算法，最终生成的是占 8 个字节 Long 类型的 ID\nSnowflake ID 组成结构：正数位（占 1 比特）+ 时间戳（占 41 比特）+ 机器ID（占 5 比特）+ 数据中心（占 5 比特）+ 自增值（占 12 比特），总共 64 比特组成的一个 Long 类型\n\n\n第一个 bit 位（1bit）：Java 中 long 的最高位是符号位代表正负，正数是 0，负数是 1，一般生成 ID 都为正数，所以默认为 0\n\n\n时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的 ID 从更小的值开始；41 位的时间戳可以使用 69 年，(1L &lt;&lt; 41) / (1000L _ 60 _ 60 _ 24 _ 365) = 69 年\n\n\n工作机器 id（10bit）：也被叫做workId，这个可以灵活配置，机房或者机器号组合都可以。\n\n\n序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成 4096 个 ID\n\n\n\n¶百度（uid-generator）\nuid-generator是基于Snowflake算法实现的，与原始的 snowflake 算法不同在于，uid-generator 支持自定义时间戳、工作机器 ID和序列号等各部分的位数，而且uid-generator中采用用户自定义workId的生成策略\n¶美团（Leaf）\nLeaf同时支持号段模式和snowflake算法模式，可以切换使用\n¶号段模式\n1234567891011DROP TABLE IF EXISTS `leaf_alloc`;CREATE TABLE `leaf_alloc` (  `biz_tag` varchar(128)  NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;业务key&#x27;,  `max_id` bigint(20) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;当前已经分配了的最大id&#x27;,  `step` int(11) NOT NULL COMMENT &#x27;初始步长，也是动态调整的最小步长&#x27;,  `description` varchar(256)  DEFAULT NULL COMMENT &#x27;业务key的描述&#x27;,  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;数据库维护的更新时间&#x27;,  PRIMARY KEY (`biz_tag`)) ENGINE=InnoDB;\n然后在项目中开启号段模式，配置对应的数据库信息，并关闭snowflake模式，字段模式大致架构如下：\n\n¶snowflake 模式\nLeaf的 snowflake 模式依赖于ZooKeeper，与原始 snowflake 算法在workId的生成上不同。Leaf中workId是基于ZooKeeper的顺序 Id 来生成的，每个应用在使用Leaf-snowflake时，启动时都会都在Zookeeper中生成一个顺序 Id，相当于一台机器对应一个顺序节点，也就是一个workId\n¶滴滴（Tinyid）\nTinyid是基于号段模式原理实现的与Leaf如出一辙，这里不给出详细使用方式\n¶附录\nLeaf——美团点评分布式 ID 生成系统\n一口气说出 9 种分布式 ID 生成方式，面试官有点懵了\n","dateCreated":"2021-11-11T15:09:00+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2021-11-11T15:09:00+00:00","description":"本文主要总结目前常用的分布式ID生成器的解决方案","headline":"分布式 ID 生成系统解决方案","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/%E5%88%86%E5%B8%83%E5%BC%8F-id-%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/%E5%88%86%E5%B8%83%E5%BC%8F-id-%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","keywords":"分布式组件"}</script><meta name="description" content="本文主要总结目前常用的分布式ID生成器的解决方案"><meta property="og:type" content="blog"><meta property="og:title" content="分布式 ID 生成系统解决方案"><meta property="og:url" content="https://pineapple-man.github.io/%E5%88%86%E5%B8%83%E5%BC%8F-id-%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="本文主要总结目前常用的分布式ID生成器的解决方案"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/others/%E5%88%86%E5%B8%83%E5%BC%8FID/%E5%88%86%E5%B8%83%E5%BC%8Fid_0.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/others/%E5%88%86%E5%B8%83%E5%BC%8FID/%E5%88%86%E5%B8%83%E5%BC%8Fid_3.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/others/%E5%88%86%E5%B8%83%E5%BC%8FID/%E5%88%86%E5%B8%83%E5%BC%8Fid_2.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/others/%E5%88%86%E5%B8%83%E5%BC%8FID/%E5%88%86%E5%B8%83%E5%BC%8Fid_4.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/others/%E5%88%86%E5%B8%83%E5%BC%8FID/%E5%88%86%E5%B8%83%E5%BC%8Fid_1.png"><meta property="article:published_time" content="2021-11-11T15:09:00.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.003Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="分布式组件"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/others/%E5%88%86%E5%B8%83%E5%BC%8FID/%E5%88%86%E5%B8%83%E5%BC%8Fid_0.jpg"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">分布式 ID 生成系统解决方案</h1><div class="post-meta"><time datetime="2021-11-11T15:09:00+00:00">11月 11, 2021 </time><span>发布在 </span><a class="category-link" href="/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">解决方案</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 3.3k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 32 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-ID-%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F"><span class="toc-text">分布式 ID 生成方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UUID"><span class="toc-text">UUID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%A2%9E-ID"><span class="toc-text">基于数据库自增 ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-text">基于数据库集群模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8F%B7%E6%AE%B5%E6%A8%A1%E5%BC%8F"><span class="toc-text">基于数据库的号段模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-Redis-%E6%A8%A1%E5%BC%8F"><span class="toc-text">基于 Redis 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95"><span class="toc-text">雪花算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BE%E5%BA%A6%EF%BC%88uid-generator%EF%BC%89"><span class="toc-text">百度（uid-generator）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BE%8E%E5%9B%A2%EF%BC%88Leaf%EF%BC%89"><span class="toc-text">美团（Leaf）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B7%E6%AE%B5%E6%A8%A1%E5%BC%8F"><span class="toc-text">号段模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#snowflake-%E6%A8%A1%E5%BC%8F"><span class="toc-text">snowflake 模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%B4%E6%BB%B4%EF%BC%88Tinyid%EF%BC%89"><span class="toc-text">滴滴（Tinyid）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol><h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><p>❓什么是全局分布式 ID？</p><div class="alert success no-icon"><p>在业务数据量不大的时候，单库单表完全可以支撑现有业务（这个时候想怎么实现就怎么实现）；当数据进一步增大，MySQL 就需要进行<strong>主从同步读写分离</strong>；随着数据日渐增长，主从同步也扛不住了，就需要对数据库进行<strong>分库分表</strong>，但分库分表后需要有一个<code>唯一ID</code>来标识一条数据，数据库的自增 ID 显然不能满足需求（容易产生 ID 冲突），如：订单、优惠券需要有唯一 ID 做标识。此时一个能够生成<code>全局唯一ID</code>的系统是非常必要的，这个<strong>全局唯一 ID 生成器</strong>就叫<strong>分布式 ID 生成系统</strong></p></div><p>❓为什么需要用全局分布式 ID？</p><blockquote><p>在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识。如在美团点评的金融、支付、餐饮、酒店、猫眼电影等产品的系统中，数据日渐增长，对数据分库分表后需要有一个唯一 ID 来标识一条数据或消息，数据库的自增 ID 显然不能满足需求；如订单、骑手、优惠券也都需要有唯一 ID 做标识。</p><footer><strong>美团技术团队</strong><cite><a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf——美团点评分布式ID生成系统</a></cite></footer></blockquote><p>❓全局分布式 ID 要完成哪些功能？</p><div class="alert success no-icon"><ul><li><p>全局唯一性：不能出现重复的 ID 号，既然是唯一标识，这是最基本的要求</p></li><li><p>趋势递增：在 MySQL InnoDB 引擎中使用的是聚集索引，由于多数 RDBMS 使用 B-tree 的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能</p></li><li><p>单调递增：保证下一个 ID 一定大于上一个 ID，例如事务版本号、IM 增量消息、排序等特殊需求</p></li><li><p>信息安全：如果 ID 是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定 URL 即可；如果是订单号就更危险了，所以在一些应用场景下，会需要 ID 无规则、不规则</p></li><li><p>高可用性：除了对 ID 号码自身的要求，业务还对 ID 号生成系统的可用性要求极高，如果 ID 生成系统瘫痪，故障可能广播到整个系统</p></li><li><p>分片支持：可以控制 ShardingId。比如某一个用户的文章要放在同一个分片内，这样查询效率高，修改也容易</p></li></ul></div><p>📓一个 ID 生成系统应该做到以下几点：平均延迟和 TP999 延迟都要尽可能低；可用性 5 个 9；高 QPS</p><h2 id="分布式-ID-生成方式"><a class="header-anchor" href="#分布式-ID-生成方式">¶</a>分布式 ID 生成方式</h2><p>✨常见的存在以下九种分布式 ID 生成方式：</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/others/分布式ID/分布式id_0.jpg" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/others/分布式ID/分布式id_0.jpg" alt=""></a></div><h3 id="UUID"><a class="header-anchor" href="#UUID">¶</a>UUID</h3><p>UUID(Universally Unique Identifier)的标准型式包含 32 个 16 进制数字，以连字号分为五段，形式为<code>8-4-4-4-12</code>的 36 个字符，示例：<code>550e8400-e29b-41d4-a716-446655440000</code>，到目前为止业界一共有 5 种方式生成 UUID，详情见 IETF 发布的 UUID 规范<a target="_blank" rel="noopener" href="https://www.ietf.org/rfc/rfc4122.txt">A Universally Unique IDentifier (UUID) URN Namespace</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">       System.out.println(uuid);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>🆚优缺点分析</p><div class="alert success no-icon"><p>👍性能非常高：本地生成，没有网络消耗<br>😣缺点比较多</p><ul><li>不易于存储：UUID 太长，16 字节 128 位，通常以 36 长度的字符串表示，很多场景不适用</li><li>信息不安全：基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置</li><li>UUID 是无序的。不是单调递增的，而现阶段主流的数据库主键索引都是选用的 B+树索引，对于无序长度过长的主键插入效率比较低，传输数据量大，不可读</li><li>UUID 往往是使用字符串存储，查询的效率比较低。</li></ul></div><blockquote><p>All indexes other than the clustered index are known as secondary indexes. In InnoDB, each record in a secondary index contains the primary key columns for the row, as well as the columns specified for the secondary index. InnoDB uses this primary key value to search for the row in the clustered index.<strong><em>If the primary key is long, the secondary indexes use more space, so it is advantageous to have a short primary key</em></strong></p><footer><strong>MySQL官方对主键建议</strong></footer></blockquote><p>📓UUID 的生成非常简单，但是并不适用于实际的业务需求。用作订单号这样的字符串没有丝毫的意义，看不出和订单相关的有用信息；对于数据库查询也非常不利，并不是非常推荐使用 UUID 作为分布式 ID 生成器</p><h3 id="基于数据库自增-ID"><a class="header-anchor" href="#基于数据库自增-ID">¶</a>基于数据库自增 ID</h3><p>基于数据库的<code>auto_increment</code>自增 ID 完全可以充当<strong>分布式 ID</strong>。具体实现：需要一个单独的 MySQL 实例用来生成 ID，建表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `SEQ_ID`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SEQID.SEQUENCE_ID (</span><br><span class="line">    id <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment,</span><br><span class="line">    <span class="keyword">value</span> <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SEQUENCE_ID(<span class="keyword">value</span>)  <span class="keyword">VALUES</span> (<span class="string">&#x27;values&#x27;</span>);</span><br></pre></td></tr></table></figure><p>🆚优缺点分析</p><div class="alert success no-icon"><p>👍非常简单，利用现有数据库系统的功能实现，成本小，有 DBA 专业维护;ID 号单调自增，可以实现一些对 ID 有特殊要求的业务<br>😣强依赖 DB，当 DB 异常时整个系统不可用，属于致命问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号;ID 发号性能瓶颈限制在单台 MySQL 的读写性能</p></div><p>📓当我们需要一个 ID 的时候，向表中插入一条记录返回主键 ID，但这种方式有一个比较致命的缺点，访问量激增时 MySQL 本身就是系统的瓶颈，用它来实现分布式服务风险比较大，不推荐！</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/others/分布式ID/分布式id_3.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/others/分布式ID/分布式id_3.png" alt=""></a></div><h3 id="基于数据库集群模式"><a class="header-anchor" href="#基于数据库集群模式">¶</a>基于数据库集群模式</h3><p>单点数据库方式不可取，对上边的方式做一些高可用优化，换成主从模式集群。害怕一个主节点挂掉没法用，那就做双主模式集群，也就是两个 Mysql 实例都能单独的生产自增 ID。那这样还会有个问题，两个 MySQL 实例的自增 ID 都从 1 开始，会生成重复的 ID，可以使用如下方式解决：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TicketServer1:</span><br><span class="line">auto<span class="operator">-</span>increment<span class="operator">-</span>increment <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">auto<span class="operator">-</span>increment<span class="operator">-</span><span class="keyword">offset</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">TicketServer2:</span><br><span class="line">auto<span class="operator">-</span>increment<span class="operator">-</span>increment <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">auto<span class="operator">-</span>increment<span class="operator">-</span><span class="keyword">offset</span> <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>假设我们要部署 N 台机器，步长需设置为 N，每台的初始值依次为 0,1,2…N-1 那么整个架构就变成了如下图所示：</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/others/分布式ID/分布式id_2.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/others/分布式ID/分布式id_2.png" alt=""></a></div><p>❓如果集群后的性能还是扛不住高并发咋办？</p><div class="alert success no-icon"><p>进行 MySQL 扩容增加节点，这是一个比较麻烦的事。从上图可以看出，水平扩展的数据库集群，有利于解决数据库单点压力的问题，同时为了 ID 生成特性，将自增步长按照机器数量来设置。</p><p>增加第三台<code>MySQL</code>实例需要人工修改一、二两台<code>MySQL实例</code>的起始值和步长，把<code>第三台机器的ID</code>起始生成位置设定在比现有<code>最大自增ID</code>的位置远一些，但必须在一、二两台<code>MySQL实例</code>ID 还没有增长到<code>第三台MySQL实例</code>的<code>起始ID</code>值，否则<code>自增ID</code>就要出现重复了，<strong>必要时可能还需要停机修改</strong></p></div><p>🆚优缺点分析</p><div class="alert success no-icon"><p>👍解决 DB 单点故障问题<br>😣这种方案弊端仍然非常明显：</p><ul><li>系统水平扩展比较困难</li><li>ID 没有了单调递增的特性，只能趋势递增，这个缺点对于一般业务需求不是很重要，可以容忍</li><li>数据库压力还是很大，每次获取 ID 都得读写一次数据库，只能靠堆机器来提高性能</li></ul></div><h3 id="基于数据库的号段模式"><a class="header-anchor" href="#基于数据库的号段模式">¶</a>基于数据库的号段模式</h3><p>号段模式是当下分布式 ID 生成器的主流实现方式之一，号段模式可以理解为从数据库批量的获取自增 ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表 1000 个 ID，具体的业务服务将本号段，生成 1~1000 的自增 ID 并加载到内存。表结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE id_generator (</span><br><span class="line">  id int(10) NOT NULL,</span><br><span class="line">  max_id bigint(20) NOT NULL COMMENT &#x27;当前最大id&#x27;,</span><br><span class="line">  step int(20) NOT NULL COMMENT &#x27;号段的布长&#x27;,</span><br><span class="line">  biz_type	int(20) NOT NULL COMMENT &#x27;业务类型&#x27;,</span><br><span class="line">  version int(20) NOT NULL COMMENT &#x27;版本号&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">biz_type</td><td style="text-align:center">代表不同业务类型</td></tr><tr><td style="text-align:center">max_id</td><td style="text-align:center">当前最大的可用 id</td></tr><tr><td style="text-align:center">step</td><td style="text-align:center">代表号段的长度</td></tr><tr><td style="text-align:center">version</td><td style="text-align:center">是一个乐观锁，每次都更新 version，保证并发时数据的正确性</td></tr></tbody></table><p>例如：生成的 ID 在数据库表中存储为如下信息：</p><table><thead><tr><th>id</th><th>biz_type</th><th>max_id</th><th>step</th><th>version</th></tr></thead><tbody><tr><td>1</td><td>101</td><td>1000</td><td>2000</td><td>0</td></tr></tbody></table><p>等这批号段 ID 用完，再次向数据库申请新号段，对<code>max_id</code>字段做一次<code>update</code>操作，<code>update max_id= max_id + step</code>，update 成功则说明新号段获取成功，新的号段范围是<code>(max_id ,max_id +step]</code>、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update id_generator set max_id = #&#123;max_id+step&#125;, version = version + 1 where version = # &#123;version&#125; and biz_type = XXX</span><br></pre></td></tr></table></figure><p>由于多业务端可能同时操作，所以采用版本号<code>version</code>乐观锁方式更新，这种<code>分布式ID</code>生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多</p><h3 id="基于-Redis-模式"><a class="header-anchor" href="#基于-Redis-模式">¶</a>基于 Redis 模式</h3><p><code>Redis</code>也同样可以实现，原理就是利用<code>redis</code>的 <code>incr</code>命令实现 ID 的原子性自增</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set seq_id 1     // 初始化自增ID为1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr seq_id      // 增加1，并返回递增后的数值</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p>✨用<code>redis</code>实现需要注意一点，要考虑到 redis 持久化的问题。<code>redis</code>有两种持久化方式<code>RDB</code>和<code>AOF</code></p><div class="alert success no-icon"><ul><li><p><code>RDB</code>会定时将一个快照进行持久化，假如连续自增但<code>redis</code>没及时持久化，而这会 Redis 挂掉了，重启 Redis 后会出现 ID 重复的情况</p></li><li><p><code>AOF</code>会对每条写命令进行持久化，即使<code>Redis</code>挂掉了也不会出现 ID 重复的情况，但由于 incr 命令的特殊性，会导致<code>Redis</code>重启恢复的数据时间过长</p></li></ul></div><h3 id="雪花算法"><a class="header-anchor" href="#雪花算法">¶</a>雪花算法</h3><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/others/分布式ID/分布式id_4.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/others/分布式ID/分布式id_4.png" alt=""></a></div><p>雪花算法（Snowflake）是 twitter 公司内部分布式项目采用的 ID 生成算法，最终生成的是占 8 个字节 Long 类型的 ID</p><div class="alert success no-icon"><p>Snowflake ID 组成结构：<code>正数位</code>（占 1 比特）+ <code>时间戳</code>（占 41 比特）+ <code>机器ID</code>（占 5 比特）+ <code>数据中心</code>（占 5 比特）+ <code>自增值</code>（占 12 比特），总共 64 比特组成的一个 Long 类型</p><ul><li><p>第一个 bit 位（1bit）：Java 中 long 的最高位是符号位代表正负，正数是 0，负数是 1，一般生成 ID 都为正数，所以默认为 0</p></li><li><p>时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的 ID 从更小的值开始；41 位的时间戳可以使用 69 年，(1L &lt;&lt; 41) / (1000L _ 60 _ 60 _ 24 _ 365) = 69 年</p></li><li><p>工作机器 id（10bit）：也被叫做<code>workId</code>，这个可以灵活配置，机房或者机器号组合都可以。</p></li><li><p>序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成 4096 个 ID</p></li></ul></div><h3 id="百度（uid-generator）"><a class="header-anchor" href="#百度（uid-generator）">¶</a>百度（uid-generator）</h3><p><code>uid-generator</code>是基于<code>Snowflake</code>算法实现的，与原始的 snowflake 算法不同在于，uid-generator 支持自<strong>定义时间戳</strong>、<strong>工作机器 ID</strong>和<strong>序列号</strong>等各部分的位数，而且<code>uid-generator</code>中采用用户自定义<code>workId</code>的生成策略</p><h3 id="美团（Leaf）"><a class="header-anchor" href="#美团（Leaf）">¶</a>美团（Leaf）</h3><p><code>Leaf</code>同时支持号段模式和<code>snowflake</code>算法模式，可以切换使用</p><h4 id="号段模式"><a class="header-anchor" href="#号段模式">¶</a>号段模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `leaf_alloc`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `leaf_alloc` (</span><br><span class="line">  `biz_tag` varchar(128)  NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;业务key&#x27;,</span><br><span class="line">  `max_id` bigint(20) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;当前已经分配了的最大id&#x27;,</span><br><span class="line">  `step` int(11) NOT NULL COMMENT &#x27;初始步长，也是动态调整的最小步长&#x27;,</span><br><span class="line">  `description` varchar(256)  DEFAULT NULL COMMENT &#x27;业务key的描述&#x27;,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;数据库维护的更新时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`biz_tag`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在项目中开启<code>号段模式</code>，配置对应的数据库信息，并关闭<code>snowflake</code>模式，字段模式大致架构如下：</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/others/分布式ID/分布式id_1.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/others/分布式ID/分布式id_1.png" alt=""></a></div><h4 id="snowflake-模式"><a class="header-anchor" href="#snowflake-模式">¶</a>snowflake 模式</h4><p><code>Leaf</code>的 snowflake 模式依赖于<code>ZooKeeper</code>，与原始 snowflake 算法在<code>workId</code>的生成上不同。<code>Leaf</code>中<code>workId</code>是基于<code>ZooKeeper</code>的顺序 Id 来生成的，每个应用在使用<code>Leaf-snowflake</code>时，启动时都会都在<code>Zookeeper</code>中生成一个顺序 Id，相当于一台机器对应一个顺序节点，也就是一个<code>workId</code></p><h3 id="滴滴（Tinyid）"><a class="header-anchor" href="#滴滴（Tinyid）">¶</a>滴滴（Tinyid）</h3><p><code>Tinyid</code>是基于号段模式原理实现的与<code>Leaf</code>如出一辙，这里不给出详细使用方式</p><h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf——美团点评分布式 ID 生成系统</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904065747402759">一口气说出 9 种分布式 ID 生成方式，面试官有点懵了</a></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/" rel="tag">分布式组件</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" data-tooltip="单调队列" aria-label="上一篇: 单调队列"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/cdn%E8%AF%A6%E8%A7%A3/" data-tooltip="CDN详解" aria-label="下一篇: CDN详解"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" data-tooltip="单调队列" aria-label="上一篇: 单调队列"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/cdn%E8%AF%A6%E8%A7%A3/" data-tooltip="CDN详解" aria-label="下一篇: CDN详解"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>