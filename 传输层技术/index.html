<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>传输层技术 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="传输层"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n¶传输层协议\n传输层对应用层提供进程到进程的通信支持，为了能够做到进程间通信，传输层使用了端口。能够将发送端某个进程的报文封装成段，传送到接收端对应进程中。\n✨传输层特点\n\n此层只有两个协议，即 UDP 和 TCP\n除了提供段传送功能外，还提供了复用/解复用、差错检测功能\n\n\n❓ 复用和解复用是什么意思？\n\n复用的含义是：应用层不同进程的报文在传输层封装成不同的段传送到网络，信息在传输层不会混合在一起\n解复用的含义是：到达接收端传输层的段，按照目的端口号分别送给各自的进程，不会送错\n\n\n📖 TCP 和 UDP 协议只运行在端系统上，提供全双工的通信，当路由器的角色是端系统时，它也有传输层和应用层，也要运行这两个协议\n¶UDP\nUDP（User Datagram Protocol）是用户数据报协议，这是一个非常简单的协议，和下层的 IP 相比，就多了一个端口号承载功能。所以，它和 IP 协议一样，服务模型都是尽力而为\n✨UDP 协议特点\n\nUDP 提供的是无连接、不可靠的服务，直接传送段，不需要先建立连接\n协议简单、报文段头小、比 TCP 快\n\n\n📖UDP 发送的前后段之间没有依赖关系，UDP 的段可能丢失，也可能乱序（后发的段先到达接收端进程），当然也可能出现差错。出现这些问题时，UDP 并没有提供问题恢复的功能\n¶报文格式\nUDP 的段头只有 8 个字节，分为四个字段，每个字段都是两个字节长：源端口号、目的端口号、长度（单位是字节）和校验和（checksum）\n🎶校验和字段是多余的,对于每个段的传送，源端和目的端都会进行校验和计算和验证，这会增加端到端的传送时延\n🤔为什么校验和是多余的 ？\n\nUDP 通信允许丢包和出现差错，即便出现差错也不会去处理\n如果传输过程中出现差错，数据链路层就会把包含差错的帧丢弃，不会再向上层传送\n凡是送达传输层的段，都是没有差错的\n\n\n¶基于 UDP 的应用\n\n\n\n局域网典型的 UDP 应用\n\n\n\n\n远程文件系统（NFS）\n\n\n网络管理（SNMP）\n\n\n动态主机配置（DHCP）\n\n\n简单文件传输（TFTP， trivial FTP）\n\n\n\n🎶这些应用都是面向局域网的，对实时性和可靠性均有较高的要求。局域网通信一般不太会丢包，使用 UDP 可以大体上保证实时性\n\n\n\nInternet 典型的 UDP 应用\n\n\n\n\n流媒体（音视频点播）\n\n\n可视电话\n\n\n域名服务（DNS）\n\n\n路由信息协议（RIP）\n\n\n路由跟踪（Tracert 网络命令）\n\n\n多播应用\n\n\n基于 RTP 的实时应用\n\n\n\n¶TCP\nTCP 是传输控制协议（Transport Control Protocol），仅支持点对点通信，提供面向连接的，可靠的、字节有序的信息传输服务。\nTCP 包含四个主要技术：可靠性控制、流量控制、拥塞控制和连接管理\n¶报文格式\nTCP 的段头是 20 个字节长，缺省的 TCP 最大段长固定为 536 字节， 这意味着一个 TCP 段的负载最多是 516 字节\n\n\n\n报文\n含义\n\n\n\n\nHead length\n段头长度，占 4 位，可区别 16 个字\n\n\n6 位是保留位\n没有使用\n\n\nU 是 Urgent 的字头\n紧急位，表示这个段需要立即向上层传送，实际当中没有使用\n\n\nA 是确认段标记\nA=1，表示这个段是确认段\n\n\nP 是 Push 的字头\n含义和 U 类似，表示立即向下传送，实际当中没有使用\n\n\nR、 S、 F 三个位跟连接管理有关\nR=1 表示重新建立连接； S=1 表示这个段是同步段，S=0 表示连接建立结束 F=1 表示连接关闭\n\n\nRcvr window size\n接收窗口，即接收端的空闲缓存。发送端基于这个值来控制发送速率，以免造成接收端因接收缓存溢出而丢包\n\n\nchecksum 字段\n存放 16 位的校验和,接收端据此来判断所接收的段里是否有差错。实践当中没有使用\n\n\nptr urgent data\n16 位，存放紧急数据的指针，实践当中没有使用\n\n\n可变长的选项字段，\n存放需要协商的最大段长、时间戳、窗口的变化因子实际当中没有使用\n\n\n\n\n¶可靠性控制\nTCP 可靠性控制的基本思想是：丢包重传，即发送端发现哪个段丢失了，就重传哪个段\n✨TCP 实现可靠传送的要求：\n\n发送端必须开辟缓存，缓存发送出去段，保证段丢失了可以重发这些段\n发送端和接收端需要相互协作（要有确认机制，告诉发送端它收到了那些段；发送端要有计时机制，一旦确认段丢失，也能发现有段丢失）\n使用段序号对所发送的段进行编号，以便发送端能确定是哪些段丢了\n\n\n¶发送端可靠算法\n\n发送端开辟的缓存称之为发送窗口 ，需要几个变量来维护这个窗口。\n\n\n\n变量\n含义\n\n\n\n\nsend_base\n基指针，指向发送窗口的最左侧的段收到一个确认段时， 基指针就右移到确认段中确认号指向的段、这意味着接收端确认段之前所有的段都已经收到了\n\n\nnextseqnum\n可以使用的下一个段序号，发送端每封装一个段，nextseqnum 就右移一位\n\n\nN\n窗口的大小，当发送窗口满时，停止发送\n\n\n\n¶接收端确认产生算法\n✨TCP 累积确认机制\n\nTCP 接收端返回确认段的确认号始终是它期待那个段的段序号\n\n📚累积确认，将告诉发送端两件事\n\n当前段之前所有的段都接受到了\n期待当前段序号的段\n\n\n接收端是有接收窗口的，用以存放所收到的失序的段\n\n\n\n变量\n含义\n\n\n\n\nrcv_base\n基指针，始终指向期待接收的段。如果基指针指向的段到了，基指针就会右移到所期待的段\n\n\nN\n接收窗口的大小，当接收窗口满时，新到的段就被丢弃\n\n\n\n\nTCP ACK 产生机制\n\n\n\n事件\n接收端动作\n\n\n\n\n按序到到达一个段，没有间隙前面所有的段都已确认\n延迟确认，做最多 500 ms 的延时，等待下一个段。如果下一个段未到，延时结束时发送 ACK\n\n\n按序到达一个段，没有间隙前面一个正在做延时\n立即发送 ACK，累积确认\n\n\n乱序到达一个段，段序号比期待的段序号高，检测到间隙\n重发 ACK，确认号还是期待段的段序号\n\n\n到达一个段，位于接受窗口的间隙中\n立即给出确认如果位于最左侧的间隙，右移接收窗口的基指针否则，标记该段接受\n\n\n\nTCP 可靠重传算法\n\n🤔如何保证 TCP 的全双工可靠通信？\n\nTCP 发送端的可靠性控制算法在接收端部署一份\n接收端的确认产生算法在发送端也部署一份\n\n¶计时器间隔设置\nTCP 发送端每发送一个段，就会启动一个逻辑计时器， 对这个段进行计时， 在发送端确定是否需要重传\n🤔这个计时器的触发间隔应该是多长呢？\n\n太长，对丢包的响应很慢，影响通信效率\n太短，会出现假丢包现象，造成大量不必要的重传，浪费网络带宽资源\n理想情况，应能反映最近未来的网络状况，应该比接下来的那个 RTT 略大一点，同时又具有较好的平滑性，避免频繁地设置计时器\n\n如果我们把未来这个 RTT 值定义为 EstimatedRTT， TCP 预测 EstimatedRTT 使用的是“加权运动平均”模型， 这个模型使用了很多次历史测量的 RTT 值，而不是只使用刚刚测量的那个 RTT 值。\n$EstimatedRTT_n = (1-x)EstimatedRTT_{n-1} + xSampleRTT$\n\n\n\n变量\n含义\n\n\n\n\n$SampleRTT$\n刚刚测量的 RTT 值\n\n\n$EstimatedRTT_{n-1}$\n上一次的预测值\n\n\n$x$\n经验值，通常为$0.125$\n\n\n\n当网络状态波动大时，偏差值 Deviation 也大；\n当网络状态波动小时， Deviation 也小。\n因此，实际设定的间隔值 Timeout 具有自适应性，能自适应网络的忙闲状况。\n¶流量控制\n🤔为什么需要流量控制 ?\n\nTCP 的接收端的段处理速度有可能比较慢，这就容易造成接收缓存溢出，导致接收端的传输层丢包\n\n🤔如何达成流量控制 ?\n\n🎶发送端的发送速率和目的端的处理速率匹配起来，对发送端的发送速率进行控制，使得既不会导致接收端丢包，也不会导致发送端发送速率过慢影响通信效率\n\n👴本质上，TCP 流量控制就是——速率匹配机制\nTCP 的流控机制使用了一个重要参数： $RcvWindow$，表示空闲的接收缓存大小\n$$\n\\text{RcvWindow}= \\text{RcvBuffer}-(\\text{LastByteRcvd}-\\text{LastByteRead})\n$$\n\n\n\n变量\n含义\n\n\n\n\n$\\text{RcvBuffer}$\n接收缓存\n\n\n$\\text{LastByteRcvd}$\n所接收的、最后的字节数\n\n\n$\\text{LastByteRead}$\n传送给应用层的最后字节数\n\n\n$\\text{LastByteRcvd}-\\text{LastByteRead}$\n被占据的接收缓存空间\n\n\n\n$\\text{LastByteRcvd}-\\text{LastByteRead}$参数是动态变化的，伴随着确认段的返回，通过段头不断地反馈给源端。源端据此来控制自己的发送速率：所发送的、尚未被确认的数据量不超过 $\\text{RcvWindow}$\n\n$\\text{Initially}, \\text{RcvWindow}=\\text{RcvBuffer}$\n$\\text{LastByteSent}-\\text{LastByteAcked}&lt;=\\text{RcvWindow}$\nWhen $\\text{RcvWindow}=0$ , one byte data is still sent to the receiver；\n\n🤔为什么接收区缓存满了之后，还需要发送一个比特的数据尼？\n\n接收缓存满时，如果停止发送数据，很容易导致通信停止（如果一直接收不到确认信\n息，通信就终止了，即便接收缓存变空，源端也感知不到）\n所以，即便接收缓存满了仍然发送一个字节的数据（段大小是 21 个字节）。\n当这个段到达接收端时，即便接收缓存腾出一点空间，这个段也能存放进去，接收端就会返回一个确认段，确认段中包含有最新的 $RcvWindow$ 值，通信就不会终止\n如果这个很小的段到达接收端，接收缓存仍然是满的，这个段被丢弃掉，损失也不大\n\n这个算法还可以进一步优化。\n在目前 TCP 的控制算法中，源端的数据发送量是根据半个 RTT 之前接收端的空闲接收缓存大小决定的，而真正想匹配的却是半个 RTT 之后接收端接收缓存的大小。这实际上是存在一个 RTT 的时差的，在这一个 RTT 内，空闲的接收缓存大小很可能发生变化了。 如果源端能根据接收端反馈的 RcvWindow 值， 通过预测模型（如加权运动平均模型） 来预测半个 RTT 之后的 RcvWindow 大小，就能提高匹配的精度，提高\nTCP 的通信效率。\n¶连接管理\n连接管理主要包括连接建立和连接关闭\nTCP 在通信之前必须要先建立连接（这个连接是逻辑上的，只存在于两个端系统之上）\n🎶建立连接的目的是\n\n两个端系统开辟缓存（发送缓存和接收缓存）\n设置控制所用的变量\n交换初始的段序号\n\n¶三次握手（连接建立）\n\n\n客户端向服务器端发送同步段及进行连接请求，段头里包含有初始段序号，同步位S=1\n服务器端给出连接确认，返回同意连接 的同步段，段头里包含有服务器端随机选取的初始段序号，同步位 S=1、确认号=客户端发送的初始段序号+1，之后服务器开辟缓存，设置相关变量\n客户端返回一个确认段，其中S=0，段序号=初始段序号+1，确认号=服务器端发送的初始段序号+1,随后客户端开辟缓存，设置相关变量。\n\n🎶三次握手的过程中，所交换段的负载域均为空\n\n🤔为什么是三次握手？而不是四次或者两次？\n\n\n\nThe Priciple reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion. ——RFC 793\n首要原因就是防止旧的重复连接初始化造成混乱\n\n\n\n同步双方初始序列号\n\n\n避免资源浪费\n\n\n¶三次握手原因一\n\n客户端连续发送多次 SYN 建立连接的报文，在网络拥堵情况下：\n\n一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；\n那么此时服务端就会回一个 SYN + ACK 报文给客户端；\n客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。\n\n如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：\n\n如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 RST 报文，以此中止历史连接；\n如果不是历史连接，则第三次发送的报文是 ACK 报文，通信双方就会成功建立连接；\n\n所以，TCP 使用三次握手建立连接的最主要原因是防止历史连接初始化了连接。\n¶三次握手原因二\nTCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：\n\n接收方可以去除重复的数据\n接收方可以根据数据包的序列号按序接收\n可以标识发送出去的数据包中， 哪些是已经被对方收到的\n\n当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。\n✨四次握手、三次握手、二次握手\n\n四次握手其实也能够可靠的同步双方的初始化序号，但由于第二步和第三步可以优化成一步，所以就成了「三次握手」\n两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收\n\n¶三次握手原因三\n如果只有「两次握手」，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以每收到一个 SYN 就只能先主动建立一个连接\n如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费\n🎶两次握手会造成资源浪费，服务器重复接收无用的连接请求，而造成重复分配资源\n\n¶三次握手总结\n不使用「两次握手」和「四次握手」的原因：\n\n「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列\n「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数\n\n¶SYN 攻击\n如果只有前两次握手，所建立的连接称为半连接\n在半连接中，只有服务器端开辟了缓存，客户端并没有开辟缓存如果一个客户端连续地和服务器端建立半连接，很可能导致服务器端因资源耗尽而瘫痪。这种半连接攻击方法是一种 DoS（Denial of Service）攻击。如果多个客户端同时半连接攻击一台服务器或路由器，就能很快地导致服务器或路由器瘫痪，这种攻击方法称为 DDoS（Distributed Denial of Service）\n避免 SYN 攻击方式一\n修改 Linux 内核参数，控制队列大小和当队列满时应做的处理\n\n当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数：\n\n1net.core.netdev_max_backlog\n\nSYN_RCVD 状态连接的最大个数：\n\n1net.ipv4.tcp_max_syn_backlog\n\n超出处理能时，对新的 SYN 直接回报 RST，丢弃连接：\n\n1net.ipv4.tcp_abort_on_overflow\n避免 SYN 攻击方式二\nLinux 内核的 SYN（未完成连接建立）队列与 Accpet（已完成连接建立）队列的工作方式\n\n\n当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」\n接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文\n服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」\n应用通过调用 accpet() socket 接口，从「 Accept 队列」取出连接\n\n\n\ntcp_syncookies 的方式可以应对 SYN 攻击的方法：\n1net.ipv4.tcp_syncookies = 1\n\ntcp_syncookies 应对 SYN 攻击\n\n当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」\n计算出一个 cookie 值，再以 SYN + ACK 中的「序列号」返回客户端\n服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」\n最后应用通过调用 accpet() socket 接口，从「 Accept 队列」取出的连接\n\n¶四次挥手（连接关闭）\n双方都可以主动断开连接，断开连接后主机中的资源将被释放\n由于 TCP 连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个 FIN 来终止这一方向的连接，收到一个 FIN 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个 TCP 连接上仍然能够发送数据，直到这一方向也发送了 FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。\n\n客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。\n服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态。\n客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。\n等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。\n客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态\n服务器收到了 ACK 应答报文后，就进入了 CLOSED 状态，至此服务端已经完成连接的关闭。\n客户端在经过 2MSL 一段时间后，自动进入 CLOSED 状态，至此客户端也完成连接的关闭。\n\n\n🎶只有发起关闭方，才会有TIME_WAIT状态\n¶为什么是四次挥手\n\n关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据\n服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接\n\n服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，所以需要多发送一次\n¶为什么需要 TIME_WAIT ？\n主动发起关闭连接的一方，才会有 TIME-WAIT 状态。\n需要 TIME-WAIT 状态，主要是两个原因：\n\n防止具有相同「四元组」的「旧」数据包被收到\n保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭\n\n防止旧连接的数据包\n假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会造成接收到历史数据的异常\n\n\n如上图黄色框框服务端在关闭连接之前发送的 SEQ = 301 报文，被网络延迟了。\n这时有相同端口的 TCP 连接被复用后，被延迟的 SEQ = 301 抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题\n\n🎶所以，TCP 就设计出了这么一个机制，经过 2MSL 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的\n保证连接正确关闭\n\nTIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request. —— RFC 793\nTIME-WAIT 作用是等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭\n\n如果 TIME-WAIT 没有等待时间或时间过短，断开连接会造成如下问题：\n\n没有确保正常断开的异常\n\n如上图红色框框客户端四次挥手的最后一个 ACK 报文如果在网络中被丢失了，此时如果客户端 TIME-WAIT 过短或没有，则就直接进入了 CLOSED 状态了，那么服务端则会一直处在 LASE_ACK 状态。\n当客户端发起建立连接的 SYN 请求报文后，服务端会发送 RST 报文给客户端，连接建立的过程就会被终止。\n\n如果 TIME-WAIT 等待足够长的情况就会遇到两种情况：\n\n服务端正常收到四次挥手的最后一个 ACK 报文，则服务端正常关闭连接。\n服务端没有收到四次挥手的最后一个 ACK 报文时，则会重发 FIN 关闭连接报文并等待新的 ACK 报文。\n\n所以客户端在 TIME-WAIT 状态等待 2MSL 时间后，就可以保证双方的连接都可以正常的关闭\n¶为什么 TIME_WAIT 时间是 2MSL\nMSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，所以 MSL 时间就是 TTL 为零所花费的时间\n🤔为什么 TIME_WAIT 等待的时间是 2MSL？\n\n网络中可能存在来自发送方的数据包，当这些数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间\n\n比如如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。\n2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时\n¶TIME_WAIT 过多如何？\n过多的 TIME-WAIT 状态主要的危害有两种：\n\n第一是内存资源占用\n第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口\n\n如果发起连接一方的 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。\n客户端受端口资源限制：\n\n客户端 TIME_WAIT 过多，就会导致端口资源被占用，因为端口就 65536 个，被占满就会导致无法创建新的连接\n\n服务端受系统资源限制：\n\n由于一个四元组表示 TCP 连接，理论上服务端可以建立很多连接，服务端确实只监听一个端口，但是会把连接扔给处理线程，所以理论上监听的端口可以继续监听。但是线程池处理不了那么多一直不断的连接了。所以当服务端出现大量 TIME_WAIT 时，系统资源被占满时，会导致处理不过来新的连接\n\n¶拥塞控制\nTCP 流控的目的是尽量避免接收端丢包，而 TCP 拥塞控制的目的则尽量避免路由器丢包\n🎶流量控制和拥塞控制均是 TCP 为了不丢包额外增加的功能\nTCP 的拥塞控制属于端到端的拥塞控制方法，要靠端系统自己去感知网络是否拥塞\n反映网络是否拥塞的主要参数有两个： 网络丢包和时延\n¶时延\n其中时延的大小不但跟网络忙闲状况有关，还跟两个端系统之间的网络距离有关系，据此来判断网络是否拥塞比较困难\n¶丢包\nTCP 采用的是基于丢包来判定网络是否拥塞。其基本思想是：\n\n网络不拥塞时，发送端增大发送窗口\n网络拥塞时，发送端就减小发送窗口，从而会降低路由器的数据输入量，让路由器恢复到非拥塞状态\n\n拥塞控制算法(Additive Increase, Multiplicative Decrease ,AIMD)分为两个部分：慢启动和拥塞避免\n\n\n\n网络情况\n拥塞情况\n\n\n\n\n计时器超时导致了丢包\n网络进入重度拥塞状态\n\n\n三个相同的确认段导致的丢包\n网络进入轻度拥塞状态\n\n\n\n✨AIMD 算法具有四个特性\n\n有效性(Efficiency)\n收敛性\n公正性(对同样的 TCP 公正)\n友好型\n\n¶附录\n35 张图解：被问千百遍的 TCP 三次握手和四次挥手面试题\n","dateCreated":"2022-02-24T02:13:03+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2022-02-24T02:13:03+00:00","description":"传输层是计算机网络的核心，本文将重点记录计算机网络相关概念，以求加深对网络知识的理解","headline":"传输层技术","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/%E4%BC%A0%E8%BE%93%E5%B1%82%E6%8A%80%E6%9C%AF/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/%E4%BC%A0%E8%BE%93%E5%B1%82%E6%8A%80%E6%9C%AF/","keywords":"计算机网络"}</script><meta name="description" content="传输层是计算机网络的核心，本文将重点记录计算机网络相关概念，以求加深对网络知识的理解"><meta property="og:type" content="blog"><meta property="og:title" content="传输层技术"><meta property="og:url" content="https://pineapple-man.github.io/%E4%BC%A0%E8%BE%93%E5%B1%82%E6%8A%80%E6%9C%AF/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="传输层是计算机网络的核心，本文将重点记录计算机网络相关概念，以求加深对网络知识的理解"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-tcpPackageInformation.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-sendReliableAlgo.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-recvReliableAlgo.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-tcpResendAlgo.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-tcp-connectBuild.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-tcp-thirdHandshake.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-tcp-thirdHandShakeReason1.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-tcp-thirdHandShakeReason3.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-avoidSynAttack.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-synAttackPriciple.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-synAttackReason.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-synAttackSolver.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-connectClose.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-recvFaultDataException.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-connectCloseException.jpg"><meta property="article:published_time" content="2022-02-24T02:13:03.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.003Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="计算机网络"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-tcpPackageInformation.png"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">传输层技术</h1><div class="post-meta"><time datetime="2022-02-24T02:13:03+00:00">2月 24, 2022 </time><span>发布在 </span><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a>, <a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 6.9k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 64 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-text">传输层协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP"><span class="toc-text">UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-text">报文格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-UDP-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">基于 UDP 的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP"><span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F-v2"><span class="toc-text">报文格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8E%A7%E5%88%B6"><span class="toc-text">可靠性控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%AB%AF%E5%8F%AF%E9%9D%A0%E7%AE%97%E6%B3%95"><span class="toc-text">发送端可靠算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E7%AB%AF%E7%A1%AE%E8%AE%A4%E4%BA%A7%E7%94%9F%E7%AE%97%E6%B3%95"><span class="toc-text">接收端确认产生算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8%E9%97%B4%E9%9A%94%E8%AE%BE%E7%BD%AE"><span class="toc-text">计时器间隔设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-text">连接管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%EF%BC%89"><span class="toc-text">三次握手（连接建立）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8E%9F%E5%9B%A0%E4%B8%80"><span class="toc-text">三次握手原因一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8E%9F%E5%9B%A0%E4%BA%8C"><span class="toc-text">三次握手原因二</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8E%9F%E5%9B%A0%E4%B8%89"><span class="toc-text">三次握手原因三</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%80%BB%E7%BB%93"><span class="toc-text">三次握手总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SYN-%E6%94%BB%E5%87%BB"><span class="toc-text">SYN 攻击</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E8%BF%9E%E6%8E%A5%E5%85%B3%E9%97%AD%EF%BC%89"><span class="toc-text">四次挥手（连接关闭）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">为什么是四次挥手</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-TIME-WAIT-%EF%BC%9F"><span class="toc-text">为什么需要 TIME_WAIT ？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-TIME-WAIT-%E6%97%B6%E9%97%B4%E6%98%AF-2MSL"><span class="toc-text">为什么 TIME_WAIT 时间是 2MSL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TIME-WAIT-%E8%BF%87%E5%A4%9A%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="toc-text">TIME_WAIT 过多如何？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-text">拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E5%BB%B6"><span class="toc-text">时延</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A2%E5%8C%85"><span class="toc-text">丢包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol><h2 id="传输层协议"><a class="header-anchor" href="#传输层协议">¶</a>传输层协议</h2><p><strong>传输层</strong>对应用层提供<font style="color:red;font-weight:700">进程到进程的通信</font>支持，为了能够做到进程间通信，传输层使用了<strong>端口</strong>。能够将发送端某个进程的报文封装成<strong>段</strong>，传送到接收端对应进程中。</p><p>✨传输层特点</p><div class="alert success no-icon"><ul><li>此层只有两个协议，即 <strong>UDP</strong> 和 <strong>TCP</strong></li><li>除了提供段传送功能外，还提供了<strong>复用/解复用</strong>、<strong>差错检测</strong>功能</li></ul></div><p>❓ 复用和解复用是什么意思？</p><div class="alert success no-icon"><ul><li><strong>复用</strong>的含义是：应用层不同进程的报文在传输层封装成不同的段传送到网络，信息在传输层不会混合在一起</li><li><strong>解复用</strong>的含义是：到达接收端传输层的段，按照目的端口号分别送给各自的进程，不会送错</li></ul></div><p>📖 TCP 和 UDP 协议只运行在端系统上，提供全双工的通信，当<strong>路由器</strong>的角色是端系统时，它<strong>也有传输层和应用层</strong>，也要运行这两个协议</p><h2 id="UDP"><a class="header-anchor" href="#UDP">¶</a>UDP</h2><p>UDP（User Datagram Protocol）是用户数据报协议，这是一个非常简单的协议，和下层的 IP 相比，就多了一个端口号承载功能。所以，它和 IP 协议一样，服务模型都是<strong>尽力而为</strong></p><p>✨UDP 协议特点</p><div class="alert success no-icon"><ul><li>UDP 提供的是<font style="color:red;font-weight:700">无连接、不可靠的服务</font>，直接传送段，不需要先建立连接</li><li>协议<strong>简单</strong>、<strong>报文段头小</strong>、<strong>比 TCP 快</strong></li></ul></div><p>📖UDP 发送的前后段之间没有依赖关系，UDP 的段<strong>可能丢失</strong>，也<strong>可能乱序</strong>（后发的段先到达接收端进程），当然也<strong>可能出现差错</strong>。出现这些问题时，<strong>UDP 并没有提供问题恢复的功能</strong></p><h3 id="报文格式"><a class="header-anchor" href="#报文格式">¶</a>报文格式</h3><p>UDP 的<strong>段头只有 8 个字节</strong>，分为<strong>四个字段</strong>，每个字段都是两个字节长：<strong>源端口号</strong>、<strong>目的端口号</strong>、<strong>长度（单位是字节）<strong>和</strong>校验和（checksum）</strong></p><p>🎶<font style="color:red;font-weight:700">校验和字段是多余的</font>,对于每个段的传送，源端和目的端都会进行校验和计算和验证，这会增加端到端的传送时延</p><p>🤔为什么校验和是多余的 ？</p><div class="alert success no-icon"><ol><li>UDP 通信允许丢包和出现差错，即便出现差错也不会去处理</li><li>如果传输过程中出现差错，数据链路层就会把包含差错的帧丢弃，不会再向上层传送</li><li>凡是送达传输层的段，都是没有差错的</li></ol></div><h3 id="基于-UDP-的应用"><a class="header-anchor" href="#基于-UDP-的应用">¶</a>基于 UDP 的应用</h3><table><thead><tr><th style="text-align:center">局域网典型的 UDP 应用</th></tr></thead><tbody><tr><td style="text-align:center">远程文件系统（NFS）</td></tr><tr><td style="text-align:center">网络管理（SNMP）</td></tr><tr><td style="text-align:center">动态主机配置（DHCP）</td></tr><tr><td style="text-align:center">简单文件传输（TFTP， trivial FTP）</td></tr></tbody></table><p>🎶这些应用都是面向局域网的，对实时性和可靠性均有较高的要求。局域网通信一般不太会丢包，<strong>使用 UDP 可以大体上保证实时性</strong></p><table><thead><tr><th style="text-align:center">Internet 典型的 UDP 应用</th></tr></thead><tbody><tr><td style="text-align:center">流媒体（音视频点播）</td></tr><tr><td style="text-align:center">可视电话</td></tr><tr><td style="text-align:center">域名服务（DNS）</td></tr><tr><td style="text-align:center">路由信息协议（RIP）</td></tr><tr><td style="text-align:center">路由跟踪（Tracert 网络命令）</td></tr><tr><td style="text-align:center">多播应用</td></tr><tr><td style="text-align:center">基于 RTP 的实时应用</td></tr></tbody></table><h2 id="TCP"><a class="header-anchor" href="#TCP">¶</a>TCP</h2><p>TCP 是传输控制协议（Transport Control Protocol），<strong>仅支持点对点通信</strong>，提供<strong>面向连接的</strong>，<strong>可靠的</strong>、<strong>字节有序的</strong>信息传输服务。</p><p>TCP 包含四个主要技术：<font style="color:red;font-weight:700">可靠性控制</font>、<font style="color:red;font-weight:700">流量控制</font>、<font style="color:red;font-weight:700">拥塞控制</font>和<font style="color:red;font-weight:700">连接管理</font></p><h3 id="报文格式-v2"><a class="header-anchor" href="#报文格式-v2">¶</a>报文格式</h3><p>TCP 的段头是 <strong>20 个字节长</strong>，缺省的 <font style="color:red;font-weight:700">TCP 最大段长固定为 536 字节</font>， 这意味着一个 <strong>TCP 段的负载最多是 516 字节</strong></p><table><thead><tr><th style="text-align:center">报文</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">Head length</td><td style="text-align:center">段头长度，占 4 位，可区别 16 个字</td></tr><tr><td style="text-align:center">6 位是保留位</td><td style="text-align:center">没有使用</td></tr><tr><td style="text-align:center">U 是 Urgent 的字头</td><td style="text-align:center">紧急位，表示这个段需要<strong>立即向上层传送</strong>，<strong>实际当中没有使用</strong></td></tr><tr><td style="text-align:center">A 是确认段标记</td><td style="text-align:center">A=1，表示这个段是确认段</td></tr><tr><td style="text-align:center">P 是 Push 的字头</td><td style="text-align:center">含义和 U 类似，表示<strong>立即向下传送</strong>，<strong>实际当中没有使用</strong></td></tr><tr><td style="text-align:center">R、 S、 F 三个位跟连接管理有关</td><td style="text-align:center">R=1 表示重新建立连接；<br>S=1 表示这个段是同步段，S=0 表示连接建立结束<br>F=1 表示连接关闭</td></tr><tr><td style="text-align:center">Rcvr window size</td><td style="text-align:center">接收窗口，即接收端的空闲缓存。发送端基于这个值来控制发送速率，以免造成接收端因接收缓存溢出而丢包</td></tr><tr><td style="text-align:center">checksum 字段</td><td style="text-align:center">存放 16 位的校验和,接收端据此来判断所接收的段里是否有差错。<br><strong>实践当中没有使用</strong></td></tr><tr><td style="text-align:center">ptr urgent data</td><td style="text-align:center">16 位，存放紧急数据的指针，<strong>实践当中没有使用</strong></td></tr><tr><td style="text-align:center">可变长的选项字段，</td><td style="text-align:center">存放需要协商的最大段长、时间戳、窗口的变化因子<br><strong>实际当中没有使用</strong></td></tr></tbody></table><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-tcpPackageInformation.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-tcpPackageInformation.png" alt=""></a></div><h3 id="可靠性控制"><a class="header-anchor" href="#可靠性控制">¶</a>可靠性控制</h3><p>TCP 可靠性控制的基本思想是：<strong>丢包重传</strong>，即<strong>发送端发现哪个段丢失了，就重传哪个段</strong></p><p>✨TCP 实现可靠传送的要求：</p><div class="alert success no-icon"><ol><li><strong>发送端必须开辟缓存</strong>，缓存发送出去段，保证段丢失了可以重发这些段</li><li>发送端和接收端需要相互协作（要有确认机制，告诉发送端它收到了那些段；发送端要有计时机制，一旦确认段丢失，也能发现有段丢失）</li><li>使用段序号对所发送的段进行编号，以便发送端能确定是哪些段丢了</li></ol></div><h4 id="发送端可靠算法"><a class="header-anchor" href="#发送端可靠算法">¶</a>发送端可靠算法</h4><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-sendReliableAlgo.png" alt=""></p><p>发送端开辟的缓存称之为<strong>发送窗口</strong> ，需要几个变量来维护这个窗口。</p><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">send_base</td><td style="text-align:center"><strong>基指针</strong>，指向发送窗口的最左侧的段<br>收到一个确认段时， 基指针就右移到确认段中确认号指向的段、这意味着<strong>接收端确认段之前所有的段都已经收到了</strong></td></tr><tr><td style="text-align:center">nextseqnum</td><td style="text-align:center">可以使用的下一个段序号，<strong>发送端每封装一个段，nextseqnum 就右移一位</strong></td></tr><tr><td style="text-align:center">N</td><td style="text-align:center"><strong>窗口的大小</strong>，当<strong>发送窗口满时，停止发送</strong></td></tr></tbody></table><h4 id="接收端确认产生算法"><a class="header-anchor" href="#接收端确认产生算法">¶</a>接收端确认产生算法</h4><p>✨TCP 累积确认机制</p><ul><li>TCP 接收端返回确认段的确认号始终是<strong>它期待那个段的段序号</strong></li></ul><p>📚累积确认，将告诉发送端两件事</p><div class="alert success no-icon"><ol><li>当前段之前所有的段都接受到了</li><li>期待当前段序号的段</li></ol></div><p>接收端是有接收窗口的，用以存放所收到的失序的段</p><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">rcv_base</td><td style="text-align:center">基指针，始终指向期待接收的段。<br>如果基指针指向的段到了，基指针就会右移到所期待的段</td></tr><tr><td style="text-align:center">N</td><td style="text-align:center">接收窗口的大小，当接收窗口满时，新到的段就被丢弃</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-recvReliableAlgo.png" alt=""></p><span class="highlight-text red">TCP ACK 产生机制</span><table><thead><tr><th style="text-align:center">事件</th><th style="text-align:center">接收端动作</th></tr></thead><tbody><tr><td style="text-align:center">按序到到达一个段，没有间隙<br>前面所有的段都已确认</td><td style="text-align:center">延迟确认，做最多 500 ms 的延时，等待下一个段。如果下一个段未到，延时结束时发送 ACK</td></tr><tr><td style="text-align:center">按序到达一个段，没有间隙<br>前面一个正在做延时</td><td style="text-align:center">立即发送 ACK，累积确认</td></tr><tr><td style="text-align:center">乱序到达一个段，段序号比期待的段序号高，检测到间隙</td><td style="text-align:center">重发 ACK，确认号还是期待段的段序号</td></tr><tr><td style="text-align:center">到达一个段，位于接受窗口的间隙中</td><td style="text-align:center">立即给出确认<br>如果位于最左侧的间隙，右移接收窗口的基指针<br>否则，标记该段接受</td></tr></tbody></table><span class="highlight-text red">TCP 可靠重传算法</span><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-tcpResendAlgo.png" alt=""></p><p>🤔如何保证 TCP 的全双工可靠通信？</p><ul><li>TCP 发送端的可靠性控制算法在接收端部署一份</li><li>接收端的确认产生算法在发送端也部署一份</li></ul><h4 id="计时器间隔设置"><a class="header-anchor" href="#计时器间隔设置">¶</a>计时器间隔设置</h4><p>TCP 发送端每发送一个段，就会启动一个逻辑计时器， 对这个段进行计时， 在发送端确定是否需要重传</p><p>🤔这个计时器的触发间隔应该是多长呢？</p><ul><li>太长，对丢包的响应很慢，影响通信效率</li><li>太短，会出现<strong>假丢包</strong>现象，造成<strong>大量不必要的重传</strong>，<strong>浪费网络带宽资源</strong></li><li>理想情况，应能反映最近未来的网络状况，应该比接下来的那个 RTT 略大一点，同时又具有较好的平滑性，避免频繁地设置计时器</li></ul><p>如果我们把未来这个 RTT 值定义为 EstimatedRTT， TCP 预测 EstimatedRTT 使用的是“加权运动平均”模型， 这个模型使用了很多次历史测量的 RTT 值，而不是只使用刚刚测量的那个 RTT 值。</p><p>$EstimatedRTT_n = (1-x)<em>EstimatedRTT_{n-1} + x</em>SampleRTT$</p><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">$SampleRTT$</td><td style="text-align:center">刚刚测量的 RTT 值</td></tr><tr><td style="text-align:center">$EstimatedRTT_{n-1}$</td><td style="text-align:center">上一次的预测值</td></tr><tr><td style="text-align:center">$x$</td><td style="text-align:center">经验值，通常为$0.125$</td></tr></tbody></table><p>当网络状态波动大时，偏差值 Deviation 也大；</p><p>当网络状态波动小时， Deviation 也小。</p><p>因此，实际设定的间隔值 Timeout 具有自适应性，能自适应网络的忙闲状况。</p><h3 id="流量控制"><a class="header-anchor" href="#流量控制">¶</a>流量控制</h3><p>🤔为什么需要流量控制 ?</p><ul><li>TCP 的<strong>接收端的段处理速度有可能比较慢</strong>，这就容易造成<strong>接收缓存溢出</strong>，<font style="color:red;font-weight:700">导致接收端的传输层丢包</font></li></ul><p>🤔如何达成流量控制 ?</p><ul><li>🎶发送端的发送速率和目的端的处理速率匹配起来，<strong>对发送端的发送速率进行控制</strong>，使得既不会导致接收端丢包，也不会导致发送端发送速率过慢影响通信效率</li></ul><p>👴本质上，TCP 流量控制就是——<strong>速率匹配机制</strong></p><p>TCP 的流控机制使用了一个重要参数： $RcvWindow$，表示空闲的接收缓存大小</p><p>$$<br>\text{RcvWindow}= \text{RcvBuffer}-(\text{LastByteRcvd}-\text{LastByteRead})<br>$$</p><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">$\text{RcvBuffer}$</td><td style="text-align:center">接收缓存</td></tr><tr><td style="text-align:center">$\text{LastByteRcvd}$</td><td style="text-align:center">所接收的、最后的字节数</td></tr><tr><td style="text-align:center">$\text{LastByteRead}$</td><td style="text-align:center">传送给应用层的最后字节数</td></tr><tr><td style="text-align:center">$\text{LastByteRcvd}-\text{LastByteRead}$</td><td style="text-align:center">被占据的接收缓存空间</td></tr></tbody></table><p>$\text{LastByteRcvd}-\text{LastByteRead}$参数是动态变化的，伴随着确认段的返回，通过段头不断地反馈给源端。源端据此来控制自己的发送速率：所发送的、尚未被确认的数据量不超过 $\text{RcvWindow}$</p><ol><li>$\text{Initially}, \text{RcvWindow}=\text{RcvBuffer}$</li><li>$\text{LastByteSent}-\text{LastByteAcked}&lt;=\text{RcvWindow}$</li><li>When $\text{RcvWindow}=0$ , one byte data is still sent to the receiver；</li></ol><p>🤔为什么接收区缓存满了之后，还需要发送一个比特的数据尼？</p><ul><li>接收缓存满时，如果停止发送数据，很容易导致通信停止（如果一直接收不到确认信<br>息，通信就终止了，即便接收缓存变空，源端也感知不到）</li><li>所以，即便接收缓存满了<strong>仍然发送一个字节的数据（段大小是 21 个字节）</strong>。</li><li>当这个段到达接收端时，即便接收缓存腾出一点空间，这个段也能存放进去，接收端就会返回一个确认段，确认段中包含有最新的 $RcvWindow$ 值，通信就不会终止</li><li>如果这个很小的段到达接收端，接收缓存仍然是满的，这个段被丢弃掉，损失也不大</li></ul><p>这个算法还可以进一步优化。</p><p>在目前 TCP 的控制算法中，源端的数据发送量是根据半个 RTT 之前接收端的空闲接收缓存大小决定的，而真正想匹配的却是半个 RTT 之后接收端接收缓存的大小。这实际上是存在一个 RTT 的时差的，在这一个 RTT 内，空闲的接收缓存大小很可能发生变化了。 如果源端能根据接收端反馈的 RcvWindow 值， 通过预测模型（如加权运动平均模型） 来预测半个 RTT 之后的 RcvWindow 大小，就能提高匹配的精度，提高<br>TCP 的通信效率。</p><h3 id="连接管理"><a class="header-anchor" href="#连接管理">¶</a>连接管理</h3><p>连接管理主要包括<strong>连接建立</strong>和<strong>连接关闭</strong></p><p>TCP 在通信之前必须要先建立连接（这个连接是逻辑上的，只存在于两个端系统之上）</p><p>🎶建立连接的目的是</p><ol><li>两个端系统开辟缓存（发送缓存和接收缓存）</li><li>设置控制所用的变量</li><li>交换初始的段序号</li></ol><h4 id="三次握手（连接建立）"><a class="header-anchor" href="#三次握手（连接建立）">¶</a>三次握手（连接建立）</h4><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-tcp-connectBuild.jpg" alt=""></p><ol><li>客户端向服务器端<strong>发送同步段及进行连接请求</strong>，段头里包含有<font style="color:red;font-weight:700">初始段序号，同步位<code>S=1</code></font></li><li>服务器端给出<strong>连接确认</strong>，<strong>返回同意连接</strong> 的同步段，段头里包含有<font style="color:red;font-weight:700">服务器端随机选取的初始段序号，同步位 S=1、确认号=客户端发送的初始段序号+1</font>，之后服务器开辟缓存，设置相关变量</li><li>客户端<strong>返回一个确认段</strong>，<font style="color:red;font-weight:700">其中<code>S=0</code>，段序号=初始段序号+1，确认号=服务器端发送的初始段序号+1</font>,随后客户端开辟缓存，设置相关变量。</li></ol><p>🎶三次握手的过程中，<strong>所交换段的负载域均为空</strong></p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-tcp-thirdHandshake.png" alt=""></p><p>🤔为什么是三次握手？而不是四次或者两次？</p><ul><li><blockquote><p>The Priciple reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion. ——RFC 793</p><p>首要原因就是防止旧的重复连接初始化造成混乱</p></blockquote></li><li><p><font style="color:red;font-weight:700">同步双方初始序列号</font></p></li><li><p><font style="color:red;font-weight:700">避免资源浪费</font></p></li></ul><h5 id="三次握手原因一"><a class="header-anchor" href="#三次握手原因一">¶</a>三次握手原因一</h5><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-tcp-thirdHandShakeReason1.jpg" alt=""></p><p>客户端连续发送多次 SYN 建立连接的报文，在<strong>网络拥堵</strong>情况下：</p><ul><li>一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；</li><li>那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端；</li><li>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 <code>RST</code> 报文给服务端，表示中止这一次连接。</li></ul><p>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：</p><ul><li>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 <code>RST</code> 报文，以此中止历史连接；</li><li>如果不是历史连接，则第三次发送的报文是 <code>ACK</code> 报文，通信双方就会成功建立连接；</li></ul><p>所以，TCP 使用三次握手建立连接的最主要原因是<strong>防止历史连接初始化了连接。</strong></p><h5 id="三次握手原因二"><a class="header-anchor" href="#三次握手原因二">¶</a>三次握手原因二</h5><p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p><ul><li>接收方可以去除重复的数据</li><li>接收方可以根据数据包的序列号按序接收</li><li>可以标识发送出去的数据包中， 哪些是已经被对方收到的</li></ul><p>当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p><p>✨四次握手、三次握手、二次握手</p><ul><li>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」</li><li>两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收</li></ul><h5 id="三次握手原因三"><a class="header-anchor" href="#三次握手原因三">¶</a>三次握手原因三</h5><p>如果只有「两次握手」，当客户端的 <code>SYN</code> 请求连接在网络中阻塞，客户端没有接收到 <code>ACK</code> 报文，就会重新发送 <code>SYN</code> ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 <code>ACK</code> 确认信号，所以每收到一个 <code>SYN</code> 就只能先主动建立一个连接</p><p>如果客户端的 <code>SYN</code> 阻塞了，重复发送多次 <code>SYN</code> 报文，那么服务器在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费</strong></p><p>🎶两次握手会造成资源浪费，服务器重复接收无用的连接请求，而造成重复分配资源</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-tcp-thirdHandShakeReason3.jpg" alt=""></p><h5 id="三次握手总结"><a class="header-anchor" href="#三次握手总结">¶</a>三次握手总结</h5><p>不使用「两次握手」和「四次握手」的原因：</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列</li><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数</li></ul><h5 id="SYN-攻击"><a class="header-anchor" href="#SYN-攻击">¶</a>SYN 攻击</h5><p>如果只有前两次握手，所建立的连接称为<strong>半连接</strong></p><p><strong>在半连接中，只有服务器端开辟了缓存</strong>，客户端并没有开辟缓存<font style="color:red;font-weight:700">如果一个客户端连续地和服务器端建立半连接，很可能导致服务器端因资源耗尽而瘫痪</font>。这种半连接攻击方法是一种 <strong>DoS（Denial of Service）攻击</strong>。如果多个客户端同时半连接攻击一台服务器或路由器，就能很快地导致服务器或路由器瘫痪，这种攻击方法称为 DDoS（Distributed Denial of Service）</p><span class="highlight-text red">避免 SYN 攻击方式一</span><p>修改 Linux 内核参数，控制队列大小和当队列满时应做的处理</p><ul><li>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.core.netdev_max_backlog</span><br></pre></td></tr></table></figure><ul><li>SYN_RCVD 状态连接的最大个数：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_max_syn_backlog</span><br></pre></td></tr></table></figure><ul><li>超出处理能时，对新的 SYN 直接回报 RST，丢弃连接：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_abort_on_overflow</span><br></pre></td></tr></table></figure><span class="highlight-text red">避免 SYN 攻击方式二</span><p>Linux 内核的 <code>SYN</code>（未完成连接建立）队列与 <code>Accpet</code>（已完成连接建立）队列的工作方式</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-avoidSynAttack.jpg" alt=""></p><ol><li>当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」</li><li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文</li><li>服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」</li><li>应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出连接</li></ol><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-synAttackPriciple.jpg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-synAttackReason.jpg" alt=""></p><p><code>tcp_syncookies</code> 的方式可以应对 SYN 攻击的方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies = 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-synAttackSolver.jpg" alt=""></p><p>tcp_syncookies 应对 SYN 攻击</p><ol><li>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」</li><li>计算出一个 <code>cookie</code> 值，再以 SYN + ACK 中的「序列号」返回客户端</li><li>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」</li><li>最后应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出的连接</li></ol><h4 id="四次挥手（连接关闭）"><a class="header-anchor" href="#四次挥手（连接关闭）">¶</a>四次挥手（连接关闭）</h4><p>双方都可以主动断开连接，断开连接后主机中的<strong>资源</strong>将被释放</p><p>由于 TCP 连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个 FIN 来终止这一方向的连接，收到一个 FIN 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个 TCP 连接上仍然能够发送数据，直到这一方向也发送了 FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。</p><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSED_WAIT</code> 状态。</li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSED</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSED</code> 状态，至此客户端也完成连接的关闭。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-connectClose.jpg" alt=""></p><p>🎶只有发起关闭方，才会有<code>TIME_WAIT</code>状态</p><h5 id="为什么是四次挥手"><a class="header-anchor" href="#为什么是四次挥手">¶</a>为什么是四次挥手</h5><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据</li><li>服务器收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接</li></ul><p>服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，所以需要多发送一次</p><h5 id="为什么需要-TIME-WAIT-？"><a class="header-anchor" href="#为什么需要-TIME-WAIT-？">¶</a>为什么需要 TIME_WAIT ？</h5><p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</p><p>需要 TIME-WAIT 状态，主要是两个原因：</p><ul><li>防止具有相同「四元组」的「旧」数据包被收到</li><li>保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭</li></ul><span class="highlight-text red">防止旧连接的数据包</span><p>假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会造成接收到历史数据的异常</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-recvFaultDataException.jpg" alt=""></p><ul><li>如上图黄色框框服务端在关闭连接之前发送的 <code>SEQ = 301</code> 报文，被网络延迟了。</li><li>这时有相同端口的 TCP 连接被复用后，被延迟的 <code>SEQ = 301</code> 抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题</li></ul><p>🎶所以，TCP 就设计出了这么一个机制，经过 <code>2MSL</code> 这个时间，<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的</strong></p><span class="highlight-text red">保证连接正确关闭</span><blockquote><p>TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request. —— RFC 793</p><p>TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭</strong></p></blockquote><p>如果 TIME-WAIT 没有等待时间或时间过短，断开连接会造成如下问题：</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/network/network-transport-connectCloseException.jpg" alt=""></p><p>没有确保正常断开的异常</p><ul><li>如上图红色框框客户端四次挥手的最后一个 <code>ACK</code> 报文如果在网络中被丢失了，此时如果客户端 <code>TIME-WAIT</code> 过短或没有，则就直接进入了 <code>CLOSED</code> 状态了，那么服务端则会一直处在 <code>LASE_ACK</code> 状态。</li><li>当客户端发起建立连接的 <code>SYN</code> 请求报文后，服务端会发送 <code>RST</code> 报文给客户端，连接建立的过程就会被终止。</li></ul><p>如果 TIME-WAIT 等待足够长的情况就会遇到两种情况：</p><ul><li>服务端正常收到四次挥手的最后一个 <code>ACK</code> 报文，则服务端正常关闭连接。</li><li>服务端没有收到四次挥手的最后一个 <code>ACK</code> 报文时，则会重发 <code>FIN</code> 关闭连接报文并等待新的 <code>ACK</code> 报文。</li></ul><p>所以客户端在 <code>TIME-WAIT</code> 状态等待 <code>2MSL</code> 时间后，就可以<strong>保证双方的连接都可以正常的关闭</strong></p><h5 id="为什么-TIME-WAIT-时间是-2MSL"><a class="header-anchor" href="#为什么-TIME-WAIT-时间是-2MSL">¶</a>为什么 TIME_WAIT 时间是 2MSL</h5><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，所以 MSL 时间就是 TTL 为零所花费的时间</p><p>🤔为什么 TIME_WAIT 等待的时间是 2MSL？</p><ul><li>网络中可能存在来自发送方的数据包，当这些数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong></li></ul><p>比如如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</p><p><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong></p><h5 id="TIME-WAIT-过多如何？"><a class="header-anchor" href="#TIME-WAIT-过多如何？">¶</a>TIME_WAIT 过多如何？</h5><p>过多的 TIME-WAIT 状态主要的危害有两种：</p><ul><li>第一是内存资源占用</li><li>第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口</li></ul><p><strong>如果发起连接一方的 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。</strong></p><p>客户端受端口资源限制：</p><ul><li>客户端 TIME_WAIT 过多，就会导致端口资源被占用，因为端口就 65536 个，被占满就会导致无法创建新的连接</li></ul><p>服务端受系统资源限制：</p><ul><li>由于一个四元组表示 TCP 连接，理论上服务端可以建立很多连接，服务端确实只监听一个端口，但是会把连接扔给处理线程，所以理论上监听的端口可以继续监听。但是线程池处理不了那么多一直不断的连接了。所以当服务端出现大量 TIME_WAIT 时，系统资源被占满时，会导致处理不过来新的连接</li></ul><h3 id="拥塞控制"><a class="header-anchor" href="#拥塞控制">¶</a>拥塞控制</h3><p>TCP <strong>流控的目的是尽量避免接收端丢包</strong>，而 <font style="color:red;font-weight:700">TCP 拥塞控制的目的则尽量避免路由器丢包</font></p><p>🎶流量控制和拥塞控制均是 TCP 为了不丢包额外增加的功能</p><p>TCP 的拥塞控制属于<font style="color:red;font-weight:700">端到端的拥塞控制方法</font>，要靠端系统自己去感知网络是否拥塞</p><p>反映网络是否拥塞的主要参数有两个： <strong>网络丢包</strong>和<strong>时延</strong></p><h4 id="时延"><a class="header-anchor" href="#时延">¶</a>时延</h4><p>其中时延的大小不但跟网络忙闲状况有关，还跟两个端系统之间的网络距离有关系，据此来判断网络是否拥塞比较困难</p><h4 id="丢包"><a class="header-anchor" href="#丢包">¶</a>丢包</h4><p>TCP 采用的是基于丢包来判定网络是否拥塞。其基本思想是：</p><ul><li>网络不拥塞时，发送端增大发送窗口</li><li>网络拥塞时，发送端就减小发送窗口，从而会降低路由器的数据输入量，让路由器恢复到非拥塞状态</li></ul><p>拥塞控制算法(Additive Increase, Multiplicative Decrease ,AIMD)分为两个部分：<strong>慢启动</strong>和<strong>拥塞避免</strong></p><table><thead><tr><th style="text-align:center">网络情况</th><th style="text-align:center">拥塞情况</th></tr></thead><tbody><tr><td style="text-align:center">计时器超时导致了丢包</td><td style="text-align:center">网络进入重度拥塞状态</td></tr><tr><td style="text-align:center">三个相同的确认段导致的丢包</td><td style="text-align:center">网络进入轻度拥塞状态</td></tr></tbody></table><p>✨AIMD 算法具有四个特性</p><ol><li>有效性(Efficiency)</li><li>收敛性</li><li>公正性(对同样的 TCP 公正)</li><li>友好型</li></ol><h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaolincoding/p/12638546.html">35 张图解：被问千百遍的 TCP 三次握手和四次挥手面试题</a></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/linux-%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1/" data-tooltip="Linux 后台任务" aria-label="上一篇: Linux 后台任务"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81/" data-tooltip="服务的状态" aria-label="下一篇: 服务的状态"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/linux-%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1/" data-tooltip="Linux 后台任务" aria-label="上一篇: Linux 后台任务"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81/" data-tooltip="服务的状态" aria-label="下一篇: 服务的状态"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>