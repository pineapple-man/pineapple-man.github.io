<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>缓冲区 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="buffer"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n¶概述\n缓冲区是一个用于存储特定数据类型的容器，由 java.nio 包定义，目前常用的缓冲区都是 Buffer 抽象类的子类。Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互。在 NIO 中，如果用户想要消费数据，数据首先会从通道读入缓冲区，随后用户在缓冲区中消费数据。对应地，用户如果想要排出数据，数据首先会从缓冲区写入通道中，随后通过通道排出数据。具体的示意图如下：\n\n¶Buffer 类及其子类\nBuffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同，有以下常用子类：\n\n.tg  {border-collapse:collapse;border-spacing:0;margin:0px auto;}\n.tg td{border-style:solid;border-width:0px;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;\n  padding:10px 5px;word-break:normal;}\n.tg th{border-style:solid;border-width:0px;font-family:Arial, sans-serif;font-size:14px;font-weight:normal;\n  overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-u1qu{font-family:\"Times New Roman\", Times, serif !important;font-size:medium;text-align:center;vertical-align:middle}\n\n\n\n  \n    ByteBuffer\n    CharBuffer\n    CharBuffer\n    CharBuffer\n    LongBuffer\n    LongBuffer\n    LongBuffer\n  \n\n\n上述 Buffer 类他们都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已。都是通过如下方法获取一个 Buffer 对象：\n12//创建一个容量为 capacity 的 XxxBuffer 对象static XxxBuffer allocate(int capacity);\nBuffer 是非线程安全的\n\n¶缓冲区的基本属性\n一个缓冲区具有如下四个最重要的基本属性(mark、position、limit、capacity)，它们遵守以下不等式：0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity\n\n.tg  {border-collapse:collapse;border-color:#9ABAD9;border-spacing:0;margin:0px auto;}\n.tg td{background-color:#EBF5FF;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#444;\n  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{background-color:#409cff;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#fff;\n  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-9wq8{border-color:inherit;text-align:center;vertical-align:middle}\n.tg .tg-ixdq{border-color:inherit;font-weight:bold;position:-webkit-sticky;position:sticky;text-align:center;top:-1px;\n  vertical-align:middle;will-change:transform}\n.tg .tg-uzvj{border-color:inherit;font-weight:bold;text-align:center;vertical-align:middle}\n\n\n\n  \n    基本属性\n    含义\n  \n\n\n  \n    容量 (capacity)\n    作为一个内存块，Buffer具有一定的固定大小，也称为\"容量\"，缓冲区容量不能为负，并且创建后不能更改\n  \n  \n    限制 (limit)\n    表示缓冲区中可以操作数据的大小（limit 后数据不能进行读写）。缓冲区的限制不能为负，并且不能大于其容量  写入模式，限制等于buffer的容量 读取模式下，limit等于写入的数据量\n  \n  \n    位置（position)\n    下一个要读取或写入的数据的索引。缓冲区的位置不能为 负，并且不能大于其限制(limit)\n  \n  \n    标记 (mark)与重置 (reset)\n    标记是一个索引，通过 Buffer 中的 mark() 方法 指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这 个 position\n  \n\n\n简单的相关操作如下：\n\n¶缓冲区常用方法\n\n.tg  {border-collapse:collapse;border-color:#9ABAD9;border-spacing:0;margin:0px auto;}\n.tg td{background-color:#EBF5FF;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#444;\n  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{background-color:#409cff;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#fff;\n  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-sx1p{font-weight:bold;position:-webkit-sticky;position:sticky;text-align:center;top:-1px;vertical-align:middle;\n  will-change:transform}\n.tg .tg-nrix{text-align:center;vertical-align:middle}\n\n\n\n  \n    常用API\n    含义\n  \n\n\n  \n    Buffer clear()\n    清空缓冲区并返回对缓冲区的引用\n  \n  \n    Buffer flip()\n    将缓冲区的界限设置为当前位置，并将当前位置重置为 0，由写模式转换为读模式\n  \n  \n    int capacity()\n    返回 Buffer 的 capacity 大小\n  \n  \n    boolean hasRemaining()\n    判断缓冲区中是否还有元素\n  \n  \n    int limit()\n    返回 Buffer 的界限(limit) 的位置\n  \n  \n    Buffer limit(int n)\n    设置缓冲区界限为 n, 并返回一个具有新 limit 的缓冲区对象\n  \n  \n    Buffer mark()\n    对缓冲区设置标记\n  \n  \n    int position()\n    返回缓冲区的当前位置 position\n  \n  \n    Buffer position(int n)\n    将设置缓冲区的当前位置为 n , 并返回修改后的 Buffer 对象\n  \n  \n    int remaining()\n    返回 position 和 limit 之间的元素个数\n  \n  \n    Buffer reset()\n    将位置 position 转到以前设置的 mark 所在的位置\n  \n  \n    Buffer rewind()\n    将位置设为为 0， 取消设置的 mark\n  \n\n\n¶缓冲区的数据操作\nBuffer 所有子类提供了两个数据操作的方法：get() &amp; put() 方法来获取及写入 Buffer中的数据\n\n.tg  {border-collapse:collapse;border-color:#9ABAD9;border-spacing:0;margin:0px auto;}\n.tg td{background-color:#EBF5FF;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#444;\n  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{background-color:#409cff;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#fff;\n  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-sx1p{font-weight:bold;position:-webkit-sticky;position:sticky;text-align:center;top:-1px;vertical-align:middle;\n  will-change:transform}\n.tg .tg-nrix{text-align:center;vertical-align:middle}\n\n\n\n  \n    常用API\n    含义\n  \n\n\n  \n    get()\n    读取单个字节\n  \n  \n    get(byte[] dst)\n    批量读取多个字节到 dst 中\n  \n  \n    get(int index)\n    读取指定索引位置的字节(不会移动 position)\n  \n  \n    put(byte b)\n    将给定单个字节写入缓冲区的当前位置\n  \n  \n    put(byte[] src)\n    将 src 中的字节写入缓冲区的当前位置\n  \n  \n    put(int index, byte b)\n    将指定字节写入缓冲区的索引位置(不会移动 position)\n  \n\n\n¶ByteBuffer使用案例\n✨ 使用Buffer读写数据一般遵循以下四个步骤：\n\n写入数据到Buffer\n调用flip()方法，转换为读模式\n从Buffer中读取数据\n调用buffer.clear()方法或者buffer.compact()方法切换至写模式\n\n一开始情况下，整个ByteBuffer中比较重要的三个属性(position,limit,capacity)初始化如下：\n\n写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态\n\nflip 动作发生后，position 切换为读取位置，limit 切换为读取限制\n\n读取 4 个字节后，状态\n\nclear 动作发生后，状态\n \ncompact 方法，是把未读完的部分向前压缩，然后切换至写模式\n\n¶向 buffer 写入数据\n存在两种方法向 buffer 中写入数据：\n\n调用 channel 的 read 方法\n\n1int readBytes = channel.read(buf);\n\n调用 buffer 自己的 put 方法\n\n1buf.put((byte)127);\n¶从 buffer 中读取数据\n同样存在两种方式从 buffer 中读取数据\n\n调用 channel 的 write 方法\n\n1int writeBytes = channel.write(buf);\n\n调用 buffer 自己的 get 方法\n\n1byte b = buf.get();\nget 方法会让 position 读指针向后走，如果想重复读取数据，有两种方法：\n\n调用 rewind 方法将 position 重新置为 0\n调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针\n\n\n¶mark 和 reset\nmark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置\n📓 rewind 和 flip 都会清除 mark 位置\n¶字符串与 ByteBuffer 互转\n123456//字符串转换为 bytebufferByteBuffer buffer1 = StandardCharsets.UTF_8.encode(&quot;你好&quot;);ByteBuffer buffer2 = Charset.forName(&quot;utf-8&quot;).encode(&quot;你好&quot;);//bytebuffer 转换为字符串 CharBuffer buffer3 = StandardCharsets.UTF_8.decode(buffer1);buffer3.toString();\n¶直接与非直接缓冲区\nbyte byffer可以是两种类型，一种是基于直接内存（也就是非堆内存）；另一种是非直接内存（也就是堆内存）。\n🆚 直接缓冲区与非直接缓冲区\n\n\n对于直接内存来说，JVM将会在IO操作上具有更高的性能，因为它直接作用于本地系统的IO操作\n\n\n非直接内存，也就是堆内存中的数据，如果要作IO操作，会先从本进程内存复制到直接内存，再利用本地IO处理\n\n\n从数据流的角度,非直接内存是下面这样的作用链：本地IO--&gt;直接内存--&gt;非直接内存--&gt;直接内存--&gt;本地IO\n\n\n直接内存是：本地IO--&gt;直接内存--&gt;本地IO\n\n\n\n在做IO处理时，比如网络发送大量数据时，直接内存会具有更高的效率。直接内存使用 allocateDirect 创建，但是它比申请普通的堆内存需要耗费更高的性能。\n不过，这部分的数据是在JVM之外的，因此它不会占用应用的内存。所以，当你有很大的数据要缓存，并且它的生命周期又很长，那么就比较适合使用直接内存。只是一般来说，如果不是能带来很明显的性能提升，还是推荐直接使用堆内存。\n字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect()  方法来确定。\n✨ 使用场景\n\n有很大的数据需要存储，它的生命周期又很长\n适合频繁的IO操作，比如网络并发场景\n\n\n¶分散和汇聚\n许多操作系统都能把组装/分解过程进行得更加高效。根据发散/汇聚的概念，进程只需一个系 统调用，就能把一连串缓冲区地址传递给操作系统。然后，内核就可以顺序填充或排干多个缓冲 区，读的时候就把数据发散到多个用户空间缓冲区，写的时候再从多个缓冲区把数据汇聚起来\n这样用户进程就不必多次执行系统调用，内核也可以优化数据的处理过程，因为它已掌握待传输数据的全部信息。如果系统配有多个 CPU ，甚至可以同时填充或排干多个缓冲区。\n¶Scattering reads\n分散读取，这样就可以一次性将读取到的内容分散在多个不同的 buffer 中，减少了一个 buffer 重复读取的次数。\n123456789101112131415try (RandomAccessFile file = new RandomAccessFile(&quot;helloword/3parts.txt&quot;, &quot;rw&quot;)) &#123;    FileChannel channel = file.getChannel();    ByteBuffer a = ByteBuffer.allocate(3);    ByteBuffer b = ByteBuffer.allocate(3);    ByteBuffer c = ByteBuffer.allocate(5);    channel.read(new ByteBuffer[]&#123;a, b, c&#125;);    a.flip();    b.flip();    c.flip();    debug(a);    debug(b);    debug(c);&#125; catch (IOException e) &#123;    e.printStackTrace();&#125;\n¶Gathering Writes\n12345678910111213141516try (RandomAccessFile file = new RandomAccessFile(&quot;helloword/3parts.txt&quot;, &quot;rw&quot;)) &#123;    FileChannel channel = file.getChannel();    ByteBuffer d = ByteBuffer.allocate(4);    ByteBuffer e = ByteBuffer.allocate(4);    channel.position(11);    d.put(new byte[]&#123;&#x27;f&#x27;, &#x27;o&#x27;, &#x27;u&#x27;, &#x27;r&#x27;&#125;);    e.put(new byte[]&#123;&#x27;f&#x27;, &#x27;i&#x27;, &#x27;v&#x27;, &#x27;e&#x27;&#125;);    d.flip();    e.flip();    debug(d);    debug(e);    channel.write(new ByteBuffer[]&#123;d, e&#125;);&#125; catch (IOException e) &#123;    e.printStackTrace();&#125;\n","dateCreated":"2022-04-18T16:52:12+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2022-04-18T16:52:12+00:00","description":"本文主要讲解 NIO 中的缓冲区","headline":"缓冲区","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/%E7%BC%93%E5%86%B2%E5%8C%BA/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/%E7%BC%93%E5%86%B2%E5%8C%BA/","keywords":"Java"}</script><meta name="description" content="本文主要讲解 NIO 中的缓冲区"><meta property="og:type" content="blog"><meta property="og:title" content="缓冲区"><meta property="og:url" content="https://pineapple-man.github.io/%E7%BC%93%E5%86%B2%E5%8C%BA/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="本文主要讲解 NIO 中的缓冲区"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/nio-buffer.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/nio-bytebuffer.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/bytebuffer-init.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/bytebuffer-write.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/bytebuffer-flip.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/bytebuffer-read.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/bytebuffer-init.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/bytebuffer-compact.png"><meta property="article:published_time" content="2022-04-18T16:52:12.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.011Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/nio-buffer.png"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">缓冲区</h1><div class="post-meta"><time datetime="2022-04-18T16:52:12+00:00">4月 18, 2022 </time><span>发布在 </span><a class="category-link" href="/categories/Java/">Java</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 2.6k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 27 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Buffer-%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%AD%90%E7%B1%BB"><span class="toc-text">Buffer 类及其子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7"><span class="toc-text">缓冲区的基本属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">缓冲区常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="toc-text">缓冲区的数据操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ByteBuffer%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">ByteBuffer使用案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91-buffer-%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">向 buffer 写入数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-buffer-%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-text">从 buffer 中读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mark-%E5%92%8C-reset"><span class="toc-text">mark 和 reset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E-ByteBuffer-%E4%BA%92%E8%BD%AC"><span class="toc-text">字符串与 ByteBuffer 互转</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%B8%8E%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">直接与非直接缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%95%A3%E5%92%8C%E6%B1%87%E8%81%9A"><span class="toc-text">分散和汇聚</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Scattering-reads"><span class="toc-text">Scattering reads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gathering-Writes"><span class="toc-text">Gathering Writes</span></a></li></ol></li></ol><h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><p>缓冲区是一个用于存储特定数据类型的容器，由 <code>java.nio</code> 包定义，目前常用的缓冲区都是 Buffer 抽象类的子类。Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互。在 NIO 中，如果用户想要消费数据，数据首先会从通道读入缓冲区，随后用户在缓冲区中消费数据。对应地，用户如果想要排出数据，数据首先会从缓冲区写入通道中，随后通过通道排出数据。具体的示意图如下：</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/nio-buffer.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/nio-buffer.png" alt=""></a></div><h2 id="Buffer-类及其子类"><a class="header-anchor" href="#Buffer-类及其子类">¶</a>Buffer 类及其子类</h2><p><strong>Buffer</strong> 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同，有以下常用子类：</p><style type="text/css">.tg{border-collapse:collapse;border-spacing:0;margin:0 auto}.tg td{border-style:solid;border-width:0;font-family:Arial,sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal}.tg th{border-style:solid;border-width:0;font-family:Arial,sans-serif;font-size:14px;font-weight:400;overflow:hidden;padding:10px 5px;word-break:normal}.tg .tg-u1qu{font-family:"Times New Roman",Times,serif!important;font-size:medium;text-align:center;vertical-align:middle}</style><table class="tg"><thead><tr><td class="tg-u1qu">ByteBuffer</td><td class="tg-u1qu">CharBuffer</td><td class="tg-u1qu">CharBuffer</td><td class="tg-u1qu">CharBuffer</td><td class="tg-u1qu">LongBuffer</td><td class="tg-u1qu">LongBuffer</td><td class="tg-u1qu">LongBuffer</td></tr></thead></table><p>上述 Buffer 类他们都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已。都是通过如下方法获取一个 Buffer 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个容量为 capacity 的 XxxBuffer 对象</span></span><br><span class="line"><span class="keyword">static</span> XxxBuffer <span class="title function_">allocate</span><span class="params">(<span class="type">int</span> capacity)</span>;</span><br></pre></td></tr></table></figure><div class="alert info no-icon"><p><font style="color:red;font-weight:700">Buffer 是非线程安全的</font></p></div><h2 id="缓冲区的基本属性"><a class="header-anchor" href="#缓冲区的基本属性">¶</a>缓冲区的基本属性</h2><p>一个缓冲区具有如下四个最重要的基本属性(<code>mark</code>、<code>position</code>、<code>limit</code>、<code>capacity</code>)，它们遵守以下不等式：<code>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</code></p><style type="text/css">.tg{border-collapse:collapse;border-color:#9abad9;border-spacing:0;margin:0 auto}.tg td{background-color:#ebf5ff;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial,sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal}.tg th{background-color:#409cff;border-color:#9abad9;border-style:solid;border-width:1px;color:#fff;font-family:Arial,sans-serif;font-size:14px;font-weight:400;overflow:hidden;padding:10px 5px;word-break:normal}.tg .tg-9wq8{border-color:inherit;text-align:center;vertical-align:middle}.tg .tg-ixdq{border-color:inherit;font-weight:700;position:-webkit-sticky;position:sticky;text-align:center;top:-1px;vertical-align:middle;will-change:transform}.tg .tg-uzvj{border-color:inherit;font-weight:700;text-align:center;vertical-align:middle}</style><table class="tg"><thead><tr><th class="tg-ixdq">基本属性</th><th class="tg-ixdq">含义</th></tr></thead><tbody><tr><td class="tg-uzvj">容量 (capacity)</td><td class="tg-9wq8">作为一个内存块，Buffer具有一定的固定大小，也称为"容量"，缓冲区容量不能为负，并且创建后不能更改</td></tr><tr><td class="tg-uzvj">限制 (limit)</td><td class="tg-9wq8">表示缓冲区中可以操作数据的大小（limit 后数据不能进行读写）。缓冲区的限制不能为负，并且不能大于其容量<span style="color:#a7a7a7"> </span>写入模式，限制等于buffer的容量<span style="color:#a7a7a7"> </span>读取模式下，limit等于写入的数据量</td></tr><tr><td class="tg-uzvj">位置（position)</td><td class="tg-9wq8">下一个要读取或写入的数据的索引。缓冲区的位置不能为 负，并且不能大于其限制(<span style="background-color:#f3f4f4">limit</span>)</td></tr><tr><td class="tg-uzvj">标记 (mark)与重置 (reset)</td><td class="tg-9wq8">标记是一个索引，通过 Buffer 中的 mark() 方法 指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这 个 position</td></tr></tbody></table><p>简单的相关操作如下：</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/nio-bytebuffer.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/nio-bytebuffer.png" alt=""></a></div><h2 id="缓冲区常用方法"><a class="header-anchor" href="#缓冲区常用方法">¶</a>缓冲区常用方法</h2><style type="text/css">.tg{border-collapse:collapse;border-color:#9abad9;border-spacing:0;margin:0 auto}.tg td{background-color:#ebf5ff;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial,sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal}.tg th{background-color:#409cff;border-color:#9abad9;border-style:solid;border-width:1px;color:#fff;font-family:Arial,sans-serif;font-size:14px;font-weight:400;overflow:hidden;padding:10px 5px;word-break:normal}.tg .tg-sx1p{font-weight:700;position:-webkit-sticky;position:sticky;text-align:center;top:-1px;vertical-align:middle;will-change:transform}.tg .tg-nrix{text-align:center;vertical-align:middle}</style><table class="tg"><thead><tr><th class="tg-sx1p">常用API</th><th class="tg-sx1p">含义</th></tr></thead><tbody><tr><td class="tg-nrix"><span style="background-color:#f3f4f4">Buffer clear()</span></td><td class="tg-nrix">清空缓冲区并返回对缓冲区的引用</td></tr><tr><td class="tg-nrix"><span style="background-color:#f3f4f4">Buffer flip()</span></td><td class="tg-nrix">将缓冲区的界限设置为当前位置，并将当前位置重置为 0，由写模式转换为读模式</td></tr><tr><td class="tg-nrix"><span style="background-color:#f3f4f4">int capacity()</span></td><td class="tg-nrix">返回 Buffer 的 capacity 大小</td></tr><tr><td class="tg-nrix"><span style="background-color:#f3f4f4">boolean hasRemaining()</span></td><td class="tg-nrix">判断缓冲区中是否还有元素</td></tr><tr><td class="tg-nrix"><span style="background-color:#f3f4f4">int limit()</span></td><td class="tg-nrix">返回 Buffer 的界限(limit) 的位置</td></tr><tr><td class="tg-nrix"><span style="background-color:#f3f4f4">Buffer limit(int n)</span></td><td class="tg-nrix">设置缓冲区界限为 n, 并返回一个具有新 limit 的缓冲区对象</td></tr><tr><td class="tg-nrix"><span style="background-color:#f3f4f4">Buffer mark()</span></td><td class="tg-nrix">对缓冲区设置标记</td></tr><tr><td class="tg-nrix"><span style="background-color:#f3f4f4">int position()</span></td><td class="tg-nrix">返回缓冲区的当前位置 position</td></tr><tr><td class="tg-nrix"><span style="background-color:#f3f4f4">Buffer position(int n)</span></td><td class="tg-nrix">将设置缓冲区的当前位置为 n , 并返回修改后的 Buffer 对象</td></tr><tr><td class="tg-nrix"><span style="background-color:#f3f4f4">int remaining()</span></td><td class="tg-nrix">返回 position 和 limit 之间的元素个数</td></tr><tr><td class="tg-nrix"><span style="background-color:#f3f4f4">Buffer reset()</span></td><td class="tg-nrix">将位置 position 转到以前设置的 mark 所在的位置</td></tr><tr><td class="tg-nrix"><span style="background-color:#f3f4f4">Buffer rewind()</span></td><td class="tg-nrix">将位置设为为 0， 取消设置的 mark</td></tr></tbody></table><h2 id="缓冲区的数据操作"><a class="header-anchor" href="#缓冲区的数据操作">¶</a>缓冲区的数据操作</h2><p>Buffer 所有子类提供了两个数据操作的方法：<code>get() &amp; put()</code>方法来获取及写入 Buffer中的数据</p><style type="text/css">.tg{border-collapse:collapse;border-color:#9abad9;border-spacing:0;margin:0 auto}.tg td{background-color:#ebf5ff;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial,sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal}.tg th{background-color:#409cff;border-color:#9abad9;border-style:solid;border-width:1px;color:#fff;font-family:Arial,sans-serif;font-size:14px;font-weight:400;overflow:hidden;padding:10px 5px;word-break:normal}.tg .tg-sx1p{font-weight:700;position:-webkit-sticky;position:sticky;text-align:center;top:-1px;vertical-align:middle;will-change:transform}.tg .tg-nrix{text-align:center;vertical-align:middle}</style><table class="tg"><thead><tr><th class="tg-sx1p">常用API</th><th class="tg-sx1p">含义</th></tr></thead><tbody><tr><td class="tg-nrix"><span style="background-color:#f3f4f4">get()</span></td><td class="tg-nrix">读取单个字节</td></tr><tr><td class="tg-nrix"><span style="background-color:#f3f4f4">get(byte[] dst)</span></td><td class="tg-nrix">批量读取多个字节到 dst 中</td></tr><tr><td class="tg-nrix"><span style="background-color:#f3f4f4">get(int index)</span></td><td class="tg-nrix">读取指定索引位置的字节(不会移动 position)</td></tr><tr><td class="tg-nrix"><span style="background-color:#f3f4f4">put(byte b)</span></td><td class="tg-nrix">将给定单个字节写入缓冲区的当前位置</td></tr><tr><td class="tg-nrix"><span style="background-color:#f3f4f4">put(byte[] src)</span></td><td class="tg-nrix">将 src 中的字节写入缓冲区的当前位置</td></tr><tr><td class="tg-nrix"><span style="background-color:#f3f4f4">put(int index, byte b)</span></td><td class="tg-nrix">将指定字节写入缓冲区的索引位置(不会移动 position)</td></tr></tbody></table><h2 id="ByteBuffer使用案例"><a class="header-anchor" href="#ByteBuffer使用案例">¶</a><code>ByteBuffer</code>使用案例</h2><p>✨ <strong>使用Buffer读写数据一般遵循以下四个步骤：</strong></p><ol><li>写入数据到Buffer</li><li>调用<code>flip()</code>方法，转换为<strong>读模式</strong></li><li>从Buffer中读取数据</li><li>调用<code>buffer.clear()</code>方法或者<code>buffer.compact()</code>方法切换至<strong>写模式</strong></li></ol><p>一开始情况下，整个<code>ByteBuffer</code>中比较重要的三个属性(<code>position</code>,<code>limit</code>,<code>capacity</code>)初始化如下：</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/bytebuffer-init.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/bytebuffer-init.png" alt=""></a></div><p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/bytebuffer-write.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/bytebuffer-write.png" alt=""></a></div><p>flip 动作发生后，position 切换为读取位置，limit 切换为读取限制</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/bytebuffer-flip.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/bytebuffer-flip.png" alt=""></a></div><p>读取 4 个字节后，状态</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/bytebuffer-read.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/bytebuffer-read.png" alt=""></a></div><p>clear 动作发生后，状态</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/bytebuffer-init.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/bytebuffer-init.png" alt=""></a></div><p>compact 方法，是把未读完的部分向前压缩，然后切换至写模式</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/bytebuffer-compact.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/io/bytebuffer-compact.png" alt=""></a></div><h3 id="向-buffer-写入数据"><a class="header-anchor" href="#向-buffer-写入数据">¶</a>向 buffer 写入数据</h3><p>存在两种方法向 buffer 中写入数据：</p><ol><li>调用 channel 的 read 方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buf);</span><br></pre></td></tr></table></figure><ol start="2"><li>调用 buffer 自己的 put 方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put((<span class="type">byte</span>)<span class="number">127</span>);</span><br></pre></td></tr></table></figure><h3 id="从-buffer-中读取数据"><a class="header-anchor" href="#从-buffer-中读取数据">¶</a>从 buffer 中读取数据</h3><p>同样存在两种方式从 buffer 中读取数据</p><ol><li>调用 channel 的 write 方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">writeBytes</span> <span class="operator">=</span> channel.write(buf);</span><br></pre></td></tr></table></figure><ol start="2"><li>调用 buffer 自己的 get 方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> buf.get();</span><br></pre></td></tr></table></figure><p>get 方法会让 position 读指针向后走，如果想重复读取数据，有两种方法：</p><div class="alert success no-icon"><ol><li>调用 rewind 方法将 position 重新置为 0</li><li>调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针</li></ol></div><h3 id="mark-和-reset"><a class="header-anchor" href="#mark-和-reset">¶</a>mark 和 reset</h3><p>mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置</p><p>📓 rewind 和 flip 都会清除 mark 位置</p><h3 id="字符串与-ByteBuffer-互转"><a class="header-anchor" href="#字符串与-ByteBuffer-互转">¶</a>字符串与 ByteBuffer 互转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串转换为 bytebuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;utf-8&quot;</span>).encode(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="comment">//bytebuffer 转换为字符串 </span></span><br><span class="line"><span class="type">CharBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> StandardCharsets.UTF_8.decode(buffer1);</span><br><span class="line">buffer3.toString();</span><br></pre></td></tr></table></figure><h2 id="直接与非直接缓冲区"><a class="header-anchor" href="#直接与非直接缓冲区">¶</a>直接与非直接缓冲区</h2><p><code>byte byffer</code>可以是两种类型，一种是基于直接内存（也就是非堆内存）；另一种是非直接内存（也就是堆内存）。</p><p>🆚 直接缓冲区与非直接缓冲区</p><div class="alert success no-icon"><ul><li><p>对于直接内存来说，JVM将会在IO操作上具有更高的性能，因为它直接作用于本地系统的IO操作</p></li><li><p>非直接内存，也就是堆内存中的数据，如果要作IO操作，会先从本进程内存复制到直接内存，再利用本地IO处理</p></li><li><p>从数据流的角度,非直接内存是下面这样的作用链：<code>本地IO--&gt;直接内存--&gt;非直接内存--&gt;直接内存--&gt;本地IO</code></p></li><li><p>直接内存是：<code>本地IO--&gt;直接内存--&gt;本地IO</code></p></li></ul></div><p>在做IO处理时，比如网络发送大量数据时，直接内存会具有更高的效率。直接内存使用 allocateDirect 创建，但是它比申请普通的堆内存需要耗费更高的性能。</p><p>不过，这部分的数据是在JVM之外的，因此它不会占用应用的内存。所以，当你有很大的数据要缓存，并且它的生命周期又很长，那么就比较适合使用直接内存。只是一般来说，如果不是能带来很明显的性能提升，还是推荐直接使用堆内存。</p><p>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect() 方法来确定。</p><p>✨ <strong>使用场景</strong></p><div class="alert success no-icon"><ul><li>有很大的数据需要存储，它的生命周期又很长</li><li>适合频繁的IO操作，比如网络并发场景</li></ul></div><h2 id="分散和汇聚"><a class="header-anchor" href="#分散和汇聚">¶</a>分散和汇聚</h2><p>许多操作系统都能把组装/分解过程进行得更加高效。根据发散/汇聚的概念，进程只需一个系 统调用，就能把一连串缓冲区地址传递给操作系统。然后，内核就可以顺序填充或排干多个缓冲 区，读的时候就把数据发散到多个用户空间缓冲区，写的时候再从多个缓冲区把数据汇聚起来</p><p>这样用户进程就不必多次执行系统调用，内核也可以优化数据的处理过程，因为它已掌握待传输数据的全部信息。如果系统配有多个 CPU ，甚至可以同时填充或排干多个缓冲区。</p><h3 id="Scattering-reads"><a class="header-anchor" href="#Scattering-reads">¶</a>Scattering reads</h3><p>分散读取，这样就可以一次性将读取到的内容分散在多个不同的 buffer 中，减少了一个 buffer 重复读取的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;helloword/3parts.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">a</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">b</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">c</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    channel.read(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;a, b, c&#125;);</span><br><span class="line">    a.flip();</span><br><span class="line">    b.flip();</span><br><span class="line">    c.flip();</span><br><span class="line">    debug(a);</span><br><span class="line">    debug(b);</span><br><span class="line">    debug(c);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Gathering-Writes"><a class="header-anchor" href="#Gathering-Writes">¶</a>Gathering Writes</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;helloword/3parts.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">d</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">e</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    channel.position(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    d.put(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;);</span><br><span class="line">    e.put(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;);</span><br><span class="line">    d.flip();</span><br><span class="line">    e.flip();</span><br><span class="line">    debug(d);</span><br><span class="line">    debug(e);</span><br><span class="line">    channel.write(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;d, e&#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/Java/" rel="tag">Java</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5/" data-tooltip="混淆矩阵" aria-label="上一篇: 混淆矩阵"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" data-tooltip="分布式系统概述" aria-label="下一篇: 分布式系统概述"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5/" data-tooltip="混淆矩阵" aria-label="上一篇: 混淆矩阵"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" data-tooltip="分布式系统概述" aria-label="下一篇: 分布式系统概述"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>