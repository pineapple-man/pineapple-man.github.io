<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>JJWT - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="JJWT"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\nJWT 的声明一般被用来在客户端和服务端间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑信息\n¶概述\nJJWT 旨在成为最易使用和理解的库，用于在 JVM 和 Android 上创建和验证 JSON Web 令牌，JWT本身是支持加密签名的，在使用签名的JWT时，需要注意一下两点：\n\n保证 JWT 是由认识的人创建的（JWT 是真实的）\n保证在创建 JWT 之后没有操纵或改变 JWT（保持其完整性）\n\n\n真实性和完整性 保证JWT包含可以信任的信息。 如果JWT未通过真实性或完整性检查，应该始终拒绝JWT，因为我们无法信任它\n¶Hello World\n仍然按照常见的套路（依赖，HelloWorld，详细概念）三步骤学习一个第三方库\n¶依赖\n1234567891011121314151617&lt;dependency&gt;    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;    &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;    &lt;version&gt;0.10.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;    &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;    &lt;version&gt;0.10.5&lt;/version&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;    &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;    &lt;version&gt;0.10.5&lt;/version&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;\n¶创建 JWT\n12345678public static void main(String[] args) &#123;\t\tSecretKey key = Keys.secretKeyFor(SignatureAlgorithm.HS256);\t\tString jws = Jwts.builder()            .setSubject(&quot;pineapple-man&quot;).signWith(key)            .compact();\t\tSystem.out.println(jws);    /**eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJwaW5lYXBwbGUtbWFuIn0.moDrltTQbK9mhQflt8_KfVtQY-5NrZg4uvRyz5k-DzQ*/&#125;\n上述代码中，构建了一个主题为pineapple-man的 JWT，使用的是HMAC-SHA-256算法的密钥对 JWT 进行签名，并在最终将它压缩成 String 形式\n¶解析 JWT\n12345678public static void main(String[] args) &#123;\tSecretKey key = Keys.secretKeyFor(SignatureAlgorithm.HS256);\tString jws = Jwts.builder().setSubject(&quot;pineapple-man&quot;).signWith(key).compact();\tSystem.out.println(jws);       //解析System.out.println(Jwts.parser().setSigningKey(key).parseClaimsJws(jws)\t\t\t.getBody().getSubject().equals(&quot;pineapple-man&quot;));&#125;\n将之前的密钥用于验证JWT的签名，如果它无法验证JWT，则抛出SignatureException。如果在做 JWT 解析时，发生了验证失败的现象，可以通过捕获JwtException异常来自定义失败情况下的处理\n123456try &#123;    Jwts.parser().setSigningKey(key).parseClaimsJws(compactJws);    //OK, we can trust this JWT&#125; catch (JwtException e) &#123;    //don&#x27;t trust the JWT!&#125;\n¶JWS\nJWS 就是已经签名的 JWT，下面展示了如何手动实现 JWS\n12345678910111213//头部信息String header = &quot;&#123;&#x27;alg&#x27;:&#x27;HS256&#x27;&#125;&quot;;String claims = &quot;&#123;&#x27;sub&#x27;:&#x27;pineapple-man&#x27;&#125;&quot;;//对他们分别进行`UTF_8`编码：byte[] encodedHeader = Base64.getEncoder().encode(header.getBytes(StandardCharsets.UTF_8));byte[] encodedClaims = Base64.getEncoder().encode(claims.getBytes(StandardCharsets.UTF_8));//将编码后的Header和Body使用.进行分隔，并连接成一个字符串String concatenated = Arrays.toString(encodedHeader) + &quot;.&quot; + Arrays.toString(encodedClaims);//使用加密私钥，选择签名算法（此处使用HMAC-SHA-256），并对连接的字符串进行签名Key key = getMySecretKey()byte[] signature = hmacSha256( concatenated, key )//由于签名始终结果是字节数组，因此Base64URL对签名进行编码并使用.将它连接到字符串concatenated后面String jws = concatenated + &#x27;.&#x27; + Base64.getEncoder().encode( signature )\n以上就是 JWS（已经签名的 JWT）生成过程的实现方式\n¶创建 JWS\n可以使用这种方式创建JWS：\n\n使用Jwts.builder()方法创建JwtBuilder实例\n调用JwtBuilder方法根据需要添加标头参数和声明\n指定要用于对JWT进行签名的SecretKey或非对称PrivateKey\n调用compact()方法进行压缩和签名，生成最终的jws\n\n12345String jws = Jwts.builder() \t// (1)    .setSubject(&quot;pineapple-man&quot;)      \t// (2)    .signWith(key)          \t// (3)    .compact();             \t// (4)\n¶设置 Header Parameters\nJWT Header提供关于JWT Claims相关的内容，格式和加密操作的元数据\n如果需要设置一个或多个JWT头参数，则可以根据需要简单地多次调用JwtBuilder.setHeaderParam\n123String jws = Jwts.builder()    .setHeaderParam(&quot;kid&quot;, &quot;myKeyId&quot;)    // ... etc ...\n每次调用setHeaderParam时，它只是将键值对附加到内部Header实例，如果键值已经存在，则会覆盖任何现有的同名键/值对\n🎶不需要设置alg或zip标头参数，因为JJWT会根据使用的签名算法或压缩算法自动设置它们\n\n除此之外，还可以使用其他方式，设置JWT Header，由于第一种方式能够完成常见的业务场景，其余的方式这里并不阐述\n¶设置 Claims\nClaims是JWT的正文部分，包含JWT创建者希望向JWT收件人提供的信息，常见的 API 如下\n\n\n\nAPI\n含义\n\n\n\n\nsetIssuer\nsets the iss (Issuer) Claim\n\n\nsetSubject\nsets the sub (Subject) Claim\n\n\nsetAudience\nsets the aud (Audience) Claim\n\n\nsetExpiration\nsets the exp (Expiration Time) Claim\n\n\nsetNotBefore\nsets the nbf (Not Before) Claim\n\n\nsetIssuedAt\nsets the iat (Issued At) Claim\n\n\nsetId\nsets the jti (JWT ID) Claim\n\n\n\n12345678910String jws = Jwts.builder()    .setIssuer(&quot;me&quot;)    .setSubject(&quot;Bob&quot;)    .setAudience(&quot;you&quot;)    .setExpiration(expiration) \t//a java.util.Date    .setNotBefore(notBefore) \t//a java.util.Date    .setIssuedAt(new Date()) \t// for example, now    .setId(UUID.randomUUID()) \t//just an example id    /// ... etc ...\n当然也可以自定义 Claims，如果需要设置一个或多个与上面显示的标准 setter 方法声明不匹配的自定义声明，可以根据需要多次调用JwtBuilde.claim 声明：\n123String jws = Jwts.builder()    .claim(&quot;hello&quot;, &quot;world&quot;)    // ... etc ...\n每次调用claim时，它只是将键值对附加到内部claims实例，如果键值已经存在，则会覆盖任何现有的同名key/value对，同头部信息一样\n¶签名\nJWT 规范确定了 12 种标准签名算法，三种密钥算法和九种非对称密钥算法，由于也不是做密码学的这里也不过多展开。自己项目中常见的使用HMAC-SHA-256就足够了\n👴建议通过调用JwtBuilder的signWith方法来指定签名密钥，以及对应的摘要算法，示例如下：\n1234String jws = Jwts.builder()   // ... etc ...   .signWith(key) // &lt;---   .compact();\n使用signWith时，JJWT还会自动使用相关的算法标识符设置所需的alg头。类似地，如果使用长度为 4096 位的RSA PrivateKey调用signWith，JJWT将使用RS512算法并自动将alg头设置为RS512\n🎶不能用PublicKeys签署JWT，因为这总是不安全的。 JJWT将拒绝任何指定的PublicKey的方式签名，并抛出异常：InvalidKeyException\n\n¶解析 JWS\n⛵解析 JWS 步骤如下：\n\n使用Jwts.parser()方法创建JwtParser实例\n指定要用于验证JWS签名的SecretKey或非对称PublicKey\n调用parseClaimsJws(String)方法，生成原始JWS\n\n🎶如之前所述，整个调用将包装在try/catch块中，以防解析或签名验证失败\n12345678910Jws&lt;Claims&gt; jws;try &#123;    jws = Jwts.parser()         \t// (1)    .setSigningKey(key)         \t// (2)    .parseClaimsJws(jwsString); \t// (3)    // we can safely trust the JWTcatch (JwtException ex) &#123;    // we cannot use the JWT as intended by its creator&#125;\n¶校验 Key\n阅读JWS时，最重要的事情是指定用于验证 JWS 加密签名的密钥。 如果签名验证失败，则无法安全地信任此JWT，应将其丢弃。如果jws是使用SecretKey签名的，则应在JwtParser上指定相同的SecretKey\n123Jwts.parser()  .setSigningKey(secretKey) // &lt;----  .parseClaimsJws(jwsString);\n如果jws是使用PrivateKey签名的，那么应该在JwtParser上指定该密钥相应的PublicKey（不是PrivateKey）\n123Jwts.parser()  .setSigningKey(publicKey) // &lt;---- publicKey, not privateKey  .parseClaimsJws(jwsString);\n❓如果应用程序不止使用一个 SecretKey 或 KeyPair 会怎么样？ 如果可以使用不同的 SecretKeys 或公钥/私钥或两者的组合创建 JWS，该怎么办？\n在这些情况下，无法使用单个键调用JwtParser的setSigningKey方法。相反，需要使用SigningKeyResolver方法指定解析 JWS 方法\n\n12345//实现了 SigningKeyResolver 接口的自定义解析类SigningKeyResolver signingKeyResolver = getMySigningKeyResolver();Jwts.parser()    .setSigningKeyResolver(signingKeyResolver) // &lt;----    .parseClaimsJws(jwsString);\n通过实现SigningKeyResolverAdapter接口的resolveSigningKey(JwsHeader，Claims)方法来简化一些事情\n123456public class MySigningKeyResolver extends SigningKeyResolverAdapter &#123;    @Override    public Key resolveSigningKey(JwsHeader jwsHeader, Claims claims) &#123;        // implement    &#125;&#125;\n在解析JWS JSON之后，JwtParser将在验证jws签名之前调用resolveSigningKey()方法。 这也就允许检查Jws Header和Claims参数，以帮助查找用于验证特定jws的密钥的信息。 这对于复杂安全模型的应用程序非常强大，这些安全模型可能在不同时间使用不同的密钥或针对不同的用户或客。JWT规范支持的方法是在创建JWS时，在JWS头中设置kid（Key ID）字段，例如：\n123456Key signingKey = getSigningKey();String keyId = getKeyId(signingKey); \t\t//any mechanism you have to associate a key with an ID is fineString jws = Jwts.builder()    .setHeaderParam(JwsHeader.KEY_ID, keyId) // 1    .signWith(signingKey)                    // 2    .compact();\n然后在解析期间，SigningKeyResolver可以检查JwsHeader以获取该kid，然后使用该值从某个位置查找密钥，如数据库。 例如：\n123456789public class MySigningKeyResolver extends SigningKeyResolverAdapter &#123;    @Override    public Key resolveSigningKey(JwsHeader jwsHeader, Claims claims) &#123;        //inspect the header or claims, lookup and return the signing key        String keyId = jwsHeader.getKeyId(); \t//or any other field that you need to inspect        Key key = lookupVerificationKey(keyId); //implement me        return key;    &#125;&#125;\n🎶检查jwsHeader.getKeyId()只是查找密钥的最常用方法，也可以检查任意数量的标头字段或声明，以确定如何查找验证密钥。\n¶Claims 断言\n如果正在解析的JWS具有特定的子sub值，可以使用JwtParser上的各种require *方法来获取数据\n12345try &#123;    Jwts.parser().requireSubject(&quot;pineapple-man&quot;).setSigningKey(key).parseClaimsJws(s);&#125; catch(InvalidClaimException ice) &#123;    // the sub field was missing or did not have a &#x27;pineapple-man&#x27; value&#125;\n如果缺少某个值，那么就不会捕获InvalidClaimException，而是捕获MissingClaimException或IncorrectClaimException异常\n1234567try &#123;    Jwts.parser().requireSubject(&quot;pineapple-man&quot;).setSigningKey(key).parseClaimsJws(s);&#125; catch(MissingClaimException mce) &#123;    // the parsed JWT did not have the sub field&#125; catch(IncorrectClaimException ice) &#123;    // the parsed JWT had a sub field, but its value was not equal to &#x27;pineapple-man&#x27;&#125;\n当然，也可以使用require(fieldName，requiredFieldValue)方法来获取自定义字段。\n12345try &#123;\tJwts.parser().require(&quot;field&quot;,&quot;requiredValue&quot;).setSigningKey(key).parseClaimsJws(s);&#125; catch(InvalidClaimException ice) &#123;    // the &#x27;myfield&#x27; field was missing or did not have a &#x27;myRequiredValue&#x27; value&#125;\n¶压缩\n如果JWT的Claim域可以足够大，包含许多key/value对；或者单个值非常冗长，可以通过压缩来减小创建的JWS的大小\n例如：如果在URL中使用生成的JWS，压缩将很重要，因为浏览器，用户邮件代理或 HTTP 网关兼容性问题，URL最好保持在4096个字符以下，所以较小的JWT有助于降低带宽利用率\n\n¶默认压缩\n如果要压缩JWT，可以使用JwtBuilder 的compressWith(CompressionAlgorithm)方法。 例如：\n123Jwts.builder()   .compressWith(CompressionCodecs.DEFLATE) // or CompressionCodecs.GZIP   // .. etc ...\n使用DEFLATE或GZIP压缩编解码器，但是在解压缩时，不必执行任何操作，不需要配置JwtParser，JJWT将按预期自动解压缩主体\n¶自定义压缩\n如果在创建JWT时使用自己的自定义压缩编解码器（通过JwtBuilder.compressWith），则需要使用setCompressionCodecResolver方法将编解码器提供给JwtParser。 例如：\n1234CompressionCodecResolver ccr = new MyCompressionCodecResolver();Jwts.parser()    .setCompressionCodecResolver(ccr) // &lt;----    // .. etc ...\n通常，CompressionCodecResolver实现将检查zip标头以找出使用的算法，然后返回支持该算法的编解码器实例。 例如：\n123456789101112public class MyCompressionCodecResolver implements CompressionCodecResolver &#123;    @Override    public CompressionCodec resolveCompressionCodec(Header header) throws CompressionException &#123;        String alg = header.getCompressionAlgorithm();        CompressionCodec codec = getCompressionCodec(alg); //implement        return codec;    &#125;&#125;\n¶附录\nJava Web Token 之 JJWT 使用\n","dateCreated":"2021-11-27T04:08:32+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2021-11-27T04:08:32+00:00","description":"本文主要讲解如何使用 JJWT 进行 JWT","headline":"JJWT","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/jjwt/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/jjwt/","keywords":"中间件"}</script><meta name="description" content="本文主要讲解如何使用 JJWT 进行 JWT"><meta property="og:type" content="blog"><meta property="og:title" content="JJWT"><meta property="og:url" content="https://pineapple-man.github.io/jjwt/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="本文主要讲解如何使用 JJWT 进行 JWT"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-11-27T04:08:32.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.015Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="中间件"><meta name="twitter:card" content="summary"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">JJWT</h1><div class="post-meta"><time datetime="2021-11-27T04:08:32+00:00">11月 27, 2021 </time><span>发布在 </span><a class="category-link" href="/categories/Java/">Java</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 2.7k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 29 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hello-World"><span class="toc-text">Hello World</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96"><span class="toc-text">依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-JWT"><span class="toc-text">创建 JWT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-JWT"><span class="toc-text">解析 JWT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JWS"><span class="toc-text">JWS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-JWS"><span class="toc-text">创建 JWS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-Header-Parameters"><span class="toc-text">设置 Header Parameters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-Claims"><span class="toc-text">设置 Claims</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%BE%E5%90%8D"><span class="toc-text">签名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-JWS"><span class="toc-text">解析 JWS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C-Key"><span class="toc-text">校验 Key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Claims-%E6%96%AD%E8%A8%80"><span class="toc-text">Claims 断言</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9"><span class="toc-text">压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8E%8B%E7%BC%A9"><span class="toc-text">默认压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8E%8B%E7%BC%A9"><span class="toc-text">自定义压缩</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol><p>JWT 的声明一般被用来在客户端和服务端间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑信息</p><h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><p>JJWT 旨在成为最易使用和理解的库，用于在 JVM 和 Android 上创建和验证 JSON Web 令牌，<code>JWT</code>本身是支持加密签名的，在使用签名的<code>JWT</code>时，需要注意一下两点：</p><div class="alert success no-icon"><ul><li>保证 JWT 是由认识的人创建的（JWT 是真实的）</li><li>保证在创建 JWT 之后没有操纵或改变 JWT（保持其完整性）</li></ul></div><p><code>真实性</code>和<code>完整性</code> 保证<code>JWT</code>包含可以信任的信息。 如果<code>JWT</code>未通过<strong>真实性</strong>或<strong>完整性</strong>检查，应该始终拒绝<code>JWT</code>，因为我们无法信任它</p><h2 id="Hello-World"><a class="header-anchor" href="#Hello-World">¶</a>Hello World</h2><p>仍然按照常见的套路（依赖，HelloWorld，详细概念）三步骤学习一个第三方库</p><h3 id="依赖"><a class="header-anchor" href="#依赖">¶</a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建-JWT"><a class="header-anchor" href="#创建-JWT">¶</a>创建 JWT</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> Keys.secretKeyFor(SignatureAlgorithm.HS256);</span><br><span class="line">		<span class="type">String</span> <span class="variable">jws</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">            .setSubject(<span class="string">&quot;pineapple-man&quot;</span>).signWith(key)</span><br><span class="line">            .compact();</span><br><span class="line">		System.out.println(jws);</span><br><span class="line">    <span class="comment">/**eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJwaW5lYXBwbGUtbWFuIn0.moDrltTQbK9mhQflt8_KfVtQY-5NrZg4uvRyz5k-DzQ*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，构建了一个主题为<code>pineapple-man</code>的 JWT，使用的是<code>HMAC-SHA-256</code>算法的密钥对 JWT 进行签名，并在最终将它压缩成 String 形式</p><h3 id="解析-JWT"><a class="header-anchor" href="#解析-JWT">¶</a>解析 JWT</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> Keys.secretKeyFor(SignatureAlgorithm.HS256);</span><br><span class="line">	<span class="type">String</span> <span class="variable">jws</span> <span class="operator">=</span> Jwts.builder().setSubject(<span class="string">&quot;pineapple-man&quot;</span>).signWith(key).compact();</span><br><span class="line">	System.out.println(jws);</span><br><span class="line">       <span class="comment">//解析</span></span><br><span class="line">System.out.println(Jwts.parser().setSigningKey(key).parseClaimsJws(jws)</span><br><span class="line">			.getBody().getSubject().equals(<span class="string">&quot;pineapple-man&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将之前的密钥用于验证<code>JWT</code>的签名，如果它无法验证<code>JWT</code>，则抛出<code>SignatureException</code>。如果在做 JWT 解析时，发生了验证失败的现象，可以通过捕获<code>JwtException</code>异常来自定义失败情况下的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Jwts.parser().setSigningKey(key).parseClaimsJws(compactJws);</span><br><span class="line">    <span class="comment">//OK, we can trust this JWT</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">    <span class="comment">//don&#x27;t trust the JWT!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JWS"><a class="header-anchor" href="#JWS">¶</a>JWS</h2><p>JWS 就是已经签名的 JWT，下面展示了如何手动实现 JWS</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头部信息</span></span><br><span class="line">String header = <span class="string">&quot;&#123;&#x27;alg&#x27;:&#x27;HS256&#x27;&#125;&quot;</span>;</span><br><span class="line">String claims = <span class="string">&quot;&#123;&#x27;sub&#x27;:&#x27;pineapple-man&#x27;&#125;&quot;</span>;</span><br><span class="line"><span class="comment">//对他们分别进行`UTF_8`编码：</span></span><br><span class="line">byte<span class="punctuation">[</span><span class="punctuation">]</span> encodedHeader = Base64.getEncoder().encode(header.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">byte<span class="punctuation">[</span><span class="punctuation">]</span> encodedClaims = Base64.getEncoder().encode(claims.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"><span class="comment">//将编码后的Header和Body使用.进行分隔，并连接成一个字符串</span></span><br><span class="line">String concatenated = Arrays.toString(encodedHeader) + <span class="string">&quot;.&quot;</span> + Arrays.toString(encodedClaims);</span><br><span class="line"><span class="comment">//使用加密私钥，选择签名算法（此处使用HMAC-SHA-256），并对连接的字符串进行签名</span></span><br><span class="line">Key key = getMySecretKey()</span><br><span class="line">byte<span class="punctuation">[</span><span class="punctuation">]</span> signature = hmacSha256( concatenated<span class="punctuation">,</span> key )</span><br><span class="line"><span class="comment">//由于签名始终结果是字节数组，因此Base64URL对签名进行编码并使用.将它连接到字符串concatenated后面</span></span><br><span class="line">String jws = concatenated + &#x27;.&#x27; + Base64.getEncoder().encode( signature )</span><br></pre></td></tr></table></figure><p>以上就是 JWS（已经签名的 JWT）生成过程的实现方式</p><h3 id="创建-JWS"><a class="header-anchor" href="#创建-JWS">¶</a>创建 JWS</h3><p>可以使用这种方式创建<code>JWS</code>：</p><ol><li>使用<code>Jwts.builder()</code>方法创建<code>JwtBuilder</code>实例</li><li>调用<code>JwtBuilder</code>方法根据需要添加标头参数和声明</li><li>指定要用于对<code>JWT</code>进行签名的<code>SecretKey</code>或<code>非对称PrivateKey</code></li><li>调用<code>compact()</code>方法进行压缩和签名，生成最终的<code>jws</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jws</span> <span class="operator">=</span> Jwts.builder() 	<span class="comment">// (1)</span></span><br><span class="line">    .setSubject(<span class="string">&quot;pineapple-man&quot;</span>)      	<span class="comment">// (2)</span></span><br><span class="line">    .signWith(key)          	<span class="comment">// (3)</span></span><br><span class="line">    .compact();             	<span class="comment">// (4)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="设置-Header-Parameters"><a class="header-anchor" href="#设置-Header-Parameters">¶</a>设置 Header Parameters</h4><p><code>JWT Header</code>提供关于<code>JWT Claims</code>相关的内容，格式和加密操作的元数据</p><p>如果需要设置一个或多个<code>JWT</code>头参数，则可以根据需要简单地多次调用<code>JwtBuilder.setHeaderParam</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jws</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">    .setHeaderParam(<span class="string">&quot;kid&quot;</span>, <span class="string">&quot;myKeyId&quot;</span>)</span><br><span class="line">    <span class="comment">// ... etc ...</span></span><br></pre></td></tr></table></figure><p>每次调用<code>setHeaderParam</code>时，它只是将键值对附加到内部<code>Header</code>实例，如果键值已经存在，则会覆盖任何现有的同名键/值对</p><div class="alert info no-icon"><p>🎶不需要设置<code>alg</code>或<code>zip</code>标头参数，因为<code>JJWT</code>会根据使用的签名算法或压缩算法自动设置它们</p></div><p>除此之外，还可以使用其他方式，设置<code>JWT Header</code>，由于第一种方式能够完成常见的业务场景，其余的方式这里并不阐述</p><h4 id="设置-Claims"><a class="header-anchor" href="#设置-Claims">¶</a>设置 Claims</h4><p><code>Claims</code>是<code>JWT</code>的正文部分，包含<code>JWT</code>创建者希望向<code>JWT</code>收件人提供的信息，常见的 API 如下</p><table><thead><tr><th style="text-align:center">API</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>setIssuer</code></td><td style="text-align:center">sets the <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7519#section-4.1.1"><code>iss</code> (Issuer) Claim</a></td></tr><tr><td style="text-align:center"><code>setSubject</code></td><td style="text-align:center">sets the <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7519#section-4.1.2"><code>sub</code> (Subject) Claim</a></td></tr><tr><td style="text-align:center"><code>setAudience</code></td><td style="text-align:center">sets the <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7519#section-4.1.3"><code>aud</code> (Audience) Claim</a></td></tr><tr><td style="text-align:center"><code>setExpiration</code></td><td style="text-align:center">sets the <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7519#section-4.1.4"><code>exp</code> (Expiration Time) Claim</a></td></tr><tr><td style="text-align:center"><code>setNotBefore</code></td><td style="text-align:center">sets the <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7519#section-4.1.5"><code>nbf</code> (Not Before) Claim</a></td></tr><tr><td style="text-align:center"><code>setIssuedAt</code></td><td style="text-align:center">sets the <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7519#section-4.1.6"><code>iat</code> (Issued At) Claim</a></td></tr><tr><td style="text-align:center"><code>setId</code></td><td style="text-align:center">sets the <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7519#section-4.1.7"><code>jti</code> (JWT ID) Claim</a></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jws</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">    .setIssuer(<span class="string">&quot;me&quot;</span>)</span><br><span class="line">    .setSubject(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">    .setAudience(<span class="string">&quot;you&quot;</span>)</span><br><span class="line">    .setExpiration(expiration) 	<span class="comment">//a java.util.Date</span></span><br><span class="line">    .setNotBefore(notBefore) 	<span class="comment">//a java.util.Date</span></span><br><span class="line">    .setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>()) 	<span class="comment">// for example, now</span></span><br><span class="line">    .setId(UUID.randomUUID()) 	<span class="comment">//just an example id</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// ... etc ...</span></span><br></pre></td></tr></table></figure><p>当然也可以自定义 Claims，如果需要设置一个或多个与上面显示的标准 setter 方法声明不匹配的自定义声明，可以根据需要多次调用<code>JwtBuilde.claim</code> 声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jws</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">    .claim(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">    <span class="comment">// ... etc ...</span></span><br></pre></td></tr></table></figure><p>每次调用<code>claim</code>时，它只是将键值对附加到内部<code>claims</code>实例，如果键值已经存在，则会覆盖任何现有的同名<code>key/value</code>对，同头部信息一样</p><h4 id="签名"><a class="header-anchor" href="#签名">¶</a>签名</h4><p>JWT 规范确定了 12 种标准签名算法，三种密钥算法和九种非对称密钥算法，由于也不是做密码学的这里也不过多展开。自己项目中常见的使用<code>HMAC-SHA-256</code>就足够了</p><p>👴建议通过调用<code>JwtBuilder</code>的<code>signWith</code>方法来指定签名密钥，以及对应的摘要算法，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jws</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">   <span class="comment">// ... etc ...</span></span><br><span class="line">   .signWith(key) <span class="comment">// &lt;---</span></span><br><span class="line">   .compact();</span><br></pre></td></tr></table></figure><p>使用<code>signWith</code>时，<code>JJWT</code>还会自动使用相关的算法标识符设置所需的<code>alg</code>头。类似地，如果使用长度为 4096 位的<code>RSA PrivateKey</code>调用<code>signWith</code>，<code>JJWT</code>将使用<code>RS512</code>算法并自动将<code>alg</code>头设置为<code>RS512</code></p><div class="alert info no-icon"><p>🎶不能用<code>PublicKeys</code>签署<code>JWT</code>，因为这总是不安全的。 <code>JJWT</code>将拒绝任何指定的<code>PublicKey</code>的方式签名，并抛出异常：<code>InvalidKeyException</code></p></div><h3 id="解析-JWS"><a class="header-anchor" href="#解析-JWS">¶</a>解析 JWS</h3><p>⛵解析 JWS 步骤如下：</p><ol><li>使用<code>Jwts.parser()</code>方法创建<code>JwtParser</code>实例</li><li>指定要用于验证<code>JWS</code>签名的<code>SecretKey</code>或<code>非对称PublicKey</code></li><li>调用<code>parseClaimsJws(String)</code>方法，生成原始<code>JWS</code></li></ol><p>🎶如之前所述，整个调用将包装在<code>try/catch</code>块中，以防解析或签名验证失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Jws&lt;Claims&gt; jws;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    jws = Jwts.parser()         	<span class="comment">// (1)</span></span><br><span class="line">    .setSigningKey(key)         	<span class="comment">// (2)</span></span><br><span class="line">    .parseClaimsJws(jwsString); 	<span class="comment">// (3)</span></span><br><span class="line">    <span class="comment">// we can safely trust the JWT</span></span><br><span class="line"><span class="keyword">catch</span> (JwtException ex) &#123;</span><br><span class="line">    <span class="comment">// we cannot use the JWT as intended by its creator</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="校验-Key"><a class="header-anchor" href="#校验-Key">¶</a>校验 Key</h4><p>阅读<code>JWS</code>时，最重要的事情是指定用于验证 JWS 加密签名的<strong>密钥</strong>。 如果签名验证失败，则无法安全地信任此<code>JWT</code>，应将其丢弃。如果<code>jws</code>是使用<code>SecretKey</code>签名的，则应在<code>JwtParser</code>上指定<strong>相同</strong>的<code>SecretKey</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jwts.parser()</span><br><span class="line">  .setSigningKey(secretKey) <span class="comment">// &lt;----</span></span><br><span class="line">  .parseClaimsJws(jwsString);</span><br></pre></td></tr></table></figure><p>如果<code>jws</code>是使用<code>PrivateKey</code>签名的，那么应该在<code>JwtParser</code>上指定该密钥<strong>相应</strong>的<code>PublicKey</code>（不是<code>PrivateKey</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jwts.parser()</span><br><span class="line">  .setSigningKey(publicKey) <span class="comment">// &lt;---- publicKey, not privateKey</span></span><br><span class="line">  .parseClaimsJws(jwsString);</span><br></pre></td></tr></table></figure><p>❓如果应用程序不止使用一个 SecretKey 或 KeyPair 会怎么样？ 如果可以使用不同的 SecretKeys 或公钥/私钥或两者的组合创建 JWS，该怎么办？</p><div class="alert success no-icon"><p>在这些情况下，无法使用单个键调用<code>JwtParser</code>的<code>setSigningKey</code>方法。相反，需要使用<code>SigningKeyResolver</code>方法指定解析 JWS 方法</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现了 SigningKeyResolver 接口的自定义解析类</span></span><br><span class="line"><span class="type">SigningKeyResolver</span> <span class="variable">signingKeyResolver</span> <span class="operator">=</span> getMySigningKeyResolver();</span><br><span class="line">Jwts.parser()</span><br><span class="line">    .setSigningKeyResolver(signingKeyResolver) <span class="comment">// &lt;----</span></span><br><span class="line">    .parseClaimsJws(jwsString);</span><br></pre></td></tr></table></figure><p>通过实现<code>SigningKeyResolverAdapter</code>接口的<code>resolveSigningKey(JwsHeader，Claims)</code>方法来简化一些事情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySigningKeyResolver</span> <span class="keyword">extends</span> <span class="title class_">SigningKeyResolverAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">resolveSigningKey</span><span class="params">(JwsHeader jwsHeader, Claims claims)</span> &#123;</span><br><span class="line">        <span class="comment">// implement</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解析<code>JWS JSON</code>之后，<code>JwtParser</code>将在验证<code>jws</code>签名之前调用<code>resolveSigningKey()</code>方法。 这也就允许检查<code>Jws Header</code>和<code>Claims</code>参数，以帮助查找用于验证特定<code>jws</code>的密钥的信息。 <strong>这对于复杂安全模型的应用程序非常强大，这些安全模型可能在不同时间使用不同的密钥或针对不同的用户或客</strong>。<code>JWT</code>规范支持的方法是在创建<code>JWS</code>时，在<code>JWS</code>头中设置<code>kid（Key ID）</code>字段，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Key</span> <span class="variable">signingKey</span> <span class="operator">=</span> getSigningKey();</span><br><span class="line"><span class="type">String</span> <span class="variable">keyId</span> <span class="operator">=</span> getKeyId(signingKey); 		<span class="comment">//any mechanism you have to associate a key with an ID is fine</span></span><br><span class="line"><span class="type">String</span> <span class="variable">jws</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">    .setHeaderParam(JwsHeader.KEY_ID, keyId) <span class="comment">// 1</span></span><br><span class="line">    .signWith(signingKey)                    <span class="comment">// 2</span></span><br><span class="line">    .compact();</span><br></pre></td></tr></table></figure><p>然后在解析期间，<code>SigningKeyResolver</code>可以检查<code>JwsHeader</code>以获取该<code>kid</code>，然后<strong>使用该值从某个位置查找密钥，如数据库</strong>。 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySigningKeyResolver</span> <span class="keyword">extends</span> <span class="title class_">SigningKeyResolverAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">resolveSigningKey</span><span class="params">(JwsHeader jwsHeader, Claims claims)</span> &#123;</span><br><span class="line">        <span class="comment">//inspect the header or claims, lookup and return the signing key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">keyId</span> <span class="operator">=</span> jwsHeader.getKeyId(); 	<span class="comment">//or any other field that you need to inspect</span></span><br><span class="line">        <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> lookupVerificationKey(keyId); <span class="comment">//implement me</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🎶检查<code>jwsHeader.getKeyId()</code>只是查找密钥的最常用方法，也可以检查任意数量的标头字段或声明，以确定如何查找验证密钥。</p><h4 id="Claims-断言"><a class="header-anchor" href="#Claims-断言">¶</a>Claims 断言</h4><p>如果正在解析的<code>JWS</code>具有特定的子<code>sub</code>值，可以使用<code>JwtParser</code>上的各种<code>require *</code>方法来获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Jwts.parser().requireSubject(<span class="string">&quot;pineapple-man&quot;</span>).setSigningKey(key).parseClaimsJws(s);</span><br><span class="line">&#125; <span class="keyword">catch</span>(InvalidClaimException ice) &#123;</span><br><span class="line">    <span class="comment">// the sub field was missing or did not have a &#x27;pineapple-man&#x27; value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果缺少某个值，那么就不会捕获<code>InvalidClaimException</code>，而是捕获<code>MissingClaimException</code>或<code>IncorrectClaimException</code>异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Jwts.parser().requireSubject(<span class="string">&quot;pineapple-man&quot;</span>).setSigningKey(key).parseClaimsJws(s);</span><br><span class="line">&#125; <span class="keyword">catch</span>(MissingClaimException mce) &#123;</span><br><span class="line">    <span class="comment">// the parsed JWT did not have the sub field</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(IncorrectClaimException ice) &#123;</span><br><span class="line">    <span class="comment">// the parsed JWT had a sub field, but its value was not equal to &#x27;pineapple-man&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以使用<code>require(fieldName，requiredFieldValue)</code>方法来获取自定义字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	Jwts.parser().require(<span class="string">&quot;field&quot;</span>,<span class="string">&quot;requiredValue&quot;</span>).setSigningKey(key).parseClaimsJws(s);</span><br><span class="line">&#125; <span class="keyword">catch</span>(InvalidClaimException ice) &#123;</span><br><span class="line">    <span class="comment">// the &#x27;myfield&#x27; field was missing or did not have a &#x27;myRequiredValue&#x27; value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压缩"><a class="header-anchor" href="#压缩">¶</a>压缩</h3><p>如果<code>JWT</code>的<code>Claim</code>域可以足够大，包含许多<code>key/value</code>对；或者单个值非常冗长，可以通过<strong>压缩来减小创建的<code>JWS</code>的大小</strong></p><div class="alert warning no-icon"><p>例如：如果在<code>URL</code>中使用生成的<code>JWS</code>，压缩将很重要，因为浏览器，用户邮件代理或 HTTP 网关兼容性问题，<code>URL</code>最好保持在<code>4096</code>个字符以下，所以较小的<code>JWT</code>有助于降低带宽利用率</p></div><h4 id="默认压缩"><a class="header-anchor" href="#默认压缩">¶</a>默认压缩</h4><p>如果要压缩<code>JWT</code>，可以使用<code>JwtBuilde</code>r 的<code>compressWith(CompressionAlgorithm)</code>方法。 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jwts.builder()</span><br><span class="line">   .compressWith(CompressionCodecs.DEFLATE) <span class="comment">// or CompressionCodecs.GZIP</span></span><br><span class="line">   <span class="comment">// .. etc ...</span></span><br></pre></td></tr></table></figure><p>使用<code>DEFLATE</code>或<code>GZIP</code>压缩编解码器，但是在解压缩时，不必执行任何操作，不需要配置<code>JwtParser</code>，<code>JJWT</code>将按预期自动解压缩主体</p><h4 id="自定义压缩"><a class="header-anchor" href="#自定义压缩">¶</a>自定义压缩</h4><p>如果在创建<code>JWT</code>时使用自己的自定义压缩编解码器（通过<code>JwtBuilder.compressWith</code>），则需要使用<code>setCompressionCodecResolver</code>方法将编解码器提供给<code>JwtParser</code>。 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CompressionCodecResolver</span> <span class="variable">ccr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCompressionCodecResolver</span>();</span><br><span class="line">Jwts.parser()</span><br><span class="line">    .setCompressionCodecResolver(ccr) <span class="comment">// &lt;----</span></span><br><span class="line">    <span class="comment">// .. etc ...</span></span><br></pre></td></tr></table></figure><p>通常，<code>CompressionCodecResolver</code>实现将检查<code>zip</code>标头以找出使用的算法，然后返回支持该算法的编解码器实例。 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCompressionCodecResolver</span> <span class="keyword">implements</span> <span class="title class_">CompressionCodecResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CompressionCodec <span class="title function_">resolveCompressionCodec</span><span class="params">(Header header)</span> <span class="keyword">throws</span> CompressionException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">alg</span> <span class="operator">=</span> header.getCompressionAlgorithm();</span><br><span class="line"></span><br><span class="line">        <span class="type">CompressionCodec</span> <span class="variable">codec</span> <span class="operator">=</span> getCompressionCodec(alg); <span class="comment">//implement</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> codec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41540822/article/details/88781964">Java Web Token 之 JJWT 使用</a></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" data-tooltip="权限控制解决方案" aria-label="上一篇: 权限控制解决方案"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/mybatis-%E5%8A%A8%E6%80%81sql/" data-tooltip="MyBatis 动态Sql" aria-label="下一篇: MyBatis 动态Sql"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" data-tooltip="权限控制解决方案" aria-label="上一篇: 权限控制解决方案"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/mybatis-%E5%8A%A8%E6%80%81sql/" data-tooltip="MyBatis 动态Sql" aria-label="下一篇: MyBatis 动态Sql"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>