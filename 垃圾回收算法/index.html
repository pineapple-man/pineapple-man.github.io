<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>垃圾回收算法 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="JVM,垃圾收集器,垃圾回收,GC"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n¶概述\nJVM 在进行垃圾回收时，主要分为两个阶段（标记阶段和清除阶段）进行，其中标记阶段用于搜集 JVM 中哪些对象需要进行回收，清除阶段用于对标记阶段的对象进行真正的回收，本文主要讲解这两个阶段所涉及的相关算法\n¶标记阶段\n在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象，只有被标记为己经死亡的对象，GC 才会在执行垃圾回收时，释放掉其所占用的内存空间，这个过程称为垃圾标记阶段\n✨判断对象存活一般有两种方式：引用计数算法和可达性分析算法\n\n🤔JVM 究竟如何标记一个死亡对象？\n当一个对象已经不再被任何的存活对象继续引用时，此时对象就是死亡对象\n\n¶引用计数算法\n引用计数算法（Reference Counting）就是对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，即表示对象 A 不可能再被使用，可进行回收\n👍优点：\n\n实现简单，垃圾对象便于辨识\n判定效率高，回收没有延迟性\n\n😣缺点\n\n需要单独的字段存储计数器，增加了存储空间的开销\n每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销\n存在循环引用的情况（这是最制命的缺陷，导致在 Java 的垃圾回收器种没有使用这类算法）\n\n\n¶循环引用\n\n当p的指针断开的时候，内部引用形成循环，造成引用一直存在，循环引用必然导致内存泄漏\n¶验证 Java 是否采用循环引用\n1234567891011121314151617181920212223public class RefCountGC &#123;    // 这个成员属性的唯一作用就是占用一点内存    private byte[] bigSize = new byte[5*1024*1024];    // 引用    Object reference = null;    public static void main(String[] args) &#123;        RefCountGC obj1 = new RefCountGC();        RefCountGC obj2 = new RefCountGC();        obj1.reference = obj2;        obj2.reference = obj1;        obj1 = null;        obj2 = null;        // 显示的执行垃圾收集行为        // 这里发生GC，obj1和obj2是否被回收？        System.gc();    &#125;&#125;/** 运行结果PSYoungGen: 15490K-&gt;808K(76288K)] 15490K-&gt;816K(251392K)**/\n上述进行了 GC 收集的行为，所以可以证明 JVM 中采用的不是引用计数器的算法\n\n¶可达性分析算法\n✨可达性分析算法又称为：根搜索算法或追踪型垃圾收集,可达性分析算法不仅具备实现简单和执行高效等特点，更重要的是——该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生\n\nJava、C#使用的就是可达性分析算法来标记对象是否存活，这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）\n¶基本思路\n❓可达性分析算法，是谁与谁可达？\n\n可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合（GC Root Set） 所连接的目标对象是否可达\n使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）\n如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象，在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象\n\n\n\n¶GC Roots\n❓GCRoots 是什么？\n所谓GCRoots根集合就是一组必须活跃的引用，下图总结了常见的GC Roots能使哪些\n\n\n除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时性地加入，共同构成完整 GC Roots 集合。比如：分代收集和局部回收（PartialGC）\n如果只针对 Java 堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots Set中去考虑，才能保证可达性分析的准确性\n由于 Root 采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root\n\n使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证，由于一致性快照的问题，是导致 GC 进行时必须Stop The World的一个重要原因。即使是号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须停顿的\n\n¶总结\n很多语言选择使用引用计数算法进行资源回收，Python 就使用引用计数算法标记对象，Java 并没有选择引用计数算法，因为很难处理循环引用关系，如此并不能说明引用计数算法不好，具体要看应用场景，业界中仍有大规模保留引用计数机制以提高吞吐量的尝试\n🤔Python 是如何解决循环引用？\n\n手动解除：在合适的时机，解除引用关系\n使用弱引用weakred，weakref是 python 提供的标准库，旨在解决循环引用\n\n¶清除阶段\n当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存\n✨目前在 JVM 中比较常见的三种垃圾收集算法是：标记一清除算法（Mark-Sweep）、复制算法（copying）、标记-压缩算法（Mark-Compact）\n\n¶标记清除算法\n标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在 1960 年提出并，并应用于 Lisp 语言\n¶执行过程\n当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（STW），然后进行两项工作，第一项是标记，第二项是清除\n标记：Collector 从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的 Header 中记录为可达对象\n清除：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收\n\n\n😣标记清除算法缺点\n\n算法的效率不算高\n在进行 GC 的时候，需要停止整个应用程序，用户体验较差\n这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表\n\n\n¶清除的实现\n这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。\n¶复制算法\n为了解决标记-清除算法在垃圾收集效率方面的缺陷，提出了复制算法\n👍复制算法优点\n\n没有标记和清除过程，实现简单，运行高效\n保证复制过去空间的连续性，不会出现碎片问题\n\n😣复制算法缺点\n\n需要两倍的内存空间\n对于 G1 这种拆分成为大量 region 的 GC，使用复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用还是时间开销都是不小的消耗\n\n\n复制算法需要复制的存活对象数量非常低才行，如果系统中存在很多的垃圾对象，不适合使用复制算法\n¶核心思想\n将活着的内存空间分为两块，每次只使用其中一块。垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收\n\n\n¶应用场景\n为了解决空间利用率问题，可以将内存分为三块： Eden、From Survivor、To Survivor，比例是 8:1:1（大量测试后得到的一个结果），每次使用 Eden 和其中一块 Survivor。回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才使用的 Survivor 空间。这样只有 10% 的内存被浪费，但是我们无法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够，需要依赖其他内存（指老年代）进行分配担保\n✨分配担保\n为对象分配内存空间时，如果 Eden+Survivor 中空闲区域无法装下该对象，会触发 MinorGC 进行垃圾收集。但如果 Minor GC 过后依然有超过 10% 的对象存活，这样存活的对象直接通过分配担保机制进入老年代，然后再将新对象存入 Eden 区\n\n在新生代，对常规应用的垃圾回收，一次通常可以回收 70% - 99% 的内存空间，回收性价比很高，所以现代的商用虚拟机都是用这种收集算法回收新生代\n\n¶标记压缩（整理）算法\n复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。\n标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以 JVM 的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生\n👍标记压缩算法优点\n\n消除了标记-清除算法当中，内存区域分散的缺点\n消除了复制算法当中，内存减半的高额代价\n\n😣标记压缩算法缺点\n\n从效率上来说，标记-整理算法要低于复制算法\n移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址\n移动过程中，需要全程暂停用户应用程序\n\n\n¶执行过程\n\n和标记清除算法一样，从根节点开始标记所有被引用对象\n将所有的存活对象压缩到内存的一端，按顺序排放\n清理边界外所有的空间\n\n\n\n标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销\n🆚与标记清除算法相比，标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的，是否移动回收后的存活对象是一项优缺点并存的风险决策。\n¶总结\n标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法\n¶清除阶段算法总结\n\n\n\n\nMark-Sweep\nMark-Compact\nCopying\n\n\n\n\n速率\n中等\n最慢\n最快\n\n\n空间开销\n少（但会堆积碎片）\n少（不堆积碎片）\n通常需要活对象的 2 倍空间（不堆积碎片）\n\n\n移动对象\n否\n是\n是\n\n\n\n效率上来说，复制算法最优，但是却浪费了太多内存，而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段\n\n🎶不存在最优的算法，只有最合适的算法\n\n¶分代收集算法\n前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。\n分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。\n在 Java 程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如 Http 请求中的 Session 对象、线程、Socket 连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String 对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。\n\n目前几乎所有的 GC 都采用分代收集算法执行垃圾回收的，在 HotSpot 中，基于分代的概念，GC 所使用的内存回收算法结合年轻代和老年代各自的特点\n¶年轻代（Young Gen）\n✨年轻代特点：区域相对老年代较小，对象生命周期短、存活率低、回收频繁\n这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过 hotspot 中的两个 survivor 的设计得到缓解\n\n¶老年代（Tenured Gen）\n✨老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁\n这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。\n\n📓各个阶段开销总结\n\n\nMark 阶段的开销与存活对象的数量成正比。\n\n\nSweep 阶段的开销与所管理区域的大小成正相关。\n\n\nCompact 阶段的开销与存活对象的数据成正比。\n\n\n以 HotSpot 中的 CMS 回收器为例，CMS 是基于 Mark-Sweep 实现的，对于对象的回收效率很高。而对于碎片问题，CMS 采用基于 Mark-Compact 算法的 Serial Old 回收器作为补偿措施：当内存回收不佳（碎片导致的 Concurrent Mode Failure 时），将采用 Serial Old 执行 Full GC 以达到对老年代内存的整理\n分待的思想被现有的虚拟机广泛使用，几乎所有的垃圾回收器都区分成新生代和老年代\n¶增量收集算法\n上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在 Stop the World 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生\n增量算法的基本思想如下：\n如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。\n\n总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作\n😣使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。\n\n¶分区算法\n一般来说，在相同条件下，堆空间越大，一次 Gc 时所需要的时间就越长，有关 GC 产生的停顿也越长。为了更好地控制 GC 产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次 GC 所产生的停顿。分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间，每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间\n\n\n¶总结\n以上介绍的都只是基本的算法思路，实际 GC 实现过程要复杂的多，目前还在发展中的前沿 GC 都是复合算法，并且并行和并发兼备\n","dateCreated":"2021-11-05T14:14:20+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2021-11-05T14:14:20+00:00","description":"这是JVM中垃圾收集系列的第二篇文章，主要讲解常见的的垃圾回收算法","headline":"垃圾回收算法","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/","keywords":"JVM"}</script><meta name="description" content="这是JVM中垃圾收集系列的第二篇文章，主要讲解常见的的垃圾回收算法"><meta property="og:type" content="blog"><meta property="og:title" content="垃圾回收算法"><meta property="og:url" content="https://pineapple-man.github.io/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="这是JVM中垃圾收集系列的第二篇文章，主要讲解常见的的垃圾回收算法"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%AA%8C%E8%AF%81.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/gc_roots.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/gcroots.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/%E6%96%B0%E7%94%9F%E4%BB%A3%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86.png"><meta property="article:published_time" content="2021-11-05T14:14:20.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.011Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="JVM"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">垃圾回收算法</h1><div class="post-meta"><time datetime="2021-11-05T14:14:20+00:00">11月 05, 2021 </time><span>发布在 </span><a class="category-link" href="/categories/Java/">Java</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 4.8k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 44 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="toc-text">标记阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-text">引用计数算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-text">循环引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81-Java-%E6%98%AF%E5%90%A6%E9%87%87%E7%94%A8%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-text">验证 Java 是否采用循环引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-text">可达性分析算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC-Roots"><span class="toc-text">GC Roots</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5"><span class="toc-text">清除阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-text">标记清除算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">清除的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-text">复制算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-text">核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9%EF%BC%88%E6%95%B4%E7%90%86%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-text">标记压缩（整理）算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-v2"><span class="toc-text">执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-v2"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-text">清除阶段算法总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text">分代收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3%EF%BC%88Young-Gen%EF%BC%89"><span class="toc-text">年轻代（Young Gen）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%88Tenured-Gen%EF%BC%89"><span class="toc-text">老年代（Tenured Gen）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text">增量收集算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="toc-text">分区算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-v3"><span class="toc-text">总结</span></a></li></ol><h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><p>JVM 在进行垃圾回收时，主要分为两个阶段（<strong>标记阶段</strong>和<strong>清除阶段</strong>）进行，其中标记阶段用于搜集 JVM 中哪些对象需要进行回收，清除阶段用于对标记阶段的对象进行真正的回收，本文主要讲解这两个阶段所涉及的相关算法</p><h2 id="标记阶段"><a class="header-anchor" href="#标记阶段">¶</a>标记阶段</h2><p>在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，<strong>首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</strong>，只有<strong>被标记为己经死亡的对象</strong>，GC 才会在执行垃圾回收时，释放掉其所占用的内存空间，这个过程称为<strong>垃圾标记阶段</strong></p><div class="alert success no-icon"><p>✨判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong></p></div><p>🤔JVM 究竟如何标记一个死亡对象？</p><div class="alert success no-icon"><p>当一个对象已经不再被任何的存活对象继续引用时，此时对象就是<strong>死亡对象</strong></p></div><h3 id="引用计数算法"><a class="header-anchor" href="#引用计数算法">¶</a>引用计数算法</h3><p>引用计数算法（Reference Counting）就是对每个对象保存一个整型的<strong>引用计数器属性</strong>，用于记录对象被引用的情况。对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，即表示对象 A 不可能再被使用，可进行回收</p><div class="alert info no-icon"><p>👍优点：</p><ul><li>实现简单，垃圾对象便于辨识</li><li>判定效率高，回收没有延迟性</li></ul><p>😣缺点</p><ul><li>需要单独的字段存储计数器，增加了存储空间的开销</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销</li><li>存在<strong>循环引用</strong>的情况（这是最制命的缺陷，导致在 <strong>Java 的垃圾回收器种没有使用这类算法</strong>）</li></ul></div><h4 id="循环引用"><a class="header-anchor" href="#循环引用">¶</a>循环引用</h4><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/循环引用.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/循环引用.png" alt=""></a></div><p>当<code>p</code>的指针断开的时候，内部引用形成循环，造成引用一直存在，<font style="color:red;font-weight:700">循环引用必然导致内存泄漏</font></p><h4 id="验证-Java-是否采用循环引用"><a class="header-anchor" href="#验证-Java-是否采用循环引用">¶</a>验证 Java 是否采用循环引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefCountGC</span> &#123;</span><br><span class="line">    <span class="comment">// 这个成员属性的唯一作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 引用</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line"></span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line"></span><br><span class="line">        obj1 = <span class="literal">null</span>;</span><br><span class="line">        obj2 = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 显示的执行垃圾收集行为</span></span><br><span class="line">        <span class="comment">// 这里发生GC，obj1和obj2是否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 运行结果</span></span><br><span class="line"><span class="comment">PSYoungGen: 15490K-&gt;808K(76288K)] 15490K-&gt;816K(251392K)</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>上述进行了 GC 收集的行为，所以可以证明 JVM 中采用的不是引用计数器的算法</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/循环引用验证.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/循环引用验证.png" alt=""></a></div><h3 id="可达性分析算法"><a class="header-anchor" href="#可达性分析算法">¶</a>可达性分析算法</h3><div class="alert success no-icon"><p>✨可达性分析算法又称为：<strong>根搜索算法</strong>或<strong>追踪型垃圾收集</strong>,可达性分析算法不仅具备实现简单和执行高效等特点，更重要的是——该算法可以<strong>有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</strong></p></div><p><code>Java</code>、<code>C#</code>使用的就是可达性分析算法来标记对象是否存活，这种类型的垃圾收集通常也叫作<strong>追踪性垃圾收集（Tracing Garbage Collection）</strong></p><h4 id="基本思路"><a class="header-anchor" href="#基本思路">¶</a>基本思路</h4><p>❓可达性分析算法，是谁与谁可达？</p><div class="alert success no-icon"><ul><li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被<strong>根对象集合（GC Root Set）</strong> 所连接的目标对象是否可达</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链（Reference Chain）</strong></li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象，在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象</li></ul></div><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/可达性分析算法.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/可达性分析算法.png" alt=""></a></div><h4 id="GC-Roots"><a class="header-anchor" href="#GC-Roots">¶</a>GC Roots</h4><p>❓GCRoots 是什么？</p><div class="alert success no-icon"><p>所谓<strong>GCRoots</strong>根集合就是一组必须活跃的引用，下图总结了常见的<code>GC Roots</code>能使哪些</p></div><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/gc_roots.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/gc_roots.png" alt=""></a></div><p>除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象<strong>临时性</strong>地加入，共同构成完整 GC Roots 集合。比如：分代收集和局部回收（PartialGC）</p><p>如果只针对 Java 堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入<strong>GC Roots Set</strong>中去考虑，才能保证可达性分析的准确性</p><p>由于 Root 采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/gcroots.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/gcroots.png" alt=""></a></div><div class="alert info no-icon"><p>使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证，由于一致性快照的问题，是导致 GC 进行时必须<code>Stop The World</code>的一个重要原因。即使是号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须停顿的</p></div><h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3><p>很多语言选择使用引用计数算法进行资源回收，Python 就使用引用计数算法标记对象，Java 并没有选择引用计数算法，因为很难处理循环引用关系，如此并不能说明引用计数算法不好，具体要看应用场景，业界中仍有大规模保留引用计数机制以提高吞吐量的尝试</p><p>🤔Python 是如何解决循环引用？</p><ul><li>手动解除：在合适的时机，解除引用关系</li><li>使用弱引用<code>weakred</code>，<code>weakref</code>是 python 提供的标准库，旨在解决循环引用</li></ul><h2 id="清除阶段"><a class="header-anchor" href="#清除阶段">¶</a>清除阶段</h2><p>当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存</p><div class="alert success no-icon"><p>✨目前在 JVM 中比较常见的三种垃圾收集算法是：<strong>标记一清除算法（Mark-Sweep）</strong>、<strong>复制算法（copying）</strong>、<strong>标记-压缩算法（Mark-Compact）</strong></p></div><h3 id="标记清除算法"><a class="header-anchor" href="#标记清除算法">¶</a>标记清除算法</h3><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被<code>J.McCarthy</code>等人在 1960 年提出并，并应用于 Lisp 语言</p><h4 id="执行过程"><a class="header-anchor" href="#执行过程">¶</a>执行过程</h4><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（STW），然后进行两项工作，第一项是<strong>标记</strong>，第二项是<strong>清除</strong></p><div class="alert succeess no-icon"><p>标记：Collector 从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的 Header 中记录为可达对象</p><p>清除：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收</p></div><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/标记清除算法.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/标记清除算法.png" alt=""></a></div><div class="alert info no-icon"><p>😣标记清除算法缺点</p><ul><li>算法的效率不算高</li><li>在进行 GC 的时候，需要停止整个应用程序，用户体验较差</li><li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li></ul></div><h4 id="清除的实现"><a class="header-anchor" href="#清除的实现">¶</a>清除的实现</h4><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p><h3 id="复制算法"><a class="header-anchor" href="#复制算法">¶</a>复制算法</h3><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，提出了复制算法</p><div class="alert info no-icon"><p>👍复制算法优点</p><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>保证复制过去空间的连续性，不会出现<strong>碎片</strong>问题</li></ul><p>😣复制算法缺点</p><ul><li>需要两倍的内存空间</li><li>对于 G1 这种拆分成为大量 region 的 GC，使用复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用还是时间开销都是不小的消耗</li></ul></div><p>复制算法需要复制的存活对象数量非常低才行，如果系统中存在很多的垃圾对象，不适合使用复制算法</p><h4 id="核心思想"><a class="header-anchor" href="#核心思想">¶</a>核心思想</h4><div class="alert success no-icon"><p>将活着的内存空间分为两块，每次只使用其中一块。垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p></div><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/复制算法.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/复制算法.png" alt=""></a></div><h4 id="应用场景"><a class="header-anchor" href="#应用场景">¶</a>应用场景</h4><p>为了解决空间利用率问题，可以将内存分为三块： Eden、From Survivor、To Survivor，比例是 8:1:1（大量测试后得到的一个结果），每次使用 Eden 和其中一块 Survivor。回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才使用的 Survivor 空间。这样只有 10% 的内存被浪费，但是我们无法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够，需要依赖其他内存（指老年代）进行分配担保</p><p>✨分配担保</p><div class="alert success no-icon"><p>为对象分配内存空间时，如果 Eden+Survivor 中空闲区域无法装下该对象，会触发 MinorGC 进行垃圾收集。但如果 Minor GC 过后依然有超过 10% 的对象存活，这样存活的对象直接通过分配担保机制进入老年代，然后再将新对象存入 Eden 区</p></div><p>在新生代，对常规应用的垃圾回收，一次通常可以回收 70% - 99% 的内存空间，回收性价比很高，所以现代的商用虚拟机都是用这种收集算法回收新生代</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/新生代的垃圾回收.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/新生代的垃圾回收.png" alt=""></a></div><h3 id="标记压缩（整理）算法"><a class="header-anchor" href="#标记压缩（整理）算法">¶</a>标记压缩（整理）算法</h3><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p><p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以 JVM 的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生</p><div class="alert info no-icon"><p>👍标记压缩算法优点</p><ul><li>消除了标记-清除算法当中，内存区域分散的缺点</li><li>消除了复制算法当中，内存减半的高额代价</li></ul><p>😣标记压缩算法缺点</p><ul><li>从效率上来说，标记-整理算法要低于复制算法</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li><li>移动过程中，需要全程暂停用户应用程序</li></ul></div><h4 id="执行过程-v2"><a class="header-anchor" href="#执行过程-v2">¶</a>执行过程</h4><div class="alert info no-icon"><ol><li>和标记清除算法一样，从根节点开始标记所有被引用对象</li><li>将所有的存活对象压缩到内存的一端，按顺序排放</li><li>清理边界外所有的空间</li></ol></div><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/标记压缩算法.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/标记压缩算法.png" alt=""></a></div><p>标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销</p><p>🆚与标记清除算法相比，标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的，是否移动回收后的存活对象是一项优缺点并存的风险决策。</p><h4 id="总结-v2"><a class="header-anchor" href="#总结-v2">¶</a>总结</h4><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法</p><h3 id="清除阶段算法总结"><a class="header-anchor" href="#清除阶段算法总结">¶</a>清除阶段算法总结</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Mark-Sweep</th><th style="text-align:center">Mark-Compact</th><th style="text-align:center">Copying</th></tr></thead><tbody><tr><td style="text-align:center"><strong>速率</strong></td><td style="text-align:center">中等</td><td style="text-align:center">最慢</td><td style="text-align:center">最快</td></tr><tr><td style="text-align:center"><strong>空间开销</strong></td><td style="text-align:center">少（但会堆积碎片）</td><td style="text-align:center">少（不堆积碎片）</td><td style="text-align:center">通常需要活对象的 2 倍空间（不堆积碎片）</td></tr><tr><td style="text-align:center"><strong>移动对象</strong></td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr></tbody></table><div class="alert success no-icon"><p>效率上来说，复制算法最优，但是却浪费了太多内存，而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段</p></div><div class="alert info no-icon"><p>🎶不存在最优的算法，只有最合适的算法</p></div><h2 id="分代收集算法"><a class="header-anchor" href="#分代收集算法">¶</a>分代收集算法</h2><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。</p><div class="alert success no-icon"><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的因此，<strong>不同生命周期的对象可以采取不同的收集方式</strong>，以便提高回收效率。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在 Java 程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如 Http 请求中的 Session 对象、线程、Socket 连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：<strong>String 对象</strong>，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p></div><p>目前几乎所有的 GC 都采用分代收集算法执行垃圾回收的，在 HotSpot 中，基于分代的概念，GC 所使用的内存回收算法结合年轻代和老年代各自的特点</p><h3 id="年轻代（Young-Gen）"><a class="header-anchor" href="#年轻代（Young-Gen）">¶</a>年轻代（Young Gen）</h3><div class="alert success no-icon"><p>✨年轻代特点：区域相对老年代较小，对象生命周期短、存活率低、回收频繁</p><p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过 hotspot 中的两个 survivor 的设计得到缓解</p></div><h3 id="老年代（Tenured-Gen）"><a class="header-anchor" href="#老年代（Tenured-Gen）">¶</a>老年代（Tenured Gen）</h3><div class="alert success no-icon"><p>✨老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁</p><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p></div><p>📓各个阶段开销总结</p><ul><li><p>Mark 阶段的开销与存活对象的数量成正比。</p></li><li><p>Sweep 阶段的开销与所管理区域的大小成正相关。</p></li><li><p>Compact 阶段的开销与存活对象的数据成正比。</p></li></ul><p>以 HotSpot 中的 CMS 回收器为例，CMS 是基于 Mark-Sweep 实现的，对于对象的回收效率很高。而对于碎片问题，CMS 采用基于 Mark-Compact 算法的 Serial Old 回收器作为补偿措施：当内存回收不佳（碎片导致的 Concurrent Mode Failure 时），将采用 Serial Old 执行 Full GC 以达到对老年代内存的整理</p><p>分待的思想被现有的虚拟机广泛使用，几乎所有的垃圾回收器都区分成新生代和老年代</p><h2 id="增量收集算法"><a class="header-anchor" href="#增量收集算法">¶</a>增量收集算法</h2><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种<code>Stop the World</code>的状态。在 Stop the World 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生</p><p>增量算法的基本思想如下：</p><div class="alert success no-icon"><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p></div><p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</p><div class="alert success no-icon"><p>😣使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p></div><h2 id="分区算法"><a class="header-anchor" href="#分区算法">¶</a>分区算法</h2><div class="alert success no-icon"><p>一般来说，在相同条件下，堆空间越大，一次 Gc 时所需要的时间就越长，有关 GC 产生的停顿也越长。为了更好地控制 GC 产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次 GC 所产生的停顿。分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间，每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间</p></div><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/分代收集.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/分代收集.png" alt=""></a></div><h2 id="总结-v3"><a class="header-anchor" href="#总结-v3">¶</a>总结</h2><p>以上介绍的都只是基本的算法思路，实际 GC 实现过程要复杂的多，目前还在发展中的前沿 GC 都是复合算法，并且并行和并发兼备</p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/JVM/" rel="tag">JVM</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86%E7%AC%A6/" data-tooltip="进程标识符" aria-label="上一篇: 进程标识符"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/springcloud-%E6%A6%82%E8%BF%B0/" data-tooltip="SpringCloud 概述" aria-label="下一篇: SpringCloud 概述"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86%E7%AC%A6/" data-tooltip="进程标识符" aria-label="上一篇: 进程标识符"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/springcloud-%E6%A6%82%E8%BF%B0/" data-tooltip="SpringCloud 概述" aria-label="下一篇: SpringCloud 概述"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>