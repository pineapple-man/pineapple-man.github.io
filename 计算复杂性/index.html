<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>计算复杂性 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="复杂性分析"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n¶时间复杂度\n✨关于时间复杂度的认识\n时间复杂度并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间花费会增长得有多快\n\n对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是依旧保持一样，还是也跟着慢了数百倍，或者变慢了数万倍，我们尤为关注其中随着数据量的不断增加，程序花费的时间并没有增长反而固定在某个界内，我们就说这个程序效率很好，具有$O(1)$的时间复杂度，也称常数级复杂度\n还有一些穷举类算法：随着输入线性增长，算法花费时间成几何阶数上涨，这就是 $O(a^n)$ 的指数级复杂度，甚至 $O(n!)$ 的阶乘级复杂度\n不会存在 $O(2n^2)$ 的复杂度，因为随着输入增加，系数并不会主要影响到程序的时间增长\n我们会说 $O(0.01 \\times n^3)$ 的程序的效率比 $O(100 \\times n^2)$ 的效率低，尽管在 $n$ 很小的时候，前者优于后者，但后者时间随数据规模增长得慢，最终 $O(n^3)$ 的复杂度将远远超过 $O(n^2)$ 我们也说，$O(n^{100})$ 的复杂度小于 $O(1.01^n)$ 的复杂度\n\n✨前面的几类复杂度被分为两种级别，其中后者的复杂度无论如何都远远大于前者：\n\n\n一种是$O(1)$,$O(log(n))$,$O(n^a)$等，我们把它叫做多项式级的复杂度，因为它的规模$n$出现在底数的位置\n\n\n另一种是$O(a^n)$和$O(n!)$型复杂度，它是非多项式级的，其复杂度计算机往往不能承受\n\n\n在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小\n¶多项式级算法是万能的吗\n❓是否所有的问题都可以找到复杂度为多项式级的算法呢？\n答案是否定的，有些问题甚至根本不可能找到一个正确的算法，这称之为不可解问题(Undecidable Decision Problem)，停机问题就是一个著名的不可解问题\n\n\nhalting problem 是逻辑数学中可计算性理论的一个问题，停机问题是：判断任意一个程序是否能在有限的时间之内结束运行，该问题等价于如下的判定问题：是否存在一个程序 P，对于任意输入的程序 w，能够判断 w 会在有限时间内结束或者陷入死循环\n艾伦-图灵在 1936 年用对角论证法证明了，不存在解决停机问题的通用算法\n\n¶p 类问题\n❓什么是 P 类问题\n如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于 P 问题\n\n¶NP 问题\n❓什么是 NP 问题？\nNP 问题不是非 P 类问题。NP 问题是指可以在多项式的时间里验证一个解的问题。NP 问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。\n\n例如：你是一个lucky dog，在程序中需要枚举时，可以一猜一个准，某人拿到了一个求最短路径的问题，问从起点到终点是否有一条小于 100 个单位长度的路线。它根据数据画好了图，但怎么也算不出来，于是来问你：如何选条路走得最少？你运气很好，肯定能随便指条很短的路出来。然后你就胡乱画了几条线，说就这条吧。那人按你指的这条把权值加起来一看，嘿，神了，路径长度 98，比 100 小。于是答案出来了，存在比 100 小的路径。别人会问他这题怎么做出来的，他就可以说，因为找到了一个比 100 小的解。\n在这个题中，找一个解很困难，但验证一个解很容易。验证一个解只需要$O(n)$的时间复杂度，也就是说我可以花$O(n)$的时间把我猜的路径的长度加出来。那么，只要我运气好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它，满足这类问题就是 NP 问题\n🎶当然有不是 NP 问题的问题，即你猜到了解但没用，因为你不能在多项式的时间里去验证它\n例如：前面所说的 Hamilton 回路是 NP 问题，因为验证一条路是否恰好经过了每一个顶点非常容易。但我要把问题换成这样：试问一个图中是否不存在 Hamilton 回路。这样问题就没法在多项式的时间里进行验证了，因为除非你试过所有的路，否则你不敢断定它没有 Hamilton 回路\n🤔定义 NP 问题，是因为通常只有 NP 问题才可能找到多项式的算法，我们不会指望一个连多项式验证一个解都不行的问题，存在一个解决它的多项式级的算法\n\n信息学中的号称最困难的问题——NP 问题，实际上是在探讨 NP 问题与 P 类问题的关系\n\n很显然，所有的 P 类问题都是 NP 问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解。人们想知道，是否所有的 NP 问题都是 P 类问题。如果把所有 P 类问题归为一个集合$\\mathbb{p}$中，把所有 NP 问题划进另一个集合$\\mathbb{N}_p$中，那么，显然有$\\mathbb{p} \\subseteq \\mathbb{N}_p$\n✨现在，所有对 NP 问题的研究都集中在一个问题上：$\\mathbb{P} =\\mathbb{N}_p$？\n通常所谓的NP 问题，其实就一句话：证明或推翻 $\\mathbb{P} =\\mathbb{N}_p$\n目前为止这个问题还并不知道答案，但是，存在一个大方向，人们普遍认为，$\\mathbb{P} =\\mathbb{N}_p$不成立。也就是说，多数人相信，存在至少一个不可能有多项式级复杂度的算法的 NP 问题。人们如此坚信$\\mathbb{P} \\neq\\mathbb{N}_p$是有原因的。就是在研究 NP 问题的过程中找出了一类非常特殊的 NP 问题叫做NP-完全问题，也即所谓的 NPC 问题。正是 NPC 问题的存在，使人们相信$\\mathbb{P} \\neq\\mathbb{N}_p$\n¶NPC 问题\n为了说明 NPC 问题，我们先引入一个概念——约化(Reducibility，有的资料上叫归约)\n¶归约\n简单地说，一个问题 A 可以约化为问题 B 的含义是：可以用问题 B 的解法解决问题 A，或者说，问题 A 可以变成问题 B\n现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果\nThomas H.Cormen ...《算法导论》\n这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为 0。按照这个规则就把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton 回路可以约化为 TSP 问题(Travelling Salesman Problem，旅行商问题)：在 Hamilton 回路问题中，两点相连即这两点距离为 0，两点不直接相连则令其距离为 1，于是问题转化为在 TSP 问题中，是否存在一条长为 0 的路径。Hamilton 回路存在当且仅当 TSP 问题中存在长为 0 的回路\n问题 A 可约化为问题 B 有一个重要的直观意义：B 的时间复杂度高于或者等于 A 的时间复杂度，也就是说，问题 A 不比问题 B 难。这很容易理解。既然问题 A 能用问题 B 来解决，倘若 B 的时间复杂度比 A 的时间复杂度还低了，那 A 的算法就可以改进为 B 的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者\n很显然，约化具有一项重要的性质：约化具有传递性，如果问题 A 可约化为问题 B，问题 B 可约化为问题 C，则问题 A 一定可约化为问题 C\n\n🎶约化的标准概念就可以定义了：如果能找到这样一个变化法则，对任意一个程序 A 的输入，都能按这个法则变换成程序 B 的输入，使两程序的输出相同，那么我们说，问题 A 可约化为问题 B\n这里所说的可约化是指可多项式地约化(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的，约化的过程只有用多项式的时间完成才有意义\n\n从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度低，但应用范围小的算法\n❓再回想前面讲的 P 和 NP 问题，联想起约化的传递性，自然地，我们会想问，如果不断地约化上去，不断找到能归纳若干小 NP 问题的一个稍复杂的大 NP 问题，那么最后是否有可能找到一个时间复杂度最高，并且能归纳所有 NP 问题的这样一个超级 NP 问题？\n答案居然是肯定的，存在这样一个 NP 问题，所有的 NP 问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的 NP 问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的NPC 问题，也就是NP-完全问题\n\n📓NPC 问题的出现使整个 NP 问题的研究得到了飞跃式的发展。我们有理由相信，NPC 问题是最复杂的问题。再次回到全文开头，人们想表达一个问题不存在多项式的高效算法时应该说它属于 NPC 问题\n¶NPC 定义\n❓什么样的问题是一个 NPC 问题？\n\n它是一个 NP 问题\n所有的 NP 问题都可以约化到它\n\n\n证明一个问题是 NPC 问题也很简单。先证明它至少是一个 NP 问题，再证明其中一个已知的 NPC 问题能约化到它（由约化的传递性，则 NPC 问题定义的第二条也得以满足），这样就可以说它是 NPC 问题了\n\n既然所有的 NP 问题都能约化成 NPC 问题，那么只要任意一个 NPC 问题找到了一个多项式的算法，那么所有的 NP 问题都能用这个算法解决了，NP 也就等于 P 了\n因此，前文说，正是 NPC 问题的存在，使人们相信$\\mathbb{P} \\neq \\mathbb{N}_p$。可以直观地理解，NPC 问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索\n¶NP-Hard\n❓NP-Hard 问题是什么？\n\n满足 NPC 问题定义的第二条但不一定要满足第一条（就是说，NP-Hard 问题要比 NPC 问题的范围广）\n\nNP-Hard 问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是 NP 问题。即使 NPC 问题发现了多项式级的算法，NP-Hard 问题有可能仍然无法得到多项式级的算法。事实上，由于 NP-Hard 放宽了限定条件，它将有可能比所有的 NPC 问题的时间复杂度更高从而更难以解决。\n¶NPC 举例\n🤔证明一个问题是否是 NPC 问题时，需要一个 NPC 问题能够约化到这个问题来证明，那么第一个 NPC 问题是如何出现的？\n\n逻辑电路问题，这是第一个 NPC 问题。其它的 NPC 问题都是由这个问题约化而来的。因此，逻辑电路问题是 NPC 类问题的鼻祖\n\n❓什么是逻辑电路问题？\n逻辑电路问题是指的这样一个问题：给定一个逻辑电路，问是否存在一种输入使输出为 True\n它显然属于 NP 问题，并且可以直接证明所有的 NP 问题都可以约化到它。证明过程的大概意思是说任意一个 NP 问题的输入和输出都可以转换成逻辑电路的输入和输出，因此对于一个 NP 问题来说，问题转化为了求出满足结果为 True 的一个输入，即一个可行解\n\n有了第一个 NPC 问题后，一大堆 NPC 问题就出现了，因为再证明一个新的 NPC 问题只需要将一个已知的 NPC 问题约化到它就行了。后来，Hamilton 回路成了 NPC 问题，TSP 问题也成了 NPC 问题。现在被证明是 NPC 问题的有很多，任何一个找到了多项式算法的话所有的 NP 问题都可以完美解决了\n¶总结\n本文的核心都在下面这张图里面了\n\n¶附录\n什么是 P 问题、NP 问题和 NPC 问题\n","dateCreated":"2021-10-23T02:58:12+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2021-10-23T02:58:12+00:00","description":"本文将简单介绍计算机算法设计中一直存在的问题","headline":"计算复杂性","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7/","keywords":"计算机理论"}</script><meta name="description" content="本文将简单介绍计算机算法设计中一直存在的问题"><meta property="og:type" content="blog"><meta property="og:title" content="计算复杂性"><meta property="og:url" content="https://pineapple-man.github.io/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="本文将简单介绍计算机算法设计中一直存在的问题"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/20150727214918014.png"><meta property="article:published_time" content="2021-10-23T02:58:12.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.003Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="计算机理论"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/20150727214918014.png"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">计算复杂性</h1><div class="post-meta"><time datetime="2021-10-23T02:58:12+00:00">10月 23, 2021 </time><span>发布在 </span><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/">计算机算法理论</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 3.7k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 35 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%BA%A7%E7%AE%97%E6%B3%95%E6%98%AF%E4%B8%87%E8%83%BD%E7%9A%84%E5%90%97"><span class="toc-text">多项式级算法是万能的吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p-%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="toc-text">p 类问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NP-%E9%97%AE%E9%A2%98"><span class="toc-text">NP 问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NPC-%E9%97%AE%E9%A2%98"><span class="toc-text">NPC 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E7%BA%A6"><span class="toc-text">归约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NPC-%E5%AE%9A%E4%B9%89"><span class="toc-text">NPC 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NP-Hard"><span class="toc-text">NP-Hard</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NPC-%E4%B8%BE%E4%BE%8B"><span class="toc-text">NPC 举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol><h2 id="时间复杂度"><a class="header-anchor" href="#时间复杂度">¶</a>时间复杂度</h2><p>✨关于时间复杂度的认识</p><div class="alert success no-icon"><p>时间复杂度并不是表示一个程序解决问题需要花多少时间，而是<strong>当问题规模扩大后，程序需要的时间花费会增长得有多快</strong></p></div><p>对于高速处理数据的计算机来说，<strong>处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是依旧保持一样，还是也跟着慢了数百倍，或者变慢了数万倍</strong>，我们尤为关注其中随着数据量的不断增加，程序<strong>花费的时间并没有增长反而固定在某个界内</strong>，我们就说这个程序效率很好，具有$O(1)$的时间复杂度，也称<strong>常数级复杂度</strong></p><p>还有一些<strong>穷举类算法</strong>：<strong>随着输入线性增长，算法花费时间成几何阶数上涨</strong>，这就是 $O(a^n)$ 的指数级复杂度，甚至 $O(n!)$ 的阶乘级复杂度</p><div class="alert info no-icon"><p>不会存在 $O(2n^2)$ 的复杂度，因为<strong>随着输入增加</strong>，系数并不会<strong>主要</strong>影响到程序的时间增长</p><p>我们会说 $O(0.01 \times n^3)$ 的程序的效率比 $O(100 \times n^2)$ 的效率低，尽管在 $n$ 很小的时候，前者优于后者，但后者时间随数据规模增长得慢，最终 $O(n^3)$ 的复杂度将远远超过 $O(n^2)$ 我们也说，$O(n^{100})$ 的复杂度小于 $O(1.01^n)$ 的复杂度</p></div><p>✨前面的几类复杂度被分为两种级别，其中后者的复杂度无论如何都远远大于前者：</p><ul><li><p>一种是$O(1)$,$O(log(n))$,$O(n^a)$等，我们把它叫做<strong>多项式级的复杂度</strong>，因为它的规模$n$出现在底数的位置</p></li><li><p>另一种是$O(a^n)$和$O(n!)$型复杂度，它是<strong>非多项式级</strong>的，其复杂度计算机往往不能承受</p></li></ul><p>在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小</p><h2 id="多项式级算法是万能的吗"><a class="header-anchor" href="#多项式级算法是万能的吗">¶</a>多项式级算法是万能的吗</h2><p>❓是否所有的问题都可以找到复杂度为多项式级的算法呢？</p><div class="alert success no-icon"><p>答案是<strong>否定的</strong>，有些问题甚至根本不可能找到一个正确的算法，这称之为<strong>不可解问题</strong>(Undecidable Decision Problem)，停机问题就是一个著名的不可解问题</p></div><blockquote><p>halting problem 是逻辑数学中可计算性理论的一个问题，停机问题是：<strong>判断任意一个程序是否能在有限的时间之内结束运行</strong>，该问题等价于如下的判定问题：<strong>是否存在一个程序 P，对于任意输入的程序 w，能够判断 w 会在有限时间内结束或者陷入死循环</strong><br>艾伦-图灵在 1936 年用对角论证法证明了，不存在解决停机问题的通用算法</p></blockquote><h2 id="p-类问题"><a class="header-anchor" href="#p-类问题">¶</a>p 类问题</h2><p>❓什么是 P 类问题</p><div class="alert success no-icon"><p>如果一个问题可以找到一个<strong>能在多项式的时间里解决它的算法</strong>，那么这个问题就<strong>属于 P 问题</strong></p></div><h2 id="NP-问题"><a class="header-anchor" href="#NP-问题">¶</a>NP 问题</h2><p>❓什么是 NP 问题？</p><div class="alert success no-icon"><p>NP 问题不是非 P 类问题。NP 问题是指<strong>可以在多项式的时间里验证一个解的问题</strong>。NP 问题的另一个定义是，<strong>可以在多项式的时间里猜出一个解的问题</strong>。</p></div><p>例如：你是一个<code>lucky dog</code>，在程序中需要枚举时，可以一猜一个准，某人拿到了一个求最短路径的问题，问从起点到终点是否有一条小于 100 个单位长度的路线。它根据数据画好了图，但怎么也算不出来，于是来问你：如何选条路走得最少？你运气很好，肯定能随便指条很短的路出来。然后你就胡乱画了几条线，说就这条吧。那人按你指的这条把权值加起来一看，嘿，神了，路径长度 98，比 100 小。于是答案出来了，存在比 100 小的路径。别人会问他这题怎么做出来的，他就可以说，因为找到了一个比 100 小的解。</p><p>在这个题中，<strong>找一个解很困难，但验证一个解很容易</strong>。验证一个解只需要$O(n)$的时间复杂度，也就是说我可以花$O(n)$的时间把我猜的路径的长度加出来。那么，只要我运气好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它，满足这类问题就是 NP 问题</p><p>🎶当然有不是 NP 问题的问题，即你猜到了解但没用，<strong>因为你不能在多项式的时间里去验证它</strong></p><p>例如：前面所说的 Hamilton 回路是 NP 问题，因为验证一条路是否恰好经过了每一个顶点非常容易。但我要把问题换成这样：试问一个图中是否不存在 Hamilton 回路。这样问题就没法在多项式的时间里进行验证了，因为除非你试过所有的路，否则你不敢断定它<strong>没有 Hamilton 回路</strong></p><p>🤔定义 NP 问题，是因为<strong>通常只有 NP 问题才可能找到多项式的算法</strong>，我们<strong>不会指望一个连多项式验证一个解都不行的问题，存在一个解决它的多项式级的算法</strong></p><blockquote><p>信息学中的号称最困难的问题——NP 问题，实际上是在探讨 NP 问题与 P 类问题的关系</p></blockquote><p>很显然，所有的 P 类问题都是 NP 问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解。人们想知道，<strong>是否所有的 NP 问题都是 P 类问题</strong>。如果把所有 P 类问题归为一个集合$\mathbb{p}$中，把所有 NP 问题划进另一个集合$\mathbb{N}_p$中，那么，显然有$\mathbb{p} \subseteq \mathbb{N}_p$</p><p>✨现在，所有对 NP 问题的研究都集中在一个问题上：$\mathbb{P} =\mathbb{N}_p$？</p><p>通常所谓的<strong>NP 问题</strong>，其实就一句话：证明或推翻 $\mathbb{P} =\mathbb{N}_p$</p><p>目前为止这个问题还并不知道答案，但是，存在一个大方向，人们普遍认为，$\mathbb{P} =\mathbb{N}_p$不成立。也就是说，多数人相信，存在至少一个不可能有多项式级复杂度的算法的 NP 问题。人们如此坚信$\mathbb{P} \neq\mathbb{N}_p$是有原因的。就是在研究 NP 问题的过程中找出了一类非常特殊的 NP 问题叫做<strong>NP-完全问题</strong>，也即所谓的 <strong>NPC 问题</strong>。正是 NPC 问题的存在，使人们相信$\mathbb{P} \neq\mathbb{N}_p$</p><h2 id="NPC-问题"><a class="header-anchor" href="#NPC-问题">¶</a>NPC 问题</h2><p>为了说明 NPC 问题，我们先引入一个概念——约化(Reducibility，有的资料上叫<strong>归约</strong>)</p><h3 id="归约"><a class="header-anchor" href="#归约">¶</a>归约</h3><p>简单地说，一个问题 A 可以约化为问题 B 的含义是：<strong>可以用问题 B 的解法解决问题 A</strong>，或者说，问题 A 可以<strong>变成</strong>问题 B</p><blockquote><p>现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果</p><footer><strong>Thomas H.Cormen ...</strong><cite>《算法导论》</cite></footer></blockquote><p>这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为 0。按照这个规则就把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton 回路可以约化为 TSP 问题(Travelling Salesman Problem，旅行商问题)：在 Hamilton 回路问题中，两点相连即这两点距离为 0，两点不直接相连则令其距离为 1，于是问题转化为在 TSP 问题中，是否存在一条长为 0 的路径。Hamilton 回路存在当且仅当 TSP 问题中存在长为 0 的回路</p><div class="alert success no-icon"><p>问题 A 可约化为问题 B 有一个重要的直观意义：<strong>B 的时间复杂度高于或者等于 A 的时间复杂度</strong>，也就是说，<strong>问题 A 不比问题 B 难</strong>。这很容易理解。既然问题 A 能用问题 B 来解决，倘若 B 的时间复杂度比 A 的时间复杂度还低了，那 A 的算法就可以改进为 B 的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者</p><p>很显然，约化具有一项重要的性质：<strong>约化具有传递性</strong>，如果问题 A 可约化为问题 B，问题 B 可约化为问题 C，则问题 A 一定可约化为问题 C</p></div><p>🎶约化的标准概念就可以定义了：<strong>如果能找到这样一个变化法则，对任意一个程序 A 的输入，都能按这个法则变换成程序 B 的输入，使两程序的输出相同，那么我们说，问题 A 可约化为问题 B</strong></p><div class="alert info no-icon"><p>这里所说的<strong>可约化</strong>是指可<strong>多项式地</strong>约化(<code>Polynomial-time Reducible</code>)，即变换输入的方法是能在多项式的时间里完成的，约化的过程只有用多项式的时间完成才有意义</p></div><p>从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度低，但应用范围小的算法</p><p>❓再回想前面讲的 P 和 NP 问题，联想起约化的传递性，自然地，我们会想问，<strong>如果不断地约化上去，不断找到能归纳若干小 NP 问题的一个稍复杂的大 NP 问题，那么最后是否有可能找到一个时间复杂度最高，并且能归纳所有 NP 问题的这样一个超级 NP 问题？</strong></p><div class="alert success no-icon"><p>答案居然是肯定的，存在这样一个 NP 问题，所有的 NP 问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的 NP 问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，<strong>这种问题不只一个</strong>，它有很多个，<strong>它是一类问题</strong>。这一类问题就是传说中的<strong>NPC 问题</strong>，也就是<strong>NP-完全问题</strong></p></div><p>📓NPC 问题的出现使整个 NP 问题的研究得到了飞跃式的发展。我们有理由相信，NPC 问题是最复杂的问题。再次回到全文开头，<strong>人们想表达一个问题不存在多项式的高效算法时应该说它属于 NPC 问题</strong></p><h3 id="NPC-定义"><a class="header-anchor" href="#NPC-定义">¶</a>NPC 定义</h3><p>❓什么样的问题是一个 NPC 问题？</p><ul><li>它是一个 NP 问题</li><li>所有的 NP 问题都可以约化到它</li></ul><blockquote><p>证明一个问题是 NPC 问题也很简单。先证明它至少是一个 NP 问题，再证明其中一个已知的 NPC 问题能约化到它（由约化的传递性，则 NPC 问题定义的第二条也得以满足），这样就可以说它是 NPC 问题了</p></blockquote><p>既然所有的 NP 问题都能约化成 NPC 问题，那么只要任意一个 NPC 问题找到了一个多项式的算法，那么所有的 NP 问题都能用这个算法解决了，NP 也就等于 P 了</p><p>因此，前文说，正是 NPC 问题的存在，使人们相信$\mathbb{P} \neq \mathbb{N}_p$。可以直观地理解，NPC 问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索</p><h3 id="NP-Hard"><a class="header-anchor" href="#NP-Hard">¶</a>NP-Hard</h3><p>❓NP-Hard 问题是什么？</p><ul><li>满足 NPC 问题定义的第二条<strong>但不一定要满足第一条</strong>（就是说，<strong>NP-Hard 问题要比 NPC 问题的范围广</strong>）</li></ul><p>NP-Hard 问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是 NP 问题。<strong>即使 NPC 问题发现了多项式级的算法，NP-Hard 问题有可能仍然无法得到多项式级的算法</strong>。事实上，由于 NP-Hard 放宽了限定条件，它将有可能比所有的 NPC 问题的时间复杂度更高从而更难以解决。</p><h3 id="NPC-举例"><a class="header-anchor" href="#NPC-举例">¶</a>NPC 举例</h3><p>🤔证明一个问题是否是 NPC 问题时，需要一个 NPC 问题能够约化到这个问题来证明，那么第一个 NPC 问题是如何出现的？</p><ul><li>逻辑电路问题，这是第一个 NPC 问题。其它的 NPC 问题都是由这个问题约化而来的。因此，逻辑电路问题是 NPC 类问题的<strong>鼻祖</strong></li></ul><p>❓什么是逻辑电路问题？</p><div class="alert success no-icon"><p>逻辑电路问题是指的这样一个问题：<strong>给定一个逻辑电路，问是否存在一种输入使输出为 True</strong><br>它显然属于 NP 问题，并且可以直接证明所有的 NP 问题都可以约化到它。证明过程的大概意思是说任意一个 NP 问题的输入和输出都可以转换成逻辑电路的输入和输出，因此对于一个 NP 问题来说，问题转化为了求出满足结果为 True 的一个输入，即一个可行解</p></div><p>有了第一个 NPC 问题后，一大堆 NPC 问题就出现了，因为再证明一个新的 NPC 问题只需要将一个已知的 NPC 问题约化到它就行了。后来，Hamilton 回路成了 NPC 问题，TSP 问题也成了 NPC 问题。现在被证明是 NPC 问题的有很多，任何一个找到了多项式算法的话所有的 NP 问题都可以完美解决了</p><h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2><p>本文的核心都在下面这张图里面了</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/20150727214918014.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/20150727214918014.png" alt=""></a></div><h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2><p><a target="_blank" rel="noopener" href="http://www.matrix67.com/blog/archives/105">什么是 P 问题、NP 问题和 NPC 问题</a></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/" rel="tag">计算机理论</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E6%88%91%E5%8F%8D%E8%BD%AC%E8%B0%81%E4%BA%86%EF%BC%9F/" data-tooltip="控制反转我反转谁了？" aria-label="上一篇: 控制反转我反转谁了？"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/cpu-%E4%B8%8E%E5%B9%B6%E5%8F%91/" data-tooltip="CPU 与并发" aria-label="下一篇: CPU 与并发"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E6%88%91%E5%8F%8D%E8%BD%AC%E8%B0%81%E4%BA%86%EF%BC%9F/" data-tooltip="控制反转我反转谁了？" aria-label="上一篇: 控制反转我反转谁了？"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/cpu-%E4%B8%8E%E5%B9%B6%E5%8F%91/" data-tooltip="CPU 与并发" aria-label="下一篇: CPU 与并发"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>