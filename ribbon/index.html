<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>ribbon - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="ribbon"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n¶概述\nSpring Cloud Ribbon 是基于 Netflix Ribbon 实现的一套客户端负载均衡的工具，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon 客户端组件提供一系列完善的配置项如连接超时，重试等。简单地说，就是在配置文件中列出 Load Balancer(简称 LB) 后面所有的机器，Ribbon 会自动的帮助你基于某种规则(如简单轮询，随机连接等）去连接这些机器。我们很容易使用 Ribbon 实现自定义的负载均衡算法\n📓 Ribbon 目前也进入维护模式。Ribbon 未来可能被 Spring Cloud LoadBalacer 替代\n\n❓什么是 Load Banlance(负载均衡)?\n简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的 HA (高可用)，常见的负载均衡有软件 Nginx，LVS，硬件 F5 等\n\n🆚 Ribbon 的负载均衡 VS Nginx 的负载均衡两者有什么区别？\n\nNginx 的负载均衡是一种服务端负载均衡技术，客户端发送请求后，被服务端负载均衡器拦截，随后负载均衡器根据相应的负载均衡算法分发请求到具体服务器上处理请求。\nRibbon 的负载均衡是一种客户端负载均衡技术，客户端想某一处发送请求时，会根据自身内部代码逻辑，已经做好了负载均衡的实现，直接访问到具体的服务。Ribbon 的客户端负载均衡配置就处于微服务的消费者中，消费者根据代码中自身拥有的负载均衡算法使用 restTemplate进行远程调用。\n\n\n从整体的请求过程可以明显看出服务端负载均衡和客户端负载均衡的差别：\n12服务端负载均衡： 客户端请求 ===&gt; 负载均衡器 ===&gt; 服务器客户端负载均衡： 客户端请求 ===&gt; 服务器\n服务端负载均衡就是通过一台服务器达到负载均衡效果，客户端负载均衡时通过自身就能够达到负载均衡，并不需要其他服务器；更准确的说，对于服务端的负载均衡技术，所有服务器的清单都是保存在负载均衡器上，负载均衡器用于维护服务器的增加或减少、而对于客户端负载均衡技术，客户端拥有所有服务器的清单，所以客户端能够越过负载均衡器，自身完成负载均衡技术\n\n根据最终负载均衡所在的位置，也可以将负载均衡技术分为两种：集中式负载均衡以及进程内负载均衡\n¶集中式 LB\n集中式 LB 即在服务的消费方和提供方之间使用独立的 LB 设施(可以是硬件，如 F5, 也可以是软件，如 nginx)，由该设施负责把访问请求通过某种策略转发至服务的提供方\n¶进程内 LB\n进程内 LB，将 LB 逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。Ribbon 就属于 111 进程内 LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址\n简单的理解， Ribbion 就是负载均衡和 RestTemplate 调用\n\n¶Ribbon 的负载均衡\n\n⛵ Ribbon 在工作时分成两步：\n\n\n先选择 EurekaServer ,它优先选择在同一个区域内负载较少的 server。\n\n\n根据用户指定的策略，在从 server 取到的服务注册列表中选择一个地址。\n\n\n其中 Ribbon 提供了多种策略：比如轮询、随机和根据响应时间加权。\n1234&lt;dependency&gt;    &lt;groupld&gt;org.springframework.cloud&lt;/groupld&gt;    &lt;artifactld&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactid&gt;&lt;/dependency&gt;\nspring-cloud-starter-netflix-eureka-client 自带了 spring-cloud-starter-ribbon 引用\n¶Ribbon 默认自带的负载规则\nRibbon 中的每一种负载均衡规则都对应着一个类，各个算法具体的含义如下表所示：\n\n\n\n类\n含义\n\n\n\n\nRoundRobinRule\n轮询规则\n\n\nRandomRule\n随机\n\n\nRetryRule\n先按照 RoundRobinRule 的策略获取服务，如果获取服务失败则在指定时间内会进行重试\n\n\nWeightedResponseTimeRule\n对 RoundRobinRule 的扩展，响应速度越快的实例选择权重越大，越容易被选择\n\n\nBestAvailableRule\n会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务\n\n\nAvailabilityFilteringRule\n先过滤掉故障实例，再选择并发较小的实例\n\n\nZoneAvoidanceRule\n默认规则,复合判断 server 所在区域的性能和 server 的可用性选择服务器\n\n\n\n\n如果想要自定义实现某个算法，只需要实现IRule 接口中的部分方法即可\n¶Ribbon 负载规则替换\n🎶 官方文档明确给出了警告： 自定义的 Ribbon 负载均衡类不能放在@componentScan所扫描的当前包及其子包下，否则这个自定义的配置类就会被所有的 Ribbon 客户端所共享，达不到特殊化定制的目的。简而言之，就是不要将 Ribbon 配置类与主启动类放在同一个包中\n12345678//在另一个子包中向 Spring 中注入 IRule 组件@Configurationpublic class MySelfRule &#123;\t@Bean\tpublic IRule myRule() &#123;\t\treturn new RandomRule();\t&#125;&#125;\n123456789@SpringBootApplication@EnableEurekaClient//向 spring boot 声明当前微服务需要使用的 ribbon 规则@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;, configuration = MySelfRule.class)public class OrderMain80 &#123;\tpublic static void main(String[] args) &#123;\t\tSpringApplication.run(OrderMain80.class, args);\t&#125;&#125;\n🎶 由于最终使用的是RestTemplate进行远程调用，所以还需要对注入的RestTemplate 进行配置\n\n123456789@Configurationpublic class ApplicationContextConfig &#123;\t@Bean\t@LoadBalanced\t//声明 resttemplate 使用 ribbon 负载均衡\tpublic RestTemplate getRestTemplate() &#123;\t\treturn new RestTemplate();\t&#125;&#125;\n¶Ribbon 默认负载轮询算法原理\n默认负载轮训算法: rest 接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标，每次服务重启动后 rest 接口计数从 1 开始\n\nIRule.java123456789101112131415161718public interface IRule&#123;/\\*_ choose one alive server from lb.allServers or_ lb.upServers according to key \\*_ @return choosen Server object. NULL is returned if none_ server is available\\*/    //重点关注这方法    public Server choose(Object key);    public void setLoadBalancer(ILoadBalancer lb);    public ILoadBalancer getLoadBalancer();&#125;\nRoundRobinRule.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586ublic class RoundRobinRule extends AbstractLoadBalancerRule &#123;    private AtomicInteger nextServerCyclicCounter;    private static final boolean AVAILABLE_ONLY_SERVERS = true;    private static final boolean ALL_SERVERS = false;    private static Logger log = LoggerFactory.getLogger(RoundRobinRule.class);    public RoundRobinRule() &#123;        nextServerCyclicCounter = new AtomicInteger(0);    &#125;    public RoundRobinRule(ILoadBalancer lb) &#123;        this();        setLoadBalancer(lb);    &#125;    //重点关注这方法。    public Server choose(ILoadBalancer lb, Object key) &#123;        if (lb == null) &#123;            log.warn(&quot;no load balancer&quot;);            return null;        &#125;        Server server = null;        int count = 0;        while (server == null &amp;&amp; count++ &lt; 10) &#123;            List&lt;Server&gt; reachableServers = lb.getReachableServers();            List&lt;Server&gt; allServers = lb.getAllServers();            int upCount = reachableServers.size();            int serverCount = allServers.size();            if ((upCount == 0) || (serverCount == 0)) &#123;                log.warn(&quot;No up servers available from load balancer: &quot; + lb);                return null;            &#125;            int nextServerIndex = incrementAndGetModulo(serverCount);            server = allServers.get(nextServerIndex);            if (server == null) &#123;                /* Transient. */                Thread.yield();                continue;            &#125;            if (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;                return (server);            &#125;            // Next.            server = null;        &#125;        if (count &gt;= 10) &#123;            log.warn(&quot;No available alive servers after 10 tries from load balancer: &quot;                    + lb);        &#125;        return server;    &#125;    /**     * Inspired by the implementation of &#123;@link AtomicInteger#incrementAndGet()&#125;.     *     * @param modulo The modulo to bound the value of the counter.     * @return The next value.     */    private int incrementAndGetModulo(int modulo) &#123;        for (;;) &#123;            int current = nextServerCyclicCounter.get();            int next = (current + 1) % modulo;//求余法            if (nextServerCyclicCounter.compareAndSet(current, next))                return next;        &#125;    &#125;    @Override    public Server choose(Object key) &#123;        return choose(getLoadBalancer(), key);    &#125;    @Override    public void initWithNiwsConfig(IClientConfig clientConfig) &#123;    &#125;&#125;\n¶附录\n服务端负载均衡和客户端负载均衡（Ribbon）的区别\n客户端负载均衡与服务端负载均衡\n","dateCreated":"2022-01-27T16:05:54+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2022-01-27T16:05:54+00:00","description":"什么是 Ribbon? 为什么要用 Ribbon?","headline":"ribbon","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/ribbon/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/ribbon/","keywords":"SpringCloud"}</script><meta name="description" content="什么是 Ribbon? 为什么要用 Ribbon?"><meta property="og:type" content="blog"><meta property="og:title" content="ribbon"><meta property="og:url" content="https://pineapple-man.github.io/ribbon/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="什么是 Ribbon? 为什么要用 Ribbon?"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/springcloud/spirngcloud-ribbon-requestflow.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/springcloud/springcloud-ribbon-iruler.png"><meta property="article:published_time" content="2022-01-27T16:05:54.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.011Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="SpringCloud"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/springcloud/spirngcloud-ribbon-requestflow.png"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">ribbon</h1><div class="post-meta"><time datetime="2022-01-27T16:05:54+00:00">1月 27, 2022 </time><span>发布在 </span><a class="category-link" href="/categories/Java/">Java</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 1.9k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 19 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E4%B8%AD%E5%BC%8F-LB"><span class="toc-text">集中式 LB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%86%85-LB"><span class="toc-text">进程内 LB</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ribbon-%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">Ribbon 的负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ribbon-%E9%BB%98%E8%AE%A4%E8%87%AA%E5%B8%A6%E7%9A%84%E8%B4%9F%E8%BD%BD%E8%A7%84%E5%88%99"><span class="toc-text">Ribbon 默认自带的负载规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ribbon-%E8%B4%9F%E8%BD%BD%E8%A7%84%E5%88%99%E6%9B%BF%E6%8D%A2"><span class="toc-text">Ribbon 负载规则替换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ribbon-%E9%BB%98%E8%AE%A4%E8%B4%9F%E8%BD%BD%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text">Ribbon 默认负载轮询算法原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol><h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><p>Spring Cloud Ribbon 是基于 Netflix Ribbon 实现的一套客户端负载均衡的工具，主要功能是<strong>提供客户端的软件负载均衡算法和服务调用</strong>。Ribbon 客户端组件提供一系列完善的配置项如连接超时，重试等。简单地说，就是在配置文件中列出 Load Balancer(简称 LB) 后面所有的机器，Ribbon 会自动的帮助你基于某种规则(如简单轮询，随机连接等）去连接这些机器。我们很容易使用 Ribbon 实现自定义的负载均衡算法</p><div class="alert info no-icon"><p>📓 Ribbon 目前也进入维护模式。Ribbon 未来可能被 Spring Cloud LoadBalacer 替代</p></div><p>❓什么是 Load Banlance(负载均衡)?</p><div class="alert success no-icon"><p>简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的 HA (高可用)，常见的负载均衡有软件 Nginx，LVS，硬件 F5 等</p></div><p>🆚 Ribbon 的负载均衡 VS Nginx 的负载均衡两者有什么区别？</p><div class="alert success no-icon"><ul><li>Nginx 的负载均衡是一种服务端负载均衡技术，客户端发送请求后，被服务端负载均衡器拦截，随后负载均衡器根据相应的负载均衡算法分发请求到具体服务器上处理请求。</li><li>Ribbon 的负载均衡是一种客户端负载均衡技术，客户端想某一处发送请求时，会根据自身内部代码逻辑，已经做好了负载均衡的实现，直接访问到具体的服务。Ribbon 的客户端负载均衡配置就处于微服务的消费者中，消费者根据代码中自身拥有的负载均衡算法使用 <code>restTemplate</code>进行远程调用。</li></ul></div><p>从整体的请求过程可以明显看出服务端负载均衡和客户端负载均衡的差别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务端负载均衡： 客户端请求 ===&gt; 负载均衡器 ===&gt; 服务器</span><br><span class="line">客户端负载均衡： 客户端请求 ===&gt; 服务器</span><br></pre></td></tr></table></figure><div class="alert info no-icon"><p>服务端负载均衡就是通过一台服务器达到负载均衡效果，客户端负载均衡时通过自身就能够达到负载均衡，并不需要其他服务器；更准确的说，对于服务端的负载均衡技术，所有服务器的清单都是保存在负载均衡器上，负载均衡器用于维护服务器的增加或减少、而对于客户端负载均衡技术，客户端拥有所有服务器的清单，所以客户端能够越过负载均衡器，自身完成负载均衡技术</p></div><p>根据最终负载均衡所在的位置，也可以将负载均衡技术分为两种：集中式负载均衡以及进程内负载均衡</p><h3 id="集中式-LB"><a class="header-anchor" href="#集中式-LB">¶</a>集中式 LB</h3><p>集中式 LB 即在服务的消费方和提供方之间使用独立的 LB 设施(可以是硬件，如 F5, 也可以是软件，如 nginx)，由该设施负责把访问请求通过某种策略转发至服务的提供方</p><h3 id="进程内-LB"><a class="header-anchor" href="#进程内-LB">¶</a>进程内 LB</h3><p>进程内 LB，将 LB 逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。Ribbon 就属于 111 进程内 LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址</p><div class="alert info no-icon"><p>简单的理解， Ribbion 就是负载均衡和 RestTemplate 调用</p></div><h2 id="Ribbon-的负载均衡"><a class="header-anchor" href="#Ribbon-的负载均衡">¶</a>Ribbon 的负载均衡</h2><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/springcloud/spirngcloud-ribbon-requestflow.png" alt=""></p><p>⛵ Ribbon 在工作时分成两步：</p><ol><li><p>先选择 EurekaServer ,它优先选择在同一个区域内负载较少的 server。</p></li><li><p>根据用户指定的策略，在从 server 取到的服务注册列表中选择一个地址。</p></li></ol><p>其中 Ribbon 提供了多种策略：比如轮询、随机和根据响应时间加权。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupld</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupld</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactld</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>spring-cloud-starter-netflix-eureka-client 自带了 spring-cloud-starter-ribbon 引用</p><h2 id="Ribbon-默认自带的负载规则"><a class="header-anchor" href="#Ribbon-默认自带的负载规则">¶</a>Ribbon 默认自带的负载规则</h2><p>Ribbon 中的每一种负载均衡规则都对应着一个类，各个算法具体的含义如下表所示：</p><table><thead><tr><th style="text-align:center">类</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">RoundRobinRule</td><td style="text-align:center">轮询规则</td></tr><tr><td style="text-align:center">RandomRule</td><td style="text-align:center">随机</td></tr><tr><td style="text-align:center">RetryRule</td><td style="text-align:center">先按照 RoundRobinRule 的策略获取服务，如果获取服务失败则在指定时间内会进行重试</td></tr><tr><td style="text-align:center">WeightedResponseTimeRule</td><td style="text-align:center">对 RoundRobinRule 的扩展，响应速度越快的实例选择权重越大，越容易被选择</td></tr><tr><td style="text-align:center">BestAvailableRule</td><td style="text-align:center">会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务</td></tr><tr><td style="text-align:center">AvailabilityFilteringRule</td><td style="text-align:center">先过滤掉故障实例，再选择并发较小的实例</td></tr><tr><td style="text-align:center">ZoneAvoidanceRule</td><td style="text-align:center">默认规则,复合判断 server 所在区域的性能和 server 的可用性选择服务器</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/springcloud/springcloud-ribbon-iruler.png" alt=""></p><p>如果想要自定义实现某个算法，只需要实现<code>IRule</code> 接口中的部分方法即可</p><h2 id="Ribbon-负载规则替换"><a class="header-anchor" href="#Ribbon-负载规则替换">¶</a>Ribbon 负载规则替换</h2><p>🎶 官方文档明确给出了警告： 自定义的 Ribbon 负载均衡类不能放在<code>@componentScan</code>所扫描的当前包及其子包下，否则这个自定义的配置类就会被所有的 Ribbon 客户端所共享，达不到特殊化定制的目的。简而言之，就是不要将 Ribbon 配置类与主启动类放在同一个包中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在另一个子包中向 Spring 中注入 IRule 组件</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySelfRule</span> &#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> IRule <span class="title function_">myRule</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">//向 spring boot 声明当前微服务需要使用的 ribbon 规则</span></span><br><span class="line"><span class="meta">@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;, configuration = MySelfRule.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderMain80</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(OrderMain80.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="alert success no-icon"><p>🎶 由于最终使用的是<code>RestTemplate</code>进行远程调用，所以还需要对注入的<code>RestTemplate</code>进行配置</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@LoadBalanced</span></span><br><span class="line">	<span class="comment">//声明 resttemplate 使用 ribbon 负载均衡</span></span><br><span class="line">	<span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ribbon-默认负载轮询算法原理"><a class="header-anchor" href="#Ribbon-默认负载轮询算法原理">¶</a>Ribbon 默认负载轮询算法原理</h2><div class="alert success no-icon"><p>默认负载轮训算法: rest 接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标，每次服务重启动后 rest 接口计数从 1 开始</p></div><figure class="highlight java"><figcaption><span>IRule.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRule</span>&#123;</span><br><span class="line">/\*</span><br><span class="line">_ choose one alive server from lb.allServers or</span><br><span class="line">_ lb.upServers according to key \*</span><br><span class="line">_ <span class="meta">@return</span> choosen Server object. NULL is returned <span class="keyword">if</span> none</span><br><span class="line">_ server is available</span><br><span class="line">\*/</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点关注这方法</span></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(Object key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ILoadBalancer <span class="title function_">getLoadBalancer</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>RoundRobinRule.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="keyword">class</span> <span class="title class_">RoundRobinRule</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalancerRule</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger nextServerCyclicCounter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">AVAILABLE_ONLY_SERVERS</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">ALL_SERVERS</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(RoundRobinRule.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoundRobinRule</span><span class="params">()</span> &#123;</span><br><span class="line">        nextServerCyclicCounter = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoundRobinRule</span><span class="params">(ILoadBalancer lb)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        setLoadBalancer(lb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点关注这方法。</span></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lb == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;no load balancer&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (server == <span class="literal">null</span> &amp;&amp; count++ &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            List&lt;Server&gt; reachableServers = lb.getReachableServers();</span><br><span class="line">            List&lt;Server&gt; allServers = lb.getAllServers();</span><br><span class="line">            <span class="type">int</span> <span class="variable">upCount</span> <span class="operator">=</span> reachableServers.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">serverCount</span> <span class="operator">=</span> allServers.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((upCount == <span class="number">0</span>) || (serverCount == <span class="number">0</span>)) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;No up servers available from load balancer: &quot;</span> + lb);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextServerIndex</span> <span class="operator">=</span> incrementAndGetModulo(serverCount);</span><br><span class="line">            server = allServers.get(nextServerIndex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">/* Transient. */</span></span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;</span><br><span class="line">                <span class="keyword">return</span> (server);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Next.</span></span><br><span class="line">            server = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;No available alive servers after 10 tries from load balancer: &quot;</span></span><br><span class="line">                    + lb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inspired by the implementation of &#123;<span class="doctag">@link</span> AtomicInteger#incrementAndGet()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modulo The modulo to bound the value of the counter.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The next value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">incrementAndGetModulo</span><span class="params">(<span class="type">int</span> modulo)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> nextServerCyclicCounter.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> (current + <span class="number">1</span>) % modulo;<span class="comment">//求余法</span></span><br><span class="line">            <span class="keyword">if</span> (nextServerCyclicCounter.compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> choose(getLoadBalancer(), key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/22b2c362b973">服务端负载均衡和客户端负载均衡（Ribbon）的区别</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014401141/article/details/78676296">客户端负载均衡与服务端负载均衡</a></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/mysql%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" data-tooltip="mysql踩坑记录" aria-label="上一篇: mysql踩坑记录"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E2%98%9E-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" data-tooltip="结构型模式 ☞ 代理模式" aria-label="下一篇: 结构型模式 ☞ 代理模式"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/mysql%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" data-tooltip="mysql踩坑记录" aria-label="上一篇: mysql踩坑记录"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E2%98%9E-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" data-tooltip="结构型模式 ☞ 代理模式" aria-label="下一篇: 结构型模式 ☞ 代理模式"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>