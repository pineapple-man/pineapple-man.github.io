<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>Java IO(一) IO 总览 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="Java IO"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n\n¶概述\nJava 的 I/O 大概可以分成以下几类:\n\n磁盘操作: File\n字节操作: InputStream 和 OutputStream\n字符操作: Reader 和 Writer\n对象操作: Serializable\n网络操作: Socket\n新 I/O 操作: NIO\n\n\n\n❓Java IO 能用来干什么？\nJava 对数据的操作是通过流的方式进行的，I/O 用来处理设备之间的数据传输(上传文件和下载文件)\n\n\n🎶 输入、输出的参照物是存储数据的介质，把对象读入到介质中定义为输入，对应的，从介质中向外读数据就是输出\n¶根据传输的数据看待 IO\n从数据传输方式或者说是运输方式角度看，可以将 IO 类分为:\n\n字节流（Byte 是计算机操作数据的最小单位，由 8 位 bit 组成）\n字符流（Char 是用户可读取的最小单位，在 Java 中由 16 bit 组成）\n\n\n🎶 可以简单的认为：字节是给计算机看的，字符是给人看的\n¶字节流\n字节流直接操作 byte 类型数据，主要操作类是OutputStream、InputStream的各种子类，特点是：不用缓冲区，直接对文件本身操作\n\n常用的各种子类如下图：\n\n¶字符流\n字符流与字节流不同，主要操作字符类型数据，主要操作类是 Reader、Writer的各种子类；特点是：使用缓冲区缓冲字符，不关闭流就不会输出任何内容\n\n¶字节流和字符流的区别\n🆚 字节流与字符流对比：\n\n字节流每次读取单个字节，字符流每次读取单个字符(一个字符根据编码的不同，对应的字节也不同，如 UTF-8 编码是 3 个字节，中文编码是 2 个字节)\n字节流用来处理二进制文件(图片、MP3、视频文件)，字符流用来处理文本文件(可以看做是特殊的二进制文件只不是使用了某种编码方式，更便于人类阅读)\n\n\n❓ 字节流和字符流应当如何选择？\n\n如果数据所在的文件可以通过记事本打开阅读，就可以使用字符流进行操作，否则只能使用字节流\n常用的音频必须使用字节流而不能使用字符流\n\n\n🎶 如果打开一个文件能够识别选用字符流，如果是一堆乱码选用字节流\n¶互相转换\n从以上分类角度观察，整个 IO 包分为字节流和字符流，为了将两种流联系起来，实际上，除了以上两种流之外，还存在一组的转换类，便于在两种流之间方便转换\n\nOutputStreamWriter：是 Writer 的子类，将输出的字符流变为字节流，即将一个字符流的输出对象变为字节流输出对象。\nInputStreamReader：是 Reader 的子类，将输入的字节流变为字符流，即将一个字节流的输入对象变为字符流的输入对象。\n\n\n✨ Java 使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储，Java 中的 IO 形式如下：\n\n🎶 Java I/O 流的特点是：每个基类的实现类都是以父类名作为类名的后缀进行命名的\n¶从数据操作方式看待 IO\n从数据来源或者操作对象角度看，IO 类可以分为：\n\n¶Java I/O 演进之路\n上述的介绍只能说是对 Java IO API 有了一个全貌的了解，下面要介绍的内容将是 Java IO 系统中的核心也是一个语言的难点所在，Java 中的 IO 模型。\n🎶 注意上下文，特别强调这里表述的是Java IO,而不是 Unix IO 或其他的 IO 形式。其实，Java 的 IO 模型本质上还是利用操作系统提供的接口来实现,所以想要了解 Java Io 模型之前最好先了解 Linux 底层 IO 模型\n¶I/O 模型基础\n🤔什么是 I/O 模型？\n\nI/O 模型是有上下文关系的，没有明确的上下文是不能确定所表达的 I/O 模型\n常说的阻塞、非阻塞、同步、异步其实都是网络 IO 场景下的 Unix I/O 模型区分\n可以简单的将 IO 模型理解为：使用 IO 处理数据的一种套路\n\n\n¶Java I/O 模型\nJava 共支持 3 种网络编程的/IO 模型：BIO、NIO、AIO，在实际通信需求下，要根据不同的业务场景和性能需求决定选择不同的 I/O 模型\n\n¶Java BIO\n在 JDK 1.4 之前，基于 Java 的所有 Socket 通信都采用同步阻塞模式(BIO)，这种请求一应答的通信模型简化了上层的应用开发，但是在性能和可靠性方面却存在着巨大的瓶颈。当并发量增大，响应时间延迟增大之后，采用 Java BIO 开发的服务端只有通过硬件的不断扩容来满足高并发和低延迟，它极大的增加了企业的成本，随着集群规模的不断膨胀，系统的可维护性也面临巨大的挑战\n同步阻塞(传统阻塞型)模型，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销\n\n\n经典的网络服务设计如上图所示，对每个请求都会产生一个新的线程来进行处理，这种设计的缺点就是：线程创建本身也是系统资源的一次比较耗时的开销，如果并发请求达到一定数量，响应将会变慢，甚至有可能因为系统资源不足而造成系统的崩溃。\n传统的 BIO 代码类似如下：\n12345678910111213141516171819202122232425262728293031323334353637public class BlokingIoServer implements Runnable&#123;    @Override    public void run() &#123;        try &#123;            //将服务绑定到指定端口            ServerSocket ss = new ServerSocket(8888);            while (!Thread.interrupted())&#123;                //对 accept()方法的调 用将被阻塞，直到一个连接建立                final Socket clientSocket = ss.accept();                //为每个请求创建一个线程来处理                new Thread(new Handler(clientSocket)).start();            &#125;            // or, single-threaded, or a thread pool        &#125; catch (IOException ex) &#123; /* ... */ &#125;    &#125;    static class Handler implements Runnable &#123;        final Socket socket;        Handler(Socket s)&#123;            socket = s;        &#125;        @Override        public void run() &#123;            try &#123;                byte[] input = new byte[1024];                socket.getInputStream().read(input);                byte[] output = process(input);                socket.getOutputStream().write(output);            &#125; catch (IOException ex) &#123; /* ... */ &#125;        &#125;        private byte[] process(byte[] cmd)&#123;            //do something            return null;        &#125;    &#125;&#125;\n¶Java NIO\n同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求就进行处理\n\n\n¶Java AIO\n异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的 I/O 请求都是由 OS 先完成了再通知服务器应用去启动线程进行处理，一般适用于连接数较多且连接时间较长的应用\n\n¶Java 各种 IO 使用场景分析\n\n\n\nJava IO 方式\n适用场景\n\n\n\n\nBIO\n连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择\n\n\nNIO\n连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等，JDK1.4 开始支持\n\n\nAIO\n连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，JDK7 开始支持\n\n\n\n🤔 为什么需要进阶 IO？\n基础的 IO 仅仅关注于本地文件读写等操作，其实从更广义的角度来讲，任意两台计算机间的通信也是一种 IO ；进程间数据通信也是一种 IO ，因此当完成基础的 IO 学习之后，需要了解到更加复杂的 IO 模式，有效的使用 IO 能够明显的提高代码的效率\n\n¶附录\nJava IO 模型\n谈一谈 Java IO 模型\n深入理解 Java I/O 模型\n深入学习 JAVA -IO 流详解\n","dateCreated":"2022-01-20T15:12:35+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2022-01-20T15:12:35+00:00","description":"Java 类库的设计者通过创建大量大类解决不同方式 I/O 通信的难题。具有讽刺意义的是，Java I/O 设计的初衷是为了避免过多的类，但是通过不停的迭代，如今的 I/O 系统提供了非常多类，让使用者感到不到所措。","headline":"Java IO(一) IO 总览","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/java-io-%E4%B8%80-io-%E6%80%BB%E8%A7%88/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/java-io-%E4%B8%80-io-%E6%80%BB%E8%A7%88/","keywords":"Java IO"}</script><meta name="description" content="Java 类库的设计者通过创建大量大类解决不同方式 I&#x2F;O 通信的难题。具有讽刺意义的是，Java I&#x2F;O 设计的初衷是为了避免过多的类，但是通过不停的迭代，如今的 I&#x2F;O 系统提供了非常多类，让使用者感到不到所措。"><meta property="og:type" content="blog"><meta property="og:title" content="Java IO(一) IO 总览"><meta property="og:url" content="https://pineapple-man.github.io/java-io-%E4%B8%80-io-%E6%80%BB%E8%A7%88/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="Java 类库的设计者通过创建大量大类解决不同方式 I&#x2F;O 通信的难题。具有讽刺意义的是，Java I&#x2F;O 设计的初衷是为了避免过多的类，但是通过不停的迭代，如今的 I&#x2F;O 系统提供了非常多类，让使用者感到不到所措。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-overview.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-catagory.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-stream.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-stream-category.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-character-category.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-transformer.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-operator-category.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-bio-overview.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-nio-overview.png"><meta property="article:published_time" content="2022-01-20T15:12:35.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.007Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="Java IO"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-overview.jpg"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">Java IO(一) IO 总览</h1><div class="post-meta"><time datetime="2022-01-20T15:12:35+00:00">1月 20, 2022 </time><span>发布在 </span><a class="category-link" href="/categories/Java/">Java</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 2.1k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 20 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9C%8B%E5%BE%85-IO"><span class="toc-text">根据传输的数据看待 IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-text">字节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-text">字符流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">字节流和字符流的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="toc-text">互相转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E7%9C%8B%E5%BE%85-IO"><span class="toc-text">从数据操作方式看待 IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-I-O-%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF"><span class="toc-text">Java I&#x2F;O 演进之路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80"><span class="toc-text">I&#x2F;O 模型基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-I-O-%E6%A8%A1%E5%9E%8B"><span class="toc-text">Java I&#x2F;O 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-BIO"><span class="toc-text">Java BIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-NIO"><span class="toc-text">Java NIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-AIO"><span class="toc-text">Java AIO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%90%84%E7%A7%8D-IO-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-text">Java 各种 IO 使用场景分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-overview.jpg" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-overview.jpg" alt=""></a></div><h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><div class="alert success no-icon"><p>Java 的 I/O 大概可以分成以下几类:</p><ul><li>磁盘操作: File</li><li>字节操作: InputStream 和 OutputStream</li><li>字符操作: Reader 和 Writer</li><li>对象操作: Serializable</li><li>网络操作: Socket</li><li>新 I/O 操作: NIO</li></ul></div><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-catagory.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-catagory.png" alt=""></a></div><p>❓Java IO 能用来干什么？</p><div class="alert success no-icon"><p>Java 对数据的操作是通过流的方式进行的，I/O 用来处理设备之间的数据传输(<strong>上传文件</strong>和<strong>下载文件</strong>)</p></div><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-stream.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-stream.png" alt=""></a></div><p>🎶 输入、输出的参照物是<strong>存储数据的介质</strong>，把<strong>对象读入到介质中</strong>定义为输入，对应的，<strong>从介质中向外读数据</strong>就是输出</p><h2 id="根据传输的数据看待-IO"><a class="header-anchor" href="#根据传输的数据看待-IO">¶</a>根据传输的数据看待 IO</h2><p>从数据传输方式或者说是运输方式角度看，可以将 IO 类分为:</p><div class="alert success no-icon"><ul><li>字节流（Byte 是计算机操作数据的最小单位，由 8 位 bit 组成）</li><li>字符流（Char 是用户可读取的最小单位，在 Java 中由 16 bit 组成）</li></ul></div><p>🎶 可以简单的认为：<code>字节</code>是给计算机看的，<code>字符</code>是给人看的</p><h3 id="字节流"><a class="header-anchor" href="#字节流">¶</a>字节流</h3><div class="alert success no-icon"><p>字节流直接操作 byte 类型数据，主要操作类是<code>OutputStream</code>、<code>InputStream</code>的各种子类，特点是：<strong>不用缓冲区</strong>，直接对文件本身操作</p></div><p>常用的各种子类如下图：</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-stream-category.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-stream-category.png" alt=""></a></div><h3 id="字符流"><a class="header-anchor" href="#字符流">¶</a>字符流</h3><p>字符流与字节流不同，主要操作字符类型数据，主要操作类是 <code>Reader</code>、<code>Writer</code>的各种子类；特点是：<strong>使用缓冲区缓冲字符</strong>，不关闭流就不会输出任何内容</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-character-category.png" alt=""></p><h3 id="字节流和字符流的区别"><a class="header-anchor" href="#字节流和字符流的区别">¶</a>字节流和字符流的区别</h3><p>🆚 字节流与字符流对比：</p><div class="alert success no-icon"><ul><li>字节流每次读取单个字节，字符流每次读取单个字符(一个字符根据编码的不同，对应的字节也不同，如 UTF-8 编码是 3 个字节，中文编码是 2 个字节)</li><li>字节流用来处理二进制文件(图片、MP3、视频文件)，字符流用来处理文本文件(可以看做是特殊的二进制文件只不是使用了某种编码方式，更便于人类阅读)</li></ul></div><p>❓ 字节流和字符流应当如何选择？</p><div class="alert success no-icon"><ul><li>如果数据所在的文件可以通过记事本打开阅读，就可以使用字符流进行操作，否则只能使用字节流</li><li>常用的音频必须使用字节流而不能使用字符流</li></ul></div><p>🎶 如果打开一个文件能够识别选用字符流，如果是一堆<strong>乱码选用字节流</strong></p><h3 id="互相转换"><a class="header-anchor" href="#互相转换">¶</a>互相转换</h3><p>从以上分类角度观察，整个 IO 包分为字节流和字符流，为了将两种流联系起来，实际上，除了以上两种流之外，还存在一组的<strong>转换类</strong>，便于在两种流之间方便转换</p><div class="alert success no-icon"><ul><li><code>OutputStreamWriter</code>：是 Writer 的子类，将输出的字符流变为字节流，即将一个字符流的输出对象变为字节流输出对象。</li><li><code>InputStreamReader</code>：是 Reader 的子类，将输入的字节流变为字符流，即将一个字节流的输入对象变为字符流的输入对象。</li></ul></div><p>✨ Java 使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储，Java 中的 IO 形式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-transformer.png" alt=""></p><p>🎶 Java I/O 流的特点是：每个基类的实现类都是<strong>以父类名作为类名的后缀</strong>进行命名的</p><h2 id="从数据操作方式看待-IO"><a class="header-anchor" href="#从数据操作方式看待-IO">¶</a>从数据操作方式看待 IO</h2><p>从数据来源或者操作对象角度看，IO 类可以分为：</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-operator-category.png" alt="img"></p><h2 id="Java-I-O-演进之路"><a class="header-anchor" href="#Java-I-O-演进之路">¶</a>Java I/O 演进之路</h2><p>上述的介绍只能说是对 Java IO API 有了一个全貌的了解，下面要介绍的内容将是 Java IO 系统中的核心也是一个语言的难点所在，Java 中的 IO 模型。</p><p>🎶 注意上下文，特别强调这里表述的是<font style="color:red;font-weight:700">Java IO</font>,而不是 Unix IO 或其他的 IO 形式。其实，Java 的 IO 模型本质上还是<font style="color:red;font-weight:700">利用操作系统提供的接口来实现</font>,所以想要了解 Java Io 模型之前最好先了解 Linux 底层 IO 模型</p><h3 id="I-O-模型基础"><a class="header-anchor" href="#I-O-模型基础">¶</a>I/O 模型基础</h3><p>🤔什么是 I/O 模型？</p><div class="alert success no-icon"><ul><li>I/O 模型是有上下文关系的，没有明确的上下文是不能确定所表达的 I/O 模型</li><li>常说的阻塞、非阻塞、同步、异步其实都是网络 IO 场景下的 Unix I/O 模型区分</li><li>可以简单的将 IO 模型理解为：使用 IO 处理数据的一种套路</li></ul></div><h3 id="Java-I-O-模型"><a class="header-anchor" href="#Java-I-O-模型">¶</a>Java I/O 模型</h3><div class="alert success no-icon"><p>Java 共支持 3 种网络编程的/IO 模型：<strong>BIO、NIO、AIO</strong>，在实际通信需求下，要根据不同的业务场景和性能需求决定选择不同的 I/O 模型</p></div><h4 id="Java-BIO"><a class="header-anchor" href="#Java-BIO">¶</a>Java BIO</h4><p>在 JDK 1.4 之前，基于 Java 的所有 Socket 通信都采用同步阻塞模式(BIO)，这种<code>请求一应答</code>的通信模型简化了上层的应用开发，但是在性能和可靠性方面却存在着巨大的瓶颈。当并发量增大，响应时间延迟增大之后，采用 Java BIO 开发的服务端只有通过硬件的不断扩容来满足高并发和低延迟，它极大的增加了企业的成本，随着集群规模的不断膨胀，系统的可维护性也面临巨大的挑战</p><div class="alert success no-icon"><p>同步阻塞(传统阻塞型)模型，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销</p></div><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-bio-overview.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-bio-overview.png" alt=""></a></div><p>经典的网络服务设计如上图所示，对每个请求都会产生一个新的线程来进行处理，这种设计的缺点就是：线程创建本身也是系统资源的一次比较耗时的开销，如果并发请求达到一定数量，响应将会变慢，甚至有可能因为系统资源不足而造成系统的崩溃。</p><p>传统的 BIO 代码类似如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlokingIoServer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将服务绑定到指定端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted())&#123;</span><br><span class="line">                <span class="comment">//对 accept()方法的调 用将被阻塞，直到一个连接建立</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//为每个请求创建一个线程来处理</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Handler</span>(clientSocket)).start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// or, single-threaded, or a thread pool</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Handler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Socket socket;</span><br><span class="line">        Handler(Socket s)&#123;</span><br><span class="line">            socket = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] input = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                socket.getInputStream().read(input);</span><br><span class="line">                <span class="type">byte</span>[] output = process(input);</span><br><span class="line">                socket.getOutputStream().write(output);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] process(<span class="type">byte</span>[] cmd)&#123;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java-NIO"><a class="header-anchor" href="#Java-NIO">¶</a>Java NIO</h4><div class="alert success no-icon"><p>同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求就进行处理</p></div><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-nio-overview.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java-io-nio-overview.png" alt=""></a></div><h4 id="Java-AIO"><a class="header-anchor" href="#Java-AIO">¶</a>Java AIO</h4><div class="alert success no-icon"><p>异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的 I/O 请求都是由 OS 先完成了再通知服务器应用去启动线程进行处理，一般适用于连接数较多且连接时间较长的应用</p></div><h3 id="Java-各种-IO-使用场景分析"><a class="header-anchor" href="#Java-各种-IO-使用场景分析">¶</a>Java 各种 IO 使用场景分析</h3><table><thead><tr><th style="text-align:center">Java IO 方式</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td style="text-align:center"><strong>BIO</strong></td><td style="text-align:center">连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择</td></tr><tr><td style="text-align:center"><strong>NIO</strong></td><td style="text-align:center">连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等，JDK1.4 开始支持</td></tr><tr><td style="text-align:center"><strong>AIO</strong></td><td style="text-align:center">连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，JDK7 开始支持</td></tr></tbody></table><p>🤔 为什么需要进阶 IO？</p><div class="alert warning no-icon"><p>基础的 IO 仅仅关注于本地文件读写等操作，其实从更广义的角度来讲，任意两台计算机间的通信也是一种 IO ；进程间数据通信也是一种 IO ，因此当完成基础的 IO 学习之后，需要了解到更加复杂的 IO 模式，有效的使用 IO 能够明显的提高代码的效率</p></div><h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/75716224">Java IO 模型</a><br><a target="_blank" rel="noopener" href="https://matt33.com/2017/08/12/java-nio/">谈一谈 Java IO 模型</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903839439519758">深入理解 Java I/O 模型</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023008389">深入学习 JAVA -IO 流详解</a></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/Java-IO/" rel="tag">Java IO</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/java-%E5%86%85%E9%83%A8%E7%B1%BB%E8%AF%A6%E8%A7%A3/" data-tooltip="Java 内部类详解" aria-label="上一篇: Java 内部类详解"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/springmvc-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/" data-tooltip="SpringMVC 核心注解总结" aria-label="下一篇: SpringMVC 核心注解总结"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/java-%E5%86%85%E9%83%A8%E7%B1%BB%E8%AF%A6%E8%A7%A3/" data-tooltip="Java 内部类详解" aria-label="上一篇: Java 内部类详解"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/springmvc-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/" data-tooltip="SpringMVC 核心注解总结" aria-label="下一篇: SpringMVC 核心注解总结"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>