<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>Java IO(二) IO 系统基础 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="NIO"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n输出流会自动创建文件，输入流读取之前文件必须存在\n\n¶概述\n自从 Java 1.0 版本以来，Java 的 I/O 库发生了明显改变，在原来面向字节的类中添加了面向字符和基于 Unicode 的类。在 JDK 1.4 中，添加了 NIO 类，添加进来主要是为了改进性能以及功能。因此，在充分理解 Java I/O 系统之前需要学习相当数量的类。\n¶File\nFile 类的名字有一定的误导性，实际上此类既能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称。如果它指的是一个文件集，就可以对此集合调用list()方法\n123456//根据一个路径得到 File 对象File(String pathname);//根据一个目录和一个子文件得到 File 对象File(String parent, String child);//根据一个父 File 对象和一个子文件/目录得到 File 对象File(File parent, String child);\n🎶 toString()被重写为文件的绝对路径\n\nFile 的众多成员方法就是常见的文件操作，如：创建文件、创建目录，移动、重命名等\n¶创建功能\n123456//创建文件public boolean createNewFile() throws IOException;//创建目录,如果存在这样的目录就不创建,并且返回false,如果父目录不存在,子文件就不会创建public boolean mkdir();//创建目录,如果父目录不存在,就会创建多级目录 &lt;==&gt; mkdir -ppublic boolean mkdirs();\n🎶创建文件主要要点：\n\n\n文件名和目录不可以同名\n\n\n明确需要创建的是一个文件还是一个目录\n\n\n相对路径，相对的是当前正在运行的 java 项目文件\n\n\n¶删除功能\n1public boolean delete();\t//删除文件 | 目录(当前目录下必须为空时,才能删除) &lt;==&gt; rm\n¶重命名功能\n1public boolean renameTo(File dest);// &lt;==&gt; mv 命令\n123File file = new File(&quot;/Users/xxx/Desktop/test&quot;);File file1 = new File(&quot;/Users/xxx/Desktop/test1&quot;);file.renameTo(file1);//如果两个文件的父路径不一致,功能将变为重命名+剪切\n¶判断功能\n1234567public boolean isDirectory();\t//目录?public boolean isFile();\t\t//文件?public boolean isHidden();\t\t//隐藏?public boolean exists();\t\t//存在?public boolean canExecute();\t//可执行?public boolean canRead();\t\t//可读?public boolean canWrite();\t\t//可写?\n¶基本获取功能\n123456public String getAbsolutePath();//绝对路径public String getPath();//相对路径public String getName();//文件名字public String getParent();//如果父目录存在,返回父目录的路径,否则返回nullpublic long length();//文件大小,单位:字节数(B)public long lastModified();//获取最后一次的修改时间,毫秒数\n1234File file = new File(&quot;/Users/xxx/Desktop/timg.jpg&quot;);System.out.println(file.getAbsolutePath());System.out.println(&quot;&quot; + (file.length()) + &#x27;B&#x27;);System.out.println(file.getParent());\n¶高级获取功能\n123public String[] list();//获取指定目录下的所有文件或者文件夹的名称数组public String[] list(FilenameFilter filter);//FilenameFilter接口过滤然public File[] listFiles();//返回文件对象数组，只深入一层\n123456789//需求:获取file目录下所有以.jpg结尾的文件public static void main(String[] args)&#123;  File file = new File(&quot;/Users/xxx/Desktop&quot;);  File[] files = file.listFiles();  for (File tempFile : files) &#123;    if (tempFile.getName().endsWith(&quot;.jpg&quot;))        System.out.println(tempFile.getAbsolutePath());  &#125;&#125;\n使用FilenameFilter接口,充当过滤器，过滤文件\n123456789101112131415public static void main(String[] args)&#123;\tFile file = new File(&quot;/Users/hmc/Desktop&quot;);\tFile[] files =    \tfile.listFiles(  \t      new FilenameFilter() &#123;\t          @Override          \tpublic boolean accept(File dir, String name) &#123;        \t    //返回true则将当前File(dir,name)加入到files数组中,否则不进行操作      \t      return new File(dir, name).isFile() &amp;&amp; name.endsWith(&quot;.jpg&quot;);    \t      &#125;  \t      &#125;);\tfor (File file1 : files) &#123;  \tSystem.out.println(file1.getAbsolutePath());\t&#125;&#125;\n¶输入和输出\n编程语言的 I/O 类库中常使用「 流 」 这个抽象概念，它代表任何又能力产出数据的数据源对象或者有能力接受数据的数据端对象。流屏蔽了实际的 I/O 设备中处理数据的细节。Java 类库中的 I/O 类分成输入和输出两部分。通过继承，任何自InputStream或Reader派生而来的类都含有 read()基本方法，用于读取单个字节或者字节数组。同样，任何自OuputStream或Writer派生而来的类都含有名为 write()的基本方法，用于写单格字节或者字节数组。\n✨ 但是，通常并不会直接用到这些方法，它们之所以存在是因为别的类可以使用它们，以便提供更有用的接口。因此，日常开发中很少使用单一的类来创建流对象，而是通过堆叠多个流对象来创建所期望的功能「 这是装饰者设计模式 」。实际上，Java 中的流库让人迷惑的主要原因就在于：创建单一的结果流，却需要创建多个对象。\n¶InputStream 类型\n\nInputStream的作用是用来表示哪些从不同数据源产生输入的类，这些数据源包括：\n\n字节数组\nString 对象\n文件\n管道\n一个由其他种类多流组成的序列\n其他数据源，如 Internet 连接等\n\n每一种数据源都有相应的 InputStream子类。另外，FilterInputStream 也属于一种 InputStream ，为装饰器类提供基类「 装饰器可以把属性或有用的接口与输入流连接在一起\n\n\n\n类\n功能\n构造器参数\n如何使用\n\n\n\n\nByteArrayInputStream\n允许将内存的缓冲区当作 InputStream 使用\n缓冲区，字节将从中取出\n作为一种数据源：将其与 FilterInputStream\n\n\nStringBufferInputStream(已弃用)\n将 String 转换成 InputStream\n字符串，底层实际使用 StringBuffer\n作为一种数据源：将其与 FilterInputStream\n\n\nFileInputStream\n用于从文件中读取信息\n字符串，表示文件名、文件或 FileDescriptor 对象\n作为一种数据源：将其与 FilterInputStream\n\n\nPipedInputStream\n产生用于写入 PipedOutputStream 的数据，实现管道话概念\nPipedOutputStream\n作为一种数据源：将其与 FilterInputStream\n\n\nSequenceInputStream\n将两个或多个 InputStream 转换成单一 InputStream\n两个 InputStream 对象或一个容纳 InputStream 对象的容器 Enumeration\n作为一种数据源：将其与 FilterInputStream\n\n\nFilterInputStream\n抽象类，作为装饰器的接口，为其他的 InputStream 类提供有用功能\n\n\n\n\n\n¶OutputStream类型\n该类别的类决定了输出所要去往的目标：字节数组byte[]（并不是String，当然可以用字节数组自己创建字符串）、文件或管道。另外，FilterOutputStream 为装饰器类提供了一个基类，装饰器类把属性或者有用的接口与输出流连接了起来\n\n\n\n类\n功能\n构造器参数\n如何使用\n\n\n\n\nByteArrayOutputStream\n在内存中创建缓冲区，所有送往该流的数据最终都要放置在此缓冲区\n缓冲区初始化尺寸（可选的）\n用于指定数据的目的地：将其与 FilterOutputStream 对象相连以提供有用的接口\n\n\nFileOutputStream\n用于将信息写至文件\n字符串，表示文件名、文件或 FilterDescriptor 对象\n用于指定数据的目的地：将其与 FilterOutputStream 对象相连以提供有用的接口\n\n\nPipedOutputStream\n任何写入其中的信息都会自动作为相关 PipedInputStream 的输出。实现管道化概念\nPipedInputStream\n用于指定数据的目的地：将其与 FilterOutputStream 对象相连以提供有用的接口\n\n\nFilterOutputStream\n抽象类，作为装饰器的接口，其中装饰器为其他 OutputStream 提供有用的功能\n\n\n\n\n\n¶添加属性和有用的接口\nFilterInputStream 和 FilterOutputStream 是用来提供装饰器类接口以控制特定输入流和输出流的两个类，分别由 InputStream 和 OutputStream 派生而来，这两个类是装饰器的能够工作的必要条件\n¶通过 FilterInputStream 从 InputStream 读取数据\nFilterInputStream 能够完成两件完全不同的事情。其中，DataInputStream 允许读取不同的基本类型数据以及 String 对象（所有的方法都以read开头，例如：readBytte(),readFloat()等等），搭配相应的 DataOutputStream，就可以通过数据流将基本类型的数据从一个地方迁移到另一个地方。具体是哪些地方，由 InputStream 可以读取到来源决定\n其他 FilterInputStream 类则在内部修改 InputStream 的行为方式，例如：是否缓存，是否保留它所读取过的行（允许我们查询行数或设置行数），以及是否把单一字符推回输入流等等。\n不管正在连接的是什么 I/O 设备，几乎每次都要对输入进行缓存，所以 I/O 类库将无缓存输入作为特殊情况\n\n\n\n类\n功能\n构造器参数\n如何使用\n\n\n\n\nDataInputStream\n与 DataOutputStream 搭配使用，可以按照可移植方式从流读取基本数据类型\nInputStream\n包含用于读取基本数据类型的全部接口\n\n\nBufferInputStream\n使用此类可以防止每次读取时都进行实际写操作代表 「 使用缓冲区 」\nInputStream 可以指定缓冲区大小\n本质上不提供接口，只不过是向进程中添加缓冲区所必需的，与接口对象搭配\n\n\nLineNumberInputStream\n跟踪输入流中的行好，可调用 getLineNumber() 和 setLineNumber(int)\nInputStream\n仅增加了行号，因此可能要与接口对象搭配使用\n\n\nPushbackInputStream\n具有能弹出一个字节的缓冲区，因此可以将读到的最后一个字符回退\nInputStream\n通常作为编译器的扫描器，开发过程中几乎用不到\n\n\n\n¶通过 FilterOutputStream 从 OutputStream 写入数据\n与 DataInputStream 对应的是 DataOutputStream，它可以将各种基本数据类型以及 String 对象格式化输出到流中。如此操作，最终任何机器上的任何 DataInputStream 都能够读取它们。其中写操作都是以write开头，例如writeByte(),writeFloat()等等\nPrintStream 最初的目的是为了可视化格式打印所有的基本数据类型以及 String 对象。这与 DataOutputStream 是不同的，后者的目的是将数据置入流中，使 DataInputStream 能够可移植地重构它们。PrintStream 内有两个重要的方法：print()和println()。对它们进行了重载，以便可打印出各种数据类型。print() 和 println() 之间的差异是，后者在操作完毕后会添加一个换行符。\n😢 PrintStream 可能会有些问题，因为它捕获了所有的 IOExceptions，因此必须使用 checkError()自行测试错误状态，如果出现错误此方法将返回true，另外，PrintStream 也未完全国际化，不能以平台无关的方式处理换行动作 「 值的庆幸的是，以上出现的问题，最终都在 PrintWriter 中得以解决 」\nBufferOutputStream 是一个修改过的 OutputStream，它对数据流使用缓冲技术，因此当每次向流写入时，不必每次都进行实际的物理写动作。所以在进行输出时，可能更经常使用它。FilterOutputStream 的类型以及功能如下表\n\n\n\n类\n功能\n构造器参数\n如何使用\n\n\n\n\nDataOutputStream\n与 DataInputStream 搭配使用\nOutputStream\n包含用于写入基本类型数据的全部接口\n\n\nPrintStream\n用于产生格式化输出，其中 DataOutputStream 处理数据的存储，PrintStream 处理显示\nOutputStream 可以用 boolean 值指示是否在每次换行时清空缓冲区\n应该是对 OutpuStream 对象的 final 封装，kennel 会经常使用到他\n\n\nBufferedOutputStream\n使用它以避免每次发送数据时都要进行实际的写操作，代表 「 使用缓冲区 」，可以调用 flush() 清空缓冲区\nOutputStream 可以指定缓冲区大小\n本质上并不提供接口，只不过是向进程中添加缓冲区所必需的，与接口对象搭配\n\n\n\n¶Reader 和 Writer\nReader 和 Writer 是 Java 1.1 中新增加的两个类，提供兼容 Unicode 与面向字符的 I/O 功能，这两个类并不会替代已有的 InputStream 以及 OutputStream 。有时必须把来自于字节层次结构中的类和字符层次结构中的类结合起来使用。为了实现这个目的，要用到适配器类，这是一种适配器模式。InputStreamReader 可以将 InputStream 转换为 Reader，而 OutputStreamWriter 能够将 OutputStream 转换为 Writer。\n设计 Reader 和 Writer 继承层次结构主要是为了国际化，老的 I/O 流继承层次结构仅支持 8 位字节流，并且不能很好地处理 16 位 Unicode 字符，由于 Unicode 用于字符国际化（ Java 本身的 char 也是 16 位的 Unicode），所以添加 Reader 和 Writer 继承层次结构是为了在所有的 I/O 操作中都支持 Unicode\n¶数据的来源与去处\n几乎所有原始的 Java I/O 流类都有相应的 Reader 和 Writer 类来提供天然的 Unicode 操作，这并不代笔着无论什么情况都可以使用字符流而不使用字节流。其实在某些特殊的情况下，就只支持面向字节流而没有面向字符流的支持，因此，最明智的做法是尽量尝试使用 Reader 和 Writer\n下面展示了在两个继承层次结构中，信息的来源和去处之间的对应关系\n\n\n\n来源与去处：Java 1.0 类\n对应的 Java 1.1 类\n\n\n\n\nInputStream\nReader适配器：InputStreamReader\n\n\nOutputStream\nWriter适配器：OutputStreamWriter\n\n\nFileInputStream\nFileReader\n\n\nFileOutputStream\nFileWriter\n\n\nByteArrayInputStream\nCharArrayReader\n\n\nByteArrayOutputStream\nCharArrayWriter\n\n\nPipedInputStream\nPipedReader\n\n\nPipedOutputStream\nPipedWriter\n\n\n\n这两个不同的继承层次结构中的结构即使不能说完全相同，也是非常相似了\n¶更改流的行为\n对于 InputStream 和 OutputStream 来说，可以使用 FIlterInputStream 和 FilterOutputStream 的装饰器子类来修改流已满足特殊需求，Reader 和 Writer 的类继承层次结构继续沿用相同思想，但是具体细节却并不相同，下表相对于前一表格来说，左右之间的对应关系的近似程序更加粗略一些。造成这种差别的原因是因为类的不同组织形式不同。例如： BufferedOutputStream 是 FilterOutputStream 的子类，但是 BufferedWriter 并不是 FIlterWriter 的子类，但是这些类的接口却是十分相似的\n\n\n\nJava 1.0 类\nJava 1.1 类\n\n\n\n\nFilterInputStream\nFilterReader\n\n\nFilterOutputStream\nFilterWriter（抽象类，没有子类）\n\n\nBufferedInputStream\nBufferedReader\n\n\nBufferedOutputStream\nBufferedWriter\n\n\nDataInputStream\n最好使用 BufferedReader 而不是使用 DataInputStream 的 readLine（）方法\n\n\nPritStream\nPrintWriter\n\n\nStreamTokenizer\nStreamTokenizer（接受 Reader 的构造器）\n\n\nPushbackInpuStream\nPushbackReader\n\n\n\n¶自我独立的类：RandomAccessFile\nRandomAccessFile 适用于由大小已知的文件操作，可以使用seek()将记录从一处转移到另一处，然后读取或者修改记录。此类与 InputStream 和 OutputStream 没有任何关联，大部分的方法都是本地的，这么做是因为此类拥有和别的 I/O 类型本质不同的行为（可以在一个文件内向前和向后移动）。在任何情况下，它都是自我独立的，直接从 Object 派生而来。\n从本质上来说，RandomAccessFile 的工作方式类似于把 DataInputStream 和 DataOutputStream 组合起来使用，还添加了一些方法\n12public RandomAccessFile(File file,String mode)throws FileNotFoundException;public RandomAccessFile(String name,String mode)throws FileNotFoundException;\n🎶mode：和 C 一样，打开文件的方式,(r,rw,rws,rwd)\n123456789101112131415// 同OutputStream流相同public void write(int b)throws IOException;public void write(byte[] b)throws IOException;public void write(byte[] b)throws IOException;// 同 DataOutputStreampublic final void writeInt(int v)throws IOException;public final void writeLong(long v)throws IOException;public long getFilePointer()throws IOException;//获取当前指针位置public void seek(long pos)throws IOException;//跳转文件指针到指定字节位置public int read()throws IOException;public final char readChar()throws IOException;//-----------------------------------------同DataInputStream流相同\n¶I/O 流的典型使用方式\n尽管可以通过不同的方式组合 I/O 流类，但日常开发中也就只用到其中的几种组合，下面的例子可以作为典型的 I/O 用法的基本参考。在这些例子中，异常处理都被简化为将异常传递给控制台，但在真正的项目中，不应该这么做，并且还需要考虑更加复杂的错误处理方式\n¶使用缓冲方式读取文件\n如果想要打开一个文件，并读取文件汇总的内容，可以使用 String 或 FIle 对象作为文件名的 FileInputReader，为了读取速度，最好再加上缓冲，也就是将所产生的引用传给 BufferedReader 构造器就可以。由于 BufferedReader 也提供了 readLine() 方法，所以这是我们的最终对象和进行读取的接口，当 readLine() 返回 null 时，此时就将文件所有内容读取完毕\n12345678public static void readFile(String filePath) throws IOException &#123;\tBufferedReader reader = new BufferedReader(new FileReader(filePath));\tString received = null;\twhile ((received = reader.readLine()) != null) &#123;\t\tSystem.out.println(received);\t&#125;\treader.close();&#125;\n¶读取内存中的数据\nStringReader 是 Reader 的一个装饰类，用法是读取一个 String 字符串，类似的还存在 StringWriter 类\n❓ 为什么有这两个类？\n可以方便进行 I/O 流的测试，目前所有的流创建起来非常复杂（来自于文件或者网络），使用 StringReader 或 StringWriter 就能够通过非常简单的方式创建一个 Reader 或 Writer，并且这个流读取/写入的内容就是构造器中传入的字符串。并且通过此类读取/写入的字符串最终都是保存在内存中的，并没有直接传输到硬盘上。\n12345678public static void readMemory(String filePath) throws IOException &#123;\tStringReader stringReader = new StringReader(new BufferedReader(new FileReader(filePath)).readLine());\tint recv;   //每次从 StringReader 中读取一个字符\twhile ((recv = stringReader.read())!=-1)&#123;\t\tSystem.out.println((char) recv);\t&#125;&#125;\n¶格式化的从内存读取数据\n读取格式化的数据，使用 DataInputStream ，它是一个面向字节的 I/O 类，并不是面向字符的，可以使用 InputStream 读取任何数据\n123456789101112public static void formatMemoryInput(String path) &#123;\ttry &#123;\t\tDataInputStream dataInputStream =\t\t\t\tnew DataInputStream(new ByteArrayInputStream(new BufferedReader(new FileReader(path)).readLine().\t\t\t\t\t\tgetBytes(StandardCharsets.UTF_8)));\t\twhile (dataInputStream.available()!=0)) &#123;\t\t\tSystem.out.println((char) dataInputStream.readByte());\t\t&#125;\t&#125; catch (IOException e) &#123;\t\te.printStackTrace();\t&#125;&#125;\n🎶 可以使用 available() 方法查看还有多少可供读取的字符，读取的媒介类型不同时，此方法的工作方式是不同的。此方法想要实现的功能是：在没有阻塞的情况下所能读取的字节数。对于文件，这意味着整个文件，对于不同类型的流，可能就不是这样的，所以这个方法需要谨慎使用。\n也可以通过捕获异常的方式来监测输入的末尾，但是使用异常进行流控制，被认为是对异常特性的错误使用\n¶基本的文件输出\nFileWriter 对象可以向文件写入数据，首先创建一个与指定文件连接的 FileWriter，实际上，通常会用 BufferedWriter 将其包装起来用以缓冲输出，「 缓冲往往能显著地增加 I/O 操作的性能 」，在本例中，为了提供格式化机制，它被装饰成 PrintWriter\n123456789101112public static void basicFileOut(String path, String outpath) throws IOException &#123;   BufferedReader bufferedReader = new BufferedReader(new FileReader(path));   PrintWriter printWriter = new PrintWriter(new BufferedWriter(new FileWriter(outpath)));   int lineCount = 1;   String recv;   while ((recv = bufferedReader.readLine()) != null) &#123;      printWriter.println(lineCount + &quot;:&quot; + recv);      lineCount++;   &#125;   bufferedReader.close();   printWriter.close();&#125;\n如果不为所有的输出文件调用 close()，就会发现缓冲区内容不会被刷新清空，最终输出文件中的内容就不会完整。Java SE5 在 PrintWriter 中添加了一个辅助构造器，使得你不必在每次希望创建文本文件并向其中写入时，都去执行所有的装饰工作。\n12345678910111213public static void basicFileOut(String path, String outpath) throws IOException &#123;  BufferedReader bufferedReader = new BufferedReader(new FileReader(path));  // 新的辅助构造器，只需要传入文件输出路径即可  PrintWriter printWriter = new PrintWriter(outpath);  int lineCount = 1;  String received;  while ((received = bufferedReader.readLine()) != null) &#123;    printWriter.println(lineCount + &quot;:&quot; + received);    lineCount++;  &#125;  bufferedReader.close();  printWriter.close();&#125;\n¶存储和恢复数据\nPrintWriter 可以对数据进行格式化，但是为了输出可供另一个流恢复的数据，需要用 DataOutputStream 写入数据，并用 DataInputStream 恢复数据。这些流可以是任何形式，但在下面的示例中使用的是一个文件，并且对于读和写都进行了缓冲处理。\n1234567891011121314public static void storingAndRecoveringData(String inputPath,String outputPath) throws IOException &#123;   DataOutputStream dataOutputStream =         new DataOutputStream(new BufferedOutputStream(new FileOutputStream(outputPath)));   dataOutputStream.writeDouble(3.1415926);   dataOutputStream.writeUTF(&quot;That was pi&quot;);   dataOutputStream.writeDouble(1.41413);   dataOutputStream.writeUTF(&quot;square root of 2&quot;);   dataOutputStream.close();   DataInputStream dataInputStream = new DataInputStream(new BufferedInputStream(new FileInputStream(inputPath)));   System.out.println(dataInputStream.readDouble());   System.out.println(dataInputStream.readUTF());   System.out.println(dataInputStream.readDouble());   System.out.println(dataInputStream.readUTF());&#125;\n如果我们使用 DataOutputStream 写入数据，Java 保证可以使用 DataInputStream 准确地读取数据。无论读和写数据的平台多么的不同，只要两个平台上都有 Java，这种问题就不会再发生。\n¶标准的异常处理代码\n123456789101112131415161718public static void main(String[] args) &#123;  String path = &quot;/Users/hmc/Desktop/test.txt&quot;;  FileOutputStream fileOutputStream = null;  try &#123;    fileOutputStream = new FileOutputStream(path);    fileOutputStream.write(&quot;hello java&quot;.getBytes());  &#125; catch (IOException e) &#123;    e.printStackTrace();  &#125; finally &#123;    if (fileOutputStream != null) &#123;      try &#123;        fileOutputStream.close();      &#125; catch (IOException e) &#123;        e.printStackTrace();      &#125;    &#125;  &#125;&#125;\n12345678910public void fileOutputStreamLearning() &#123;    \t//jdk8 新特性\t\ttry (FileOutputStream fos = new FileOutputStream(&quot;D:\\\\JavaProject\\\\java-code\\\\.gitignore1&quot;, true)) &#123;\t\t\tfos.write(22);// 写入一个字符\t\t\tfos.write(&quot;这就是我要写入的内容&quot;.getBytes());\t\t&#125; catch (IOException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;\n¶标准 I/O\n标准 I/O 这个术语参考的是 Unix 中 「 程序所使用的单一信息流 」这个概念。程序是所有输入都可以来自于标准输入，它的所有输出也都可以发送到标准输出，以及所有的错误信息都可以发送到标准错误。\n✨ 标准 I/O 的意义在于：可以很容易地把程序串联起来，一个程序的标准输出可以称为另一程序的标准输入\n¶从标准输入中读取\n按照标准 I/O，Java 提供了 System.in、System.out 和 System.err，其中System.out已经事先被包装成了 PrintStream 对象，System.err 同样也是 PrintStream，但 System.in 却是一个没有被包装过的未经加工的 InputStream。这意味着尽管我们可以立即使用 System.out 和 System.err，但是在读取 System.in 之前必须对其进行包装。\n12345BufferedReader in = new BufferedReader(new InputStreamReader(System.in));String s;while ((s = in.readLine()) != null &amp;&amp; s.length() != 0) &#123;   System.out.println(s);&#125;\n¶将 System.out 转换成 PrintWriter\nSystem.out 是一个 PrintStream ，而 PrintWriter 是一个 OutputStream，PrintWriter 有一个可以接受 OutputStream 作为参数的构造器\n123// true 表示 auto flush，以便开启自动清空功能，否则，你可能看不到输出PrintWriter out = new PrintWriter(System.out, true);out.println(&quot;hello print writer&quot;);\n¶标准 I/O 重定向\nJava 的 System 类提供了一些简单的静态方法调用，以允许程序对标准输入、输出和错误 I/O 流进行重定向\n123setIn(InputStream);setOut(PrintStream);setErr(PrintStream);\n🎶 重定向操作的是字节流，而不是字符流，因此我们使用的是 InputStream 和 OutputStream 而不是 Reader 和 Writer\n¶压缩\nJava IO 类库中的类支持读写压缩格式的数据流，因此可以使用这些流对其他的 I/O 类进行封装，以提供压缩功能。\n✨ 这些类不是从 Reader 和 Writer 类派生而来的，而是属于 InputStream 和 OutputStream 继承层次结构的一部分。\n\n\n\n压缩类\n功能\n\n\n\n\nCheckedInputStream\nGetCheckSum() 为任何 InputStream 产生校验和\n\n\nCheckOutputStream\nGetCheckSum() 为任何 OutputStream 产生校验和\n\n\nDeflateOutputStream\n压缩类的基类\n\n\nZipOutputStream\n一个 DeflateOutputStream，用于将数据压缩成 ZIP 文件格式\n\n\nGZIPOutputStream\n一个 DeflateOutputStream，用于将数据压缩成 GZIP 文件格式\n\n\nInflaterInputStream\n解压缩类的基类\n\n\nZipInputStream\n一个 InflaterInputStream，用于解压缩 Zip 文件格式的数据\n\n\nGZIPInputStream\n一个 InflaterInputStream，用于解压缩 GZip 文件格式的数据\n\n\n\n¶文件字节流\n文件字节流用来向文件进行相关的读取与写出操作，具体有两个类：FileInputStream 以及 FileOutputStream\n¶FileInputStream\n123public FileInputStream(File file)throws FileNotFoundException;public FileInputStream(FileDescriptor fdObj);public FileInputStream(String name)throws FileNotFoundException;\n123456//每次读取一个字节,并将字节的ASCII码值返回,如果读取到文件末尾,返回-1public int read() throws IOException;//返回值是实际读取的长度，如果没有数据读入，返回-1public int read(byte[] b)throws IOException;//返回读取的总长度，如果没有数据读入，返回-1public int read(byte[] b,int off,int len)throws IOException;\n123456FileInputStream fileInputStream = new FileInputStream(path);int bs = 0;while ((bs = fileInputStream.read()) != -1) &#123;  System.out.print((char) bs);//使用print不会手动给程序增加换行&#125;fileInputStream.close();\n12345678FileInputStream fileInputStream1 = new FileInputStream(path);byte[] by = new byte[1024];int len = 0;while ((len = fileInputStream1.read(by)) != -1) &#123;  String str = new String(by, 0, len);  System.out.println(str);&#125;fileInputStream1.close();\n¶FileOutputStream\n创建对象就会强制生成新文件，清空源文件内容\n12345public FileOutputStream(File file)throws FileNotFoundException;//如果append为true,则进行文件的追加写入public FileOutputStream(File file,boolean append)throws FileNotFoundException;public FileOutputStream(String name)throws FileNotFoundException;public FileOutputStream(String name,boolean append)throws FileNotFoundException;\n1234public void write(int b)throws IOException;//写入b对应ASCII码表中的字符public void write(byte[] b)throws IOException;//写一个字节数组public void write(byte[] b,int off,int len)throws IOException;//写一个数组的一部分public void close()throws IOException;\n12345678public static void main(String[] args) throws IOException &#123;\tFile file = new File(&quot;E:\\\\lifeInformation\\\\test.txt&quot;);    //源代码throws FileNotFoundException异常需要自己处理此异常    FileOutputStream fileOutputStream = new FileOutputStream(file);\t\t//会抛出IOException异常，IOException是FileNotFoundException异常的父类    fileOutputStream.write(&quot;hello world io&quot;.getBytes());    fileOutputStream.close();  &#125;\n❓为什么一定要关闭文件？\n让流对象变成垃圾，这样就可以被垃圾回收器回收并通知系统去释放该文件相关的资源\n¶字节缓冲区流\n通过FileInputStream中字节数组读写数据的确比读取一个字节的方式快；然而如果拥有一个缓存区将比单纯的字节数组读写数据更快，Java 提供了带缓冲区的字节类，这种类被称为:缓冲区类，专门对 FileInputStream 以及 FileOutputStream 包装主要有如下两类:\n缓冲区写数据流类（BuffededOutputStream）和缓冲区读数据流类（BufferedInputStream）\n¶BufferedOutputStream\n使用缓冲区，更加快速高效的写数据，由于 BufferedOutputStream 流是作用在 OutputStream 流之上的，所以BufferedOutputStream构造方法的参数就应该传入OuputStream对象\n1234//使用默认的缓冲区大小，通常使用public BufferedOutputStream(OutputStream out);//指定缓冲区的大小，一般用不上public BufferedOutputStream(OutputStream out,int size);\n123456// 高效缓冲区类,每次写一个字节public void write(int b)throws IOException;// 继承自FilterOutputStream方法,高效缓冲区类,每次写一个缓冲区数组public void write(byte[] b)throws IOException;// 将缓冲区字节数组某一区间上的内容写入流中public void write(byte[] b,int off,int len)throws IOException;\n12345BufferedOutputStream bufferedOutputStream =    new BufferedOutputStream(        new FileOutputStream((&quot;E:\\\\research_plan\\\\2020..17~\\\\test.txt&quot;)));bufferedOutputStream.write(&quot;hello java bufferedOutputStream&quot;.getBytes());bufferedOutputStream.close();\n¶BufferedInputputStream\n使用缓冲区对流中的数据进行高效的读取，同缓冲区写数据流相同，基于字节输入流，所以构造参数需要字节输入流\n12BufferedInputStream(InputStream in);BufferedInputStream(InputStream in, int size);\n123456public int read()throws IOException;public int read(byte[] b,int off,int len)throws IOException;public void read(byte[] b)throws IOException;//继承自FilterInputStream方法public void mark(int readlimit);//设置markpublic void reset()throws IOException;//重置读取指针到mark处public boolean markSupported();//判断当前类是否支持mark()以及reset()方法\n12345678910111213141516public static void main(String[] args) throws IOException &#123;  BufferedInputStream bufferedInputStream =      new BufferedInputStream(new FileInputStream(&quot;E:\\\\research_plan\\\\2020..17~\\\\test.txt&quot;));  bufferedInputStream.mark(0);  byte[] by = new byte[1024];  int len = 0;  while ((len = bufferedInputStream.read()) != -1) &#123;    System.out.print((char) len);  &#125;  System.out.println(&quot;-------------------------&quot;);  bufferedInputStream.reset();//重置指针，从文件头部再一次读取文件内容  while ((len = bufferedInputStream.read(by)) != -1) &#123;    System.out.println(new String(by, 0, len));  &#125;  bufferedInputStream.close();&#125;\n🎶 Java 文件读取虽有多种方式，但是多种读取方式共享同个文件读取指针，意味着：前一种读取方式读完整个文件时，后一种方式将读取不到任何内容（此时文件指针已经移动到了文件尾部）。存在重复读取一个文件时，就需要重置文件指针，保证后一种读取方式能够正确读取文件内容。\n🤔为什么缓冲区数据流的构造参数需要我们手动传入输入输出流，而不是和输入输出流一样，直接传入一个文件路径？\n这是一种装饰器模式，如果使用文件路径，缓冲区流就使得 Java IO 系统更加复杂\n¶转换流\n将字节流转换为字符流,写入数据的编码以及读出数据的解码过程均是在转换流类中进行，其他的过程并不需要涉及这个步骤\n¶OutputStreamWriter\n此类继承自java.io.Writer一种输出转换字符流转换类，一个字符 = 两个字节。\n\n\n字符流数据不直接进入硬盘而是写入缓冲区，所以每次写完之后需要flush()或者close()。\n\n\n与字节流不同，转换流每次写入的是什么最终在文件中就会保存什么，而不会出现字节流的情况:不论写什么最终都会转换为 char 类型的字符.比如写入97,最终在文件中保存的就是a.\n\n\n12345//采用默认编码把字节流的数据转换为字符流public OutputStreamWriter(OutputStream out);//根据指定编码把字节流转换为字符流public OutputStreamWriter(OutputStream out,String charsetName)    throws UnsupportedEncodingException;\n123456789//----------------------------------------------------继承的public void write(String str)throws IOException;public void write(char[] cbuf)throws IOException;//----------------------------------------------------重写的public void write(String str,int off,int len)throws IOException;public void write(char[] cbuf,int off,int len)throws IOException;public void write(int c)throws IOException;//写一个字符public void flush()throws IOException;//刷新缓冲，将数据写入硬盘public void close()throws IOException;//先刷新缓冲区，然后关闭文件\n每次使用一个字节输出流的类以及字符集初始化字符流对象即可实现\n1234OutputStreamWriter outputStreamWriter =    new OutputStreamWriter(new FileOutputStream(&quot;testx.txt&quot;), &quot;GBK&quot;);outputStreamWriter.write(&quot;中国&quot;);outputStreamWriter.close();\n🆚flush()与 close()的区别？\n\n**close()**关闭流对象，但是先刷新一次缓冲区，关闭之后，流对象不可以继续使用\n**flush()**仅仅刷新缓冲区，刷新之后，流对象还可以继续使用\n\n¶FileWriter\n继承自java.io.OutputStreamWriter，由于常见的操作都是使用本地默认编码，所以不用指定编码\n1234public FileWriter(String fileName,boolean append)throws IOException;public FileWriter(String fileName)throws IOException;//直接指明写入文件的路径字符串public FileWriter(File file,boolean append)throws IOException;public FileWriter(File file)throws IOException;\n¶InputStreamReader\n是字节流变换为字符流的桥梁，并不支持mark()以及reset()\n12InputStreamReader(InputStream in);InputStreamReader(InputStream in, String charsetName);\n1234//字符流每次读入一个字符public int read()throws IOException;//字符流每次读入一个数组public int read(char[] cbuf,int offset,int length)throws IOException;\n每次读入一个字符的输入流\n1234567891011OutputStreamWriter outputStreamWriter =    new OutputStreamWriter(new FileOutputStream(&quot;testx.txt&quot;), &quot;GBK&quot;);outputStreamWriter.write(&quot;中国&quot;);outputStreamWriter.close();InputStreamReader inputStreamReader =    new InputStreamReader(new FileInputStream(&quot;testx.txt&quot;), &quot;utf-8&quot;);    int ch = 0;    while ((ch = inputStreamReader.read()) != -1) &#123;      System.out.print((char) ch);    &#125;inputStreamReader.close();\n每次读入一个数组的输入流\n123456789101112OutputStreamWriter outputStreamWriter =    new OutputStreamWriter(new FileOutputStream(&quot;testx.txt&quot;), &quot;GBK&quot;);outputStreamWriter.write(&quot;中国&quot;);outputStreamWriter.close();InputStreamReader inputStreamReader =    new InputStreamReader(new FileInputStream(&quot;testx.txt&quot;), &quot;utf-8&quot;);char[] cbuf = new char[1024];int len = cbuf.length;int offset = 0;while ((len = inputStreamReader.read(cbuf, offset, len)) != -1) &#123;  System.out.print(cbuf);&#125;\n¶FileReader\nFileOutputStream 流对应的字符流\n12public FileReader(File file)throws FileNotFoundException;public FileReader(String fileName)throws FileNotFoundException;\n¶字符缓冲区流\n字符流为了高效读写，同样提供了对应了字符缓冲流\n\nBufferedReader\nBufferedWriter\n\n¶BufferedWriter\n1234//使用Writer的具体子类FileWriter初始化字符缓冲输出流，缓冲区使用默认大小public BufferedWriter(Writer out);//指定缓冲区大小public BufferedWriter(Writer out,int sz);\n1234567public void write(String s,int off,int len)throws IOException;//写入特定长度的字符串public void write(char[] cbuf,int off,int len)throws IOException;public void write(int c)throws IOException;public void flush()throws IOException;public void close()throws IOException;//在当前行插入一个换行符，能够根据系统不同输入不同的字符public void newLine()throws IOException;\n¶BufferedReader\n123//使用Reader的具体子类FileReader初始化字符缓冲流，缓冲区大小使用默认长度public BufferedReader(Reader in);public BufferedReader(Reader in,aint sz);\n1234public int read()throws IOException;//每次读入一个字符public int read(char[] cbuf,int off,int len)throws IOException;//每次读入一个字符数组//每次读一行,包含该行内容的字符串，不包含任何终止符.如果到达文件结尾返回nullpublic String readLine()throws IOException;\n¶LineNumberReader\n继承自java.io.BufferedReader,具有字符缓冲区流两个所不具有的特定方法打印行号\n12LineNumberReader(Reader in);LineNumberReader(Reader in, int sz);\n12public int getLineNumber();//获取当前读取文件的行号public void setLineNumber(int lineNumber);//设置行号的其实记录值\n1234567891011BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(&quot;test.txt&quot;, true));bufferedWriter.write(&quot;这里似乎有点意思&quot;);bufferedWriter.newLine();bufferedWriter.close();BufferedReader bufferedReader = new BufferedReader(new FileReader(&quot;test.txt&quot;));char[] cbuf = new char[1024];int len = cbuf.length;while ((len = bufferedReader.read(cbuf, 0, len)) != -1) &#123;\tSystem.out.print(cbuf);&#125;bufferedReader.close();\n¶数据输入输出流\n继承自java.io.FilterInputStream,可以对基本数据类型操作的 IO 类\n¶DataInputStream\n读取DateOutputSream写入文件中的内容\n1DataInputStream(InputStream in);\n1234public final short readShort()throws IOException;//读取一个short类型的数据public final long readLong()throws IOException;//读取一个long类型的数据public final char readChar()throws IOException;//读取一个char类型的数据public final xxx readXxx()throws IOException;//读取一个基本数据类型为xxx的数据\n🎶由于写入的数据并不是正规的字节或者字符数据，因此使用记事本打开是一堆乱码，只能通过相应的DataInputStream进行读取，并且写入的是什么类型读取时也应该调用相应类型的 API\n¶DatsOutputStream\n继承自java.io.FilterOutputStream，用于传递基本数据类型以及 String 对象供 DataInputStream 读取\n1public DataOutputStream(OutputStream out);\n1234public final void writeByte(int v)throws IOException;public final void writeInt(int v)throws IOException;//向文件中写一个基本数据类型为xxx的数据public final void writeXxx(int v)throws IOException;\n12345678910DataOutputStream dataOutputStream =\tnew DataOutputStream(new FileOutputStream(&quot;text.txt&quot;, true));dataOutputStream.writeInt(3);dataOutputStream.writeShort();dataOutputStream.writeChar(&#x27;a&#x27;);dataOutputStream.close();DataInputStream dataInputStream = new DataInputStream(new FileInputStream(&quot;text.txt&quot;));System.out.println(dataInputStream.readInt());System.out.println(dataInputStream.readShort());System.out.println(dataInputStream.readChar());dataInputStream.close();\n¶内存操作流\n用于处理临时存储信息，程序结束，数据就从内存中消失\n\n\n\n字节数组\n字符数组\n字符串\n\n\n\n\nByteArrayInputStream\nCharArrayReader\nStringReader\n\n\nByteArrayOutputStream\nCharArrayWriter\nStringWriter\n\n\n\n¶ByteArrayOutputStream\n\n继承自java.io.OutputStream,属于字节流的范畴，写入的数据并不会保存到本地磁盘中，而是存在于内存缓冲区中.\n此流并不需要显示调用 close()去关闭，并且手动调用 close()后仍然可以向其中写入数据\n由于数据仅仅存在于内存缓冲区中，所以如果需要读取当前数据，需要将缓冲区中的数据保存到一个byte[]或者String中，而后使用ByteArrayInputStream流对这些数据进行读取\n\n12public ByteArrayOutputStream();//创建一个内存操作流，内存缓冲区容量大小随着输入数据自适应增长public ByteArrayOutputStream(int size);//创建一个字节数组输出流，并且字节数组输出流的大小限定为size\n12345678public byte[] toByteArray();//将当前字节数组输出流中的内容返回，提供给输入流进行读取public String toString();\t//将当前字节数组输出流中的内容转换成String类型返回//将输出流中的内容按照特定的编码集返回public String toString(String charsetName)throws UnsupportedEncodingException;public void writeTo(OutputStream out)throws IOException;//将当前字节输出流中的内容写入到OutputStream流中public void write(int b);\t//写入一个字符public void write(byte[] b,int off,int len);//一次性写入一个数组public int size();//获取当前字节数组的长度，用于读取当前输出流内部数据时使用\n¶ByteArrayInputStream\n继承自java.io.InputStream,属于字节流的范畴\n12public ByteArrayInputStream(byte[] buf);\t//使用从输出流中传递出来的字节数组，查看当前内存缓冲区中的数据public ByteArrayInputStream(byte[] buf,int offset,int length);\n123//读取方法和字节流的read方法相同public int read(byte[] b,int off,int len);public int read();\n¶打印流\n✨打印流是一种写数据的流，最终系统会进行读取，没有提供给用户对应的读数据接口；可以向此流中写入任意类型的数据，如果启动了自动刷新，能够自动刷新写入的内容；此流和其他的输出流相同是可以直接操作文本文件的\n🤔 共有哪些流对象是可以直接操作文本文件的尼？\n目前共有如下几种流可以直接作用于文件中：FileInputStream、FileOutputStream、FileReader、FileWriter、PrintStream（字节打印流）、PrintWriter（字符打印流）\n打印字符流,继承自java.io.Writer可以直接将内容写入到一个文件中,但是其也拥有自己的特有方法:能够自动刷新,每写一次就自动刷新文件\n12345678public PrintWriter(File file);PrintWriter(String fileName);//---------------------------------------使用字节流PrintWriter(OutputStream out);PrintWriter(OutputStream out, boolean autoFlush);//启动自动刷新//---------------------------------------使用字符流PrintWriter(Writer out);PrintWriter(Writer out, boolean autoFlush)\n12345678public void print(boolean b);//print重载了所有基本数据类型,但是不支持自动刷新//重载了常用的基本数据类型,开启自动刷新时,会将内容自动自动保存至文件,每次会在行末尾增加一个换行符public void println(boolean x);public void write(char[] buf,int off,int len);//继承自父类的传统写方法public void close();//如果未启动自动刷新,则依靠flush()或者close()将内容写入文件public void flush();public PrintWriter format(String format,Object... args);public PrintWriter printf(String format,Object... args);\n🎶如果启动了自动刷新,则 println, printf, orformat methods 将会自动刷新.\n12345println();//等价于/**********************/bw.write();bw.newLine();bw.flush()\n123PrintWriter printWriter = new PrintWriter(new FileWriter(&quot;text.txt&quot;), true);printWriter.println(&quot;中国&quot;);printWriter.close();//养成关闭文件的好习惯\n¶标准输入输出流\nSystem 类中的两个成员变量:\n123public static final InputStream in;//标准输入流public static final PrintStream out;//标准输出流public static final PrintStream err;\n¶键盘录入数据\n✨ 一个程序要想获取外部提供的输入数据，共有以下三种：\n\n通过 main 方法的 args 接受参数\n使用 JDK5 以后的新特性 Scanner\n使用字符缓冲流包装标准输入流(System.in)实现\n\n1234567891011System.out.println(&quot;使用Scanner进行数据的读取&quot;);Scanner scanner = new Scanner(System.in);int x = scanner.nextInt();System.out.println(x);System.out.println(&quot;使用bufferedreader进行字符串的读取&quot;);BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));System.out.println(bufferedReader.readLine());System.out.println(&quot;使用bufferedreader进行int的读取&quot;);String line = bufferedReader.readLine();int i = Integer.parseInt(line);System.out.println(i);\n使用字符流将数据写入到控制台\n12345BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(System.out));bufferedWriter.write(&quot;使用bufferedreader进行字符串的读取\\n&quot;);bufferedWriter.flush();BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));System.out.println(bufferedReader.readLine());\n¶合并流\n以前的文件流传输过程:\n1234//a.txt---&gt; b.txt//c.txt---&gt; b.txt//需求//a.txt+c.txt --&gt; b.txt\n¶SequenceInputStream\n继承自java.io.InputStream,主要将多个文件合并处理\n123public SequenceInputStream(InputStream s1,InputStream s2);public SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e);//Enumeration 是vector中一个方法的返回值类型\n其中Enumeration是一个接口，只有两种方法\n12boolean hasMoreElements();//等同于iterator中的hasNext()E nextElement();//等同于iterator中的next()方法\n12for (Enumeration&lt;E&gt; e = v.elements(); e.hasMoreElements();)    System.out.println(e.nextElement());\n均继承自InputStream没有自己的特有方法\n123void close();int\tread();int\tread(byte[] b, int off, int len);\n¶序列化流\n\n序列化流：\n\n将对象按照流一样的方式存入文件中或在网络中传输(对象–&gt;流)\nObjectOutputStream\n\n\n反序列化流:\n\n将文本文件中的流对象数据或者网络中的流对象数据还原成对象(流数据–&gt;对象)\nObjectInputStream\n\n\n\n¶ObjectIntputStream\n12public ObjectInputStream(InputStream in)throws IOException;protected ObjectInputStream()throws IOException,SecurityException;\nPerson 类实现了序列化接口，那么它本身也会拥有一个标记值，如果相应的类做出了更改，这个 ID 就会更改，如果更改之后没有进行序列化操作，继续进行反序列的操作将会出现异常。\n12//从当前输入流自动读取一个对象public final Object readObject()throws IOException,ClassNotFoundException;\n¶ObjdectOutputStream\n12protected ObjectOutputStream()throws IOException,SecurityException;public ObjectOutputStream(OutputStream out)throws IOException;\njava.io.NotSerializableException：未序列化异常，需要实现Serializable接口，以启用序列化功能。Serializable 接口没有任何方法，这种没有方法的接口为标记接口\n12//序列化一个对象public final void writeObject(Object obj)throws IOException;\n¶ID\n❓ 在实际开发中，可能还需要使用以前写过的数据，不能重新写入，如何处理？\n\n将当前类的 ID 固定，由于每次会读取当前类中固定的 ID 值，所以对类的任何修改，均不会造成之后的访问失败\n\n1static final long serialVersionUID = 1L;//推荐使用IDE帮助生成随机的ID\n¶序列化选择\n一个类中可能有多个成员变量，有些可能并不需要进行序列化，此使就需要使用transient关键字，声明不需要序列化的成员变量\n1234567891011class Person implements Serializable&#123;  public String name;  private transient int age;//序列化时并不会序列化此字段，反序列化时读取到的值就是默认值      @Override  public String toString() &#123;    return &quot;Person&#123;&quot; +            &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +            &quot;, age=&quot; + age +            &#x27;&#125;&#x27;;  &#125;&#125;\n¶Properties\n属性集合类，是一个可以和 I/O 流结合使用的集合类，properties可保存在流中或从流中加载，属性列表中每个键及其对应的值都是一个字符串\n12public Properties();public Properties(Properties defaults);\n123456789public V put(String key,String value);//------------------------------------------------继承自hashtablepublic Object setProperty(String key,String value);//添加元素public String getProperty(String key);//获取元素public Set&lt;String&gt; stringPropertyNames();//获取所有的键的集合//把文件中的数据读取到集合中，文件中的数据必须是键值对形式public void load(Reader reader)throws IOException;//把集合中的数据存储到文件，public void store(OutputStream out,String comments)throws IOException;\n¶附： 编码表\n\n\n\n码表\n用途\n\n\n\n\nISO-8859-1\n拉丁码表,8 位表示一个数据\n\n\nGB23\n中国的中文编码表\n\n\nGBK23\n中国的中文编码表\n\n\nGBK\n中国的中文编码表升级,融合了更多的中文文字符号,java 默认中文码表\n\n\nGB18030\nGBK 的取代版本\n\n\nUnicode\n国际标准码,融合了多种文字,java 默认码表\n\n\nUTF-8\n最多用三个字节来表示一个字符,具有较好的兼容其他码表\n\n\n\nJava I/O\nJava Properties 类\n深入学习 JAVA -IO 流详解\n使用 StringWriter 和 StringReader 的好处\n","dateCreated":"2022-01-24T14:15:08+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2022-01-24T14:15:08+00:00","description":"IO 是一门语言中的难点，对于 Java 而言，有着丰富的 IO 体系，所以本系列将通过相关资料梳理出 Java IO 的脉络","headline":"Java IO(二) IO 系统基础","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/java-io-%E4%BA%8C-io-%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/java-io-%E4%BA%8C-io-%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/","keywords":"Java IO"}</script><meta name="description" content="IO 是一门语言中的难点，对于 Java 而言，有着丰富的 IO 体系，所以本系列将通过相关资料梳理出 Java IO 的脉络"><meta property="og:type" content="blog"><meta property="og:title" content="Java IO(二) IO 系统基础"><meta property="og:url" content="https://pineapple-man.github.io/java-io-%E4%BA%8C-io-%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="IO 是一门语言中的难点，对于 Java 而言，有着丰富的 IO 体系，所以本系列将通过相关资料梳理出 Java IO 的脉络"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/IOClass.svg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/java-inputstream.png"><meta property="article:published_time" content="2022-01-24T14:15:08.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.011Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="Java IO"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/IOClass.svg"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">Java IO(二) IO 系统基础</h1><div class="post-meta"><time datetime="2022-01-24T14:15:08+00:00">1月 24, 2022 </time><span>发布在 </span><a class="category-link" href="/categories/Java/">Java</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 10.5k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 109 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#File"><span class="toc-text">File</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%8A%9F%E8%83%BD"><span class="toc-text">创建功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD"><span class="toc-text">删除功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%91%BD%E5%90%8D%E5%8A%9F%E8%83%BD"><span class="toc-text">重命名功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD"><span class="toc-text">判断功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD"><span class="toc-text">基本获取功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD"><span class="toc-text">高级获取功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-text">输入和输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InputStream-%E7%B1%BB%E5%9E%8B"><span class="toc-text">InputStream 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OutputStream%E7%B1%BB%E5%9E%8B"><span class="toc-text">OutputStream类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%92%8C%E6%9C%89%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-text">添加属性和有用的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-FilterInputStream-%E4%BB%8E-InputStream-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-text">通过 FilterInputStream 从 InputStream 读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-FilterOutputStream-%E4%BB%8E-OutputStream-%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">通过 FilterOutputStream 从 OutputStream 写入数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reader-%E5%92%8C-Writer"><span class="toc-text">Reader 和 Writer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9D%A5%E6%BA%90%E4%B8%8E%E5%8E%BB%E5%A4%84"><span class="toc-text">数据的来源与去处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E6%B5%81%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-text">更改流的行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E7%8B%AC%E7%AB%8B%E7%9A%84%E7%B1%BB%EF%BC%9ARandomAccessFile"><span class="toc-text">自我独立的类：RandomAccessFile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-%E6%B5%81%E7%9A%84%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">I&#x2F;O 流的典型使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BC%93%E5%86%B2%E6%96%B9%E5%BC%8F%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-text">使用缓冲方式读取文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">读取内存中的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%9A%84%E4%BB%8E%E5%86%85%E5%AD%98%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-text">格式化的从内存读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA"><span class="toc-text">基本的文件输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%92%8C%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="toc-text">存储和恢复数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81"><span class="toc-text">标准的异常处理代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86-I-O"><span class="toc-text">标准 I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E4%B8%AD%E8%AF%BB%E5%8F%96"><span class="toc-text">从标准输入中读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86-System-out-%E8%BD%AC%E6%8D%A2%E6%88%90-PrintWriter"><span class="toc-text">将 System.out 转换成 PrintWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86-I-O-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">标准 I&#x2F;O 重定向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9"><span class="toc-text">压缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-text">文件字节流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FileInputStream"><span class="toc-text">FileInputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileOutputStream"><span class="toc-text">FileOutputStream</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E5%8C%BA%E6%B5%81"><span class="toc-text">字节缓冲区流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BufferedOutputStream"><span class="toc-text">BufferedOutputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BufferedInputputStream"><span class="toc-text">BufferedInputputStream</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-text">转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OutputStreamWriter"><span class="toc-text">OutputStreamWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileWriter"><span class="toc-text">FileWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InputStreamReader"><span class="toc-text">InputStreamReader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileReader"><span class="toc-text">FileReader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E5%8C%BA%E6%B5%81"><span class="toc-text">字符缓冲区流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BufferedWriter"><span class="toc-text">BufferedWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BufferedReader"><span class="toc-text">BufferedReader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LineNumberReader"><span class="toc-text">LineNumberReader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">数据输入输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DataInputStream"><span class="toc-text">DataInputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DatsOutputStream"><span class="toc-text">DatsOutputStream</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E6%B5%81"><span class="toc-text">内存操作流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ByteArrayOutputStream"><span class="toc-text">ByteArrayOutputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ByteArrayInputStream"><span class="toc-text">ByteArrayInputStream</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-text">打印流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">标准输入输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">键盘录入数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%B5%81"><span class="toc-text">合并流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SequenceInputStream"><span class="toc-text">SequenceInputStream</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81"><span class="toc-text">序列化流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ObjectIntputStream"><span class="toc-text">ObjectIntputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ObjdectOutputStream"><span class="toc-text">ObjdectOutputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ID"><span class="toc-text">ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E9%80%89%E6%8B%A9"><span class="toc-text">序列化选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Properties"><span class="toc-text">Properties</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%EF%BC%9A-%E7%BC%96%E7%A0%81%E8%A1%A8"><span class="toc-text">附： 编码表</span></a></li></ol><p><span style="color:#00f;font-weight:700">输出流会自动创建文件，输入流读取之前文件必须存在</span></p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/IOClass.svg" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/IOClass.svg" alt=""></a></div><h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><p>自从 Java 1.0 版本以来，Java 的 I/O 库发生了明显改变，在原来面向字节的类中添加了面向字符和基于 Unicode 的类。在 JDK 1.4 中，添加了 NIO 类，添加进来主要是为了改进性能以及功能。因此，在充分理解 Java I/O 系统之前需要学习相当数量的类。</p><h2 id="File"><a class="header-anchor" href="#File">¶</a>File</h2><p>File 类的名字有一定的误导性，实际上此类既能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称。如果它指的是一个文件集，就可以对此集合调用<code>list()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据一个路径得到 File 对象</span></span><br><span class="line">File(String pathname);</span><br><span class="line"><span class="comment">//根据一个目录和一个子文件得到 File 对象</span></span><br><span class="line">File(String parent, String child);</span><br><span class="line"><span class="comment">//根据一个父 File 对象和一个子文件/目录得到 File 对象</span></span><br><span class="line">File(File parent, String child);</span><br></pre></td></tr></table></figure><div class="alert warning no-icon"><p>🎶 <code>toString()</code>被重写为文件的绝对路径</p></div><p>File 的众多成员方法就是常见的文件操作，如：创建文件、创建目录，移动、重命名等</p><h3 id="创建功能"><a class="header-anchor" href="#创建功能">¶</a>创建功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">createNewFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="comment">//创建目录,如果存在这样的目录就不创建,并且返回false,如果父目录不存在,子文件就不会创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdir</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//创建目录,如果父目录不存在,就会创建多级目录 &lt;==&gt; mkdir -p</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdirs</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>🎶创建文件主要要点：</p><ul><li><p>文件名和目录不可以同名</p></li><li><p>明确需要创建的是一个<span style="color:red;font-weight:700">文件</span>还是一个<span style="color:red;font-weight:700">目录</span></p></li><li><p>相对路径，相对的是当前<strong>正在运行的 java 项目文件</strong></p></li></ul><h3 id="删除功能"><a class="header-anchor" href="#删除功能">¶</a>删除功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">()</span>;	<span class="comment">//删除文件 | 目录(当前目录下必须为空时,才能删除) &lt;==&gt; rm</span></span><br></pre></td></tr></table></figure><h3 id="重命名功能"><a class="header-anchor" href="#重命名功能">¶</a>重命名功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">renameTo</span><span class="params">(File dest)</span>;<span class="comment">// &lt;==&gt; mv 命令</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/xxx/Desktop/test&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/xxx/Desktop/test1&quot;</span>);</span><br><span class="line">file.renameTo(file1);<span class="comment">//如果两个文件的父路径不一致,功能将变为重命名+剪切</span></span><br></pre></td></tr></table></figure><h3 id="判断功能"><a class="header-anchor" href="#判断功能">¶</a>判断功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDirectory</span><span class="params">()</span>;	<span class="comment">//目录?</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span>;		<span class="comment">//文件?</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHidden</span><span class="params">()</span>;		<span class="comment">//隐藏?</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>;		<span class="comment">//存在?</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canExecute</span><span class="params">()</span>;	<span class="comment">//可执行?</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canRead</span><span class="params">()</span>;		<span class="comment">//可读?</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canWrite</span><span class="params">()</span>;		<span class="comment">//可写?</span></span><br></pre></td></tr></table></figure><h3 id="基本获取功能"><a class="header-anchor" href="#基本获取功能">¶</a>基本获取功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getAbsolutePath</span><span class="params">()</span>;<span class="comment">//绝对路径</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span>;<span class="comment">//相对路径</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>;<span class="comment">//文件名字</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getParent</span><span class="params">()</span>;<span class="comment">//如果父目录存在,返回父目录的路径,否则返回null</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">length</span><span class="params">()</span>;<span class="comment">//文件大小,单位:字节数(B)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lastModified</span><span class="params">()</span>;<span class="comment">//获取最后一次的修改时间,毫秒数</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/xxx/Desktop/timg.jpg&quot;</span>);</span><br><span class="line">System.out.println(file.getAbsolutePath());</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span> + (file.length()) + <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">System.out.println(file.getParent());</span><br></pre></td></tr></table></figure><h3 id="高级获取功能"><a class="header-anchor" href="#高级获取功能">¶</a>高级获取功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] list();<span class="comment">//获取指定目录下的所有文件或者文件夹的名称数组</span></span><br><span class="line"><span class="keyword">public</span> String[] list(FilenameFilter filter);<span class="comment">//FilenameFilter接口过滤然</span></span><br><span class="line"><span class="keyword">public</span> File[] listFiles();<span class="comment">//返回文件对象数组，只深入一层</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求:获取file目录下所有以.jpg结尾的文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">  <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/xxx/Desktop&quot;</span>);</span><br><span class="line">  File[] files = file.listFiles();</span><br><span class="line">  <span class="keyword">for</span> (File tempFile : files) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tempFile.getName().endsWith(<span class="string">&quot;.jpg&quot;</span>))</span><br><span class="line">        System.out.println(tempFile.getAbsolutePath());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>FilenameFilter</code>接口,充当过滤器，过滤文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/hmc/Desktop&quot;</span>);</span><br><span class="line">	File[] files =</span><br><span class="line">    	file.listFiles(</span><br><span class="line">  	      <span class="keyword">new</span> <span class="title class_">FilenameFilter</span>() &#123;</span><br><span class="line">	          <span class="meta">@Override</span></span><br><span class="line">          	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span> &#123;</span><br><span class="line">        	    <span class="comment">//返回true则将当前File(dir,name)加入到files数组中,否则不进行操作</span></span><br><span class="line">      	      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">File</span>(dir, name).isFile() &amp;&amp; name.endsWith(<span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">    	      &#125;</span><br><span class="line">  	      &#125;);</span><br><span class="line">	<span class="keyword">for</span> (File file1 : files) &#123;</span><br><span class="line">  	System.out.println(file1.getAbsolutePath());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入和输出"><a class="header-anchor" href="#输入和输出">¶</a>输入和输出</h2><p>编程语言的 I/O 类库中常使用「 流 」 这个抽象概念，它代表任何又能力产出数据的数据源对象或者有能力接受数据的数据端对象。流屏蔽了实际的 I/O 设备中处理数据的细节。Java 类库中的 I/O 类分成输入和输出两部分。通过继承，任何自<code>InputStream</code>或<code>Reader</code>派生而来的类都含有 <code>read()</code>基本方法，用于读取单个字节或者字节数组。同样，任何自<code>OuputStream</code>或<code>Writer</code>派生而来的类都含有名为 <code>write()</code>的基本方法，用于写单格字节或者字节数组。</p><p>✨ 但是，通常并不会直接用到这些方法，它们之所以存在是因为别的类可以使用它们，以便提供更有用的接口。因此，日常开发中很少使用单一的类来创建流对象，而是通过堆叠多个流对象来创建所期望的功能「 这是装饰者设计模式 」。实际上，Java 中的流库让人迷惑的主要原因就在于：创建单一的结果流，却需要创建多个对象。</p><h3 id="InputStream-类型"><a class="header-anchor" href="#InputStream-类型">¶</a><code>InputStream</code> 类型</h3><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/java/java-inputstream.png" alt=""></p><p><code>InputStream</code>的作用是用来表示哪些从不同数据源产生输入的类，这些数据源包括：</p><ul><li>字节数组</li><li>String 对象</li><li>文件</li><li>管道</li><li>一个由其他种类多流组成的序列</li><li>其他数据源，如 <code>Internet</code> 连接等</li></ul><p>每一种数据源都有相应的 <code>InputStream</code>子类。另外，FilterInputStream 也属于一种 InputStream ，为装饰器类提供基类「 装饰器可以把属性或有用的接口与输入流连接在一起</p><table><thead><tr><th style="text-align:center">类</th><th style="text-align:center">功能</th><th style="text-align:center">构造器参数</th><th>如何使用</th></tr></thead><tbody><tr><td style="text-align:center"><code>ByteArrayInputStream</code></td><td style="text-align:center">允许将内存的缓冲区当作 InputStream 使用</td><td style="text-align:center">缓冲区，字节将从中取出</td><td>作为一种数据源：将其与 FilterInputStream</td></tr><tr><td style="text-align:center"><code>StringBufferInputStream</code><br>(已弃用)</td><td style="text-align:center">将 String 转换成 InputStream</td><td style="text-align:center">字符串，底层实际使用 StringBuffer</td><td>作为一种数据源：将其与 FilterInputStream</td></tr><tr><td style="text-align:center"><code>FileInputStream</code></td><td style="text-align:center">用于从文件中读取信息</td><td style="text-align:center">字符串，表示文件名、文件或 FileDescriptor 对象</td><td>作为一种数据源：将其与 FilterInputStream</td></tr><tr><td style="text-align:center"><code>PipedInputStream</code></td><td style="text-align:center">产生用于写入 PipedOutputStream 的数据，实现管道话概念</td><td style="text-align:center">PipedOutputStream</td><td>作为一种数据源：将其与 FilterInputStream</td></tr><tr><td style="text-align:center"><code>SequenceInputStream</code></td><td style="text-align:center">将两个或多个 InputStream 转换成单一 InputStream</td><td style="text-align:center">两个 InputStream 对象或一个容纳 InputStream 对象的容器 Enumeration</td><td>作为一种数据源：将其与 FilterInputStream</td></tr><tr><td style="text-align:center"><code>FilterInputStream</code></td><td style="text-align:center">抽象类，作为装饰器的接口，为其他的 InputStream 类提供有用功能</td><td style="text-align:center"></td><td></td></tr></tbody></table><h3 id="OutputStream类型"><a class="header-anchor" href="#OutputStream类型">¶</a><code>OutputStream</code>类型</h3><p>该类别的类决定了输出所要去往的目标：字节数组<code>byte[]</code>（并不是<code>String</code>，当然可以用字节数组自己创建字符串）、文件或管道。另外，FilterOutputStream 为装饰器类提供了一个基类，装饰器类把属性或者有用的接口与输出流连接了起来</p><table><thead><tr><th style="text-align:center">类</th><th style="text-align:center">功能</th><th style="text-align:center">构造器参数</th><th style="text-align:center">如何使用</th></tr></thead><tbody><tr><td style="text-align:center">ByteArrayOutputStream</td><td style="text-align:center">在内存中创建缓冲区，所有送往该流的数据最终都要放置在此缓冲区</td><td style="text-align:center">缓冲区初始化尺寸（可选的）</td><td style="text-align:center">用于指定数据的目的地：将其与 FilterOutputStream 对象相连以提供有用的接口</td></tr><tr><td style="text-align:center">FileOutputStream</td><td style="text-align:center">用于将信息写至文件</td><td style="text-align:center">字符串，表示文件名、文件或 FilterDescriptor 对象</td><td style="text-align:center">用于指定数据的目的地：将其与 FilterOutputStream 对象相连以提供有用的接口</td></tr><tr><td style="text-align:center">PipedOutputStream</td><td style="text-align:center">任何写入其中的信息都会自动作为相关 PipedInputStream 的输出。实现管道化概念</td><td style="text-align:center">PipedInputStream</td><td style="text-align:center">用于指定数据的目的地：将其与 FilterOutputStream 对象相连以提供有用的接口</td></tr><tr><td style="text-align:center">FilterOutputStream</td><td style="text-align:center">抽象类，作为装饰器的接口，其中装饰器为其他 OutputStream 提供有用的功能</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="添加属性和有用的接口"><a class="header-anchor" href="#添加属性和有用的接口">¶</a>添加属性和有用的接口</h2><p>FilterInputStream 和 FilterOutputStream 是用来提供装饰器类接口以控制特定输入流和输出流的两个类，分别由 InputStream 和 OutputStream 派生而来，这两个类是装饰器的能够工作的必要条件</p><h3 id="通过-FilterInputStream-从-InputStream-读取数据"><a class="header-anchor" href="#通过-FilterInputStream-从-InputStream-读取数据">¶</a>通过 FilterInputStream 从 InputStream 读取数据</h3><p>FilterInputStream 能够完成两件完全不同的事情。其中，DataInputStream 允许读取不同的基本类型数据以及 String 对象（所有的方法都以<code>read</code>开头，例如：<code>readBytte()</code>,<code>readFloat()</code>等等），搭配相应的 DataOutputStream，就可以通过数据流将基本类型的数据从一个地方迁移到另一个地方。具体是哪些地方，由 InputStream 可以读取到来源决定</p><p>其他 FilterInputStream 类则在内部修改 InputStream 的行为方式，例如：是否缓存，是否保留它所读取过的行（允许我们查询行数或设置行数），以及是否把单一字符推回输入流等等。</p><p>不管正在连接的是什么 I/O 设备，几乎每次都要对输入进行缓存，所以 I/O 类库将<font style="color:red">无缓存输入作为特殊情况</font></p><table><thead><tr><th style="text-align:center">类</th><th style="text-align:center">功能</th><th style="text-align:center">构造器参数</th><th style="text-align:center">如何使用</th></tr></thead><tbody><tr><td style="text-align:center">DataInputStream</td><td style="text-align:center">与 DataOutputStream 搭配使用，可以按照可移植方式从流读取基本数据类型</td><td style="text-align:center">InputStream</td><td style="text-align:center">包含用于读取基本数据类型的全部接口</td></tr><tr><td style="text-align:center">BufferInputStream</td><td style="text-align:center">使用此类可以防止每次读取时都进行实际写操作<br>代表 「 使用缓冲区 」</td><td style="text-align:center">InputStream 可以指定缓冲区大小</td><td style="text-align:center">本质上不提供接口，只不过是向进程中添加缓冲区所必需的，与接口对象搭配</td></tr><tr><td style="text-align:center">LineNumberInputStream</td><td style="text-align:center">跟踪输入流中的行好，可调用 getLineNumber() 和 setLineNumber(int)</td><td style="text-align:center">InputStream</td><td style="text-align:center">仅增加了行号，因此可能要与接口对象搭配使用</td></tr><tr><td style="text-align:center">PushbackInputStream</td><td style="text-align:center">具有能弹出一个字节的缓冲区，因此可以将读到的最后一个字符回退</td><td style="text-align:center">InputStream</td><td style="text-align:center">通常作为编译器的扫描器，开发过程中几乎用不到</td></tr></tbody></table><h3 id="通过-FilterOutputStream-从-OutputStream-写入数据"><a class="header-anchor" href="#通过-FilterOutputStream-从-OutputStream-写入数据">¶</a>通过 FilterOutputStream 从 OutputStream 写入数据</h3><p>与 DataInputStream 对应的是 DataOutputStream，它可以将各种基本数据类型以及 String 对象格式化输出到流中。如此操作，最终任何机器上的任何 DataInputStream 都能够读取它们。其中写操作都是以<code>write</code>开头，例如<code>writeByte()</code>,<code>writeFloat()</code>等等</p><p>PrintStream 最初的目的是为了可视化格式打印所有的基本数据类型以及 String 对象。这与 DataOutputStream 是不同的，后者的目的是将数据置入流中，使 DataInputStream 能够可移植地重构它们。PrintStream 内有两个重要的方法：<code>print()</code>和<code>println()</code>。对它们进行了重载，以便可打印出各种数据类型。print() 和 println() 之间的差异是，后者在操作完毕后会添加一个换行符。</p><p>😢 PrintStream 可能会有些问题，因为它捕获了所有的 IOExceptions，因此必须使用 <code>checkError()</code>自行测试错误状态，如果出现错误此方法将返回<code>true</code>，另外，PrintStream 也未完全国际化，不能以平台无关的方式处理换行动作 「 值的庆幸的是，以上出现的问题，最终都在 PrintWriter 中得以解决 」</p><p>BufferOutputStream 是一个修改过的 OutputStream，它对数据流使用缓冲技术，因此当每次向流写入时，不必每次都进行实际的物理写动作。所以在进行输出时，可能更经常使用它。FilterOutputStream 的类型以及功能如下表</p><table><thead><tr><th style="text-align:center">类</th><th style="text-align:center">功能</th><th style="text-align:center">构造器参数</th><th style="text-align:center">如何使用</th></tr></thead><tbody><tr><td style="text-align:center">DataOutputStream</td><td style="text-align:center">与 DataInputStream 搭配使用</td><td style="text-align:center">OutputStream</td><td style="text-align:center">包含用于写入基本类型数据的全部接口</td></tr><tr><td style="text-align:center">PrintStream</td><td style="text-align:center">用于产生格式化输出，其中 DataOutputStream 处理数据的存储，PrintStream 处理显示</td><td style="text-align:center">OutputStream 可以用 boolean 值指示是否在每次换行时清空缓冲区</td><td style="text-align:center">应该是对 OutpuStream 对象的 final 封装，kennel 会经常使用到他</td></tr><tr><td style="text-align:center">BufferedOutputStream</td><td style="text-align:center">使用它以避免每次发送数据时都要进行实际的写操作，代表 「 使用缓冲区 」，可以调用 flush() 清空缓冲区</td><td style="text-align:center">OutputStream 可以指定缓冲区大小</td><td style="text-align:center">本质上并不提供接口，只不过是向进程中添加缓冲区所必需的，与接口对象搭配</td></tr></tbody></table><h2 id="Reader-和-Writer"><a class="header-anchor" href="#Reader-和-Writer">¶</a>Reader 和 Writer</h2><p>Reader 和 Writer 是 Java 1.1 中新增加的两个类，提供兼容 Unicode 与面向字符的 I/O 功能，这两个类并不会替代已有的 InputStream 以及 OutputStream 。有时必须把来自于字节层次结构中的类和字符层次结构中的类结合起来使用。为了实现这个目的，要用到适配器类，这是一种适配器模式。InputStreamReader 可以将 InputStream 转换为 Reader，而 OutputStreamWriter 能够将 OutputStream 转换为 Writer。</p><p>设计 Reader 和 Writer 继承层次结构主要是为了国际化，老的 I/O 流继承层次结构仅支持 8 位字节流，并且不能很好地处理 16 位 Unicode 字符，由于 Unicode 用于字符国际化（ Java 本身的 char 也是 16 位的 Unicode），所以添加 Reader 和 Writer 继承层次结构是为了在所有的 I/O 操作中都支持 Unicode</p><h3 id="数据的来源与去处"><a class="header-anchor" href="#数据的来源与去处">¶</a>数据的来源与去处</h3><p>几乎所有原始的 Java I/O 流类都有相应的 Reader 和 Writer 类来提供天然的 Unicode 操作，这并不代笔着无论什么情况都可以使用字符流而不使用字节流。其实在某些特殊的情况下，就只支持面向字节流而没有面向字符流的支持，因此，最明智的做法是尽量尝试使用 Reader 和 Writer</p><p>下面展示了在两个继承层次结构中，信息的来源和去处之间的对应关系</p><table><thead><tr><th style="text-align:center">来源与去处：Java 1.0 类</th><th style="text-align:center">对应的 Java 1.1 类</th></tr></thead><tbody><tr><td style="text-align:center">InputStream</td><td style="text-align:center">Reader<br>适配器：InputStreamReader</td></tr><tr><td style="text-align:center">OutputStream</td><td style="text-align:center">Writer<br>适配器：OutputStreamWriter</td></tr><tr><td style="text-align:center">FileInputStream</td><td style="text-align:center">FileReader</td></tr><tr><td style="text-align:center">FileOutputStream</td><td style="text-align:center">FileWriter</td></tr><tr><td style="text-align:center">ByteArrayInputStream</td><td style="text-align:center">CharArrayReader</td></tr><tr><td style="text-align:center">ByteArrayOutputStream</td><td style="text-align:center">CharArrayWriter</td></tr><tr><td style="text-align:center">PipedInputStream</td><td style="text-align:center">PipedReader</td></tr><tr><td style="text-align:center">PipedOutputStream</td><td style="text-align:center">PipedWriter</td></tr></tbody></table><p>这两个不同的继承层次结构中的结构即使不能说完全相同，也是非常相似了</p><h3 id="更改流的行为"><a class="header-anchor" href="#更改流的行为">¶</a>更改流的行为</h3><p>对于 InputStream 和 OutputStream 来说，可以使用 FIlterInputStream 和 FilterOutputStream 的装饰器子类来修改流已满足特殊需求，Reader 和 Writer 的类继承层次结构继续沿用相同思想，但是具体细节却并不相同，下表相对于前一表格来说，左右之间的对应关系的近似程序更加粗略一些。造成这种差别的原因是因为类的不同组织形式不同。例如： BufferedOutputStream 是 FilterOutputStream 的子类，但是 BufferedWriter 并不是 FIlterWriter 的子类，但是这些类的接口却是十分相似的</p><table><thead><tr><th>Java 1.0 类</th><th style="text-align:center">Java 1.1 类</th></tr></thead><tbody><tr><td>FilterInputStream</td><td style="text-align:center">FilterReader</td></tr><tr><td>FilterOutputStream</td><td style="text-align:center">FilterWriter（抽象类，没有子类）</td></tr><tr><td>BufferedInputStream</td><td style="text-align:center">BufferedReader</td></tr><tr><td>BufferedOutputStream</td><td style="text-align:center">BufferedWriter</td></tr><tr><td>DataInputStream</td><td style="text-align:center">最好使用 BufferedReader 而不是使用 DataInputStream 的 readLine（）方法</td></tr><tr><td>PritStream</td><td style="text-align:center">PrintWriter</td></tr><tr><td>StreamTokenizer</td><td style="text-align:center">StreamTokenizer（接受 Reader 的构造器）</td></tr><tr><td>PushbackInpuStream</td><td style="text-align:center">PushbackReader</td></tr></tbody></table><h2 id="自我独立的类：RandomAccessFile"><a class="header-anchor" href="#自我独立的类：RandomAccessFile">¶</a>自我独立的类：RandomAccessFile</h2><p>RandomAccessFile 适用于由大小已知的文件操作，可以使用<code>seek()</code>将记录从一处转移到另一处，然后读取或者修改记录。此类与 InputStream 和 OutputStream 没有任何关联，大部分的方法都是本地的，这么做是因为此类拥有和别的 I/O 类型本质不同的行为（可以在一个文件内向前和向后移动）。在任何情况下，它都是自我独立的，直接从 Object 派生而来。</p><p>从本质上来说，RandomAccessFile 的工作方式类似于把 DataInputStream 和 DataOutputStream 组合起来使用，还添加了一些方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file,String mode)</span><span class="keyword">throws</span> FileNotFoundException;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(String name,String mode)</span><span class="keyword">throws</span> FileNotFoundException;</span><br></pre></td></tr></table></figure><p>🎶mode：和 C 一样，打开文件的方式,(<code>r</code>,<code>rw</code>,<code>rws</code>,<code>rwd</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同OutputStream流相同</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同 DataOutputStream</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeInt</span><span class="params">(<span class="type">int</span> v)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeLong</span><span class="params">(<span class="type">long</span> v)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getFilePointer</span><span class="params">()</span><span class="keyword">throws</span> IOException;<span class="comment">//获取当前指针位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">seek</span><span class="params">(<span class="type">long</span> pos)</span><span class="keyword">throws</span> IOException;<span class="comment">//跳转文件指针到指定字节位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">char</span> <span class="title function_">readChar</span><span class="params">()</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="comment">//-----------------------------------------同DataInputStream流相同</span></span><br></pre></td></tr></table></figure><h2 id="I-O-流的典型使用方式"><a class="header-anchor" href="#I-O-流的典型使用方式">¶</a>I/O 流的典型使用方式</h2><p>尽管可以通过不同的方式组合 I/O 流类，但日常开发中也就只用到其中的几种组合，下面的例子可以作为典型的 I/O 用法的基本参考。在这些例子中，异常处理都被简化为将异常传递给控制台，但在真正的项目中，不应该这么做，并且还需要考虑更加复杂的错误处理方式</p><h3 id="使用缓冲方式读取文件"><a class="header-anchor" href="#使用缓冲方式读取文件">¶</a>使用缓冲方式读取文件</h3><p>如果想要打开一个文件，并读取文件汇总的内容，可以使用 String 或 FIle 对象作为文件名的 FileInputReader，为了读取速度，最好再加上缓冲，也就是将所产生的引用传给 BufferedReader 构造器就可以。由于 BufferedReader 也提供了 readLine() 方法，所以这是我们的最终对象和进行读取的接口，当 readLine() 返回 null 时，此时就将文件所有内容读取完毕</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath));</span><br><span class="line">	<span class="type">String</span> <span class="variable">received</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">while</span> ((received = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">		System.out.println(received);</span><br><span class="line">	&#125;</span><br><span class="line">	reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取内存中的数据"><a class="header-anchor" href="#读取内存中的数据">¶</a>读取内存中的数据</h3><p>StringReader 是 Reader 的一个装饰类，用法是读取一个 String 字符串，类似的还存在 StringWriter 类</p><p>❓ 为什么有这两个类？</p><p>可以方便进行 I/O 流的测试，目前所有的流创建起来非常复杂（来自于文件或者网络），使用 StringReader 或 StringWriter 就能够通过非常简单的方式创建一个 Reader 或 Writer，并且这个流读取/写入的内容就是构造器中传入的字符串。并且通过此类读取/写入的字符串最终都是保存在内存中的，并没有直接传输到硬盘上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readMemory</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="type">StringReader</span> <span class="variable">stringReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringReader</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath)).readLine());</span><br><span class="line">	<span class="type">int</span> recv;</span><br><span class="line">   <span class="comment">//每次从 StringReader 中读取一个字符</span></span><br><span class="line">	<span class="keyword">while</span> ((recv = stringReader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">		System.out.println((<span class="type">char</span>) recv);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="格式化的从内存读取数据"><a class="header-anchor" href="#格式化的从内存读取数据">¶</a>格式化的从内存读取数据</h3><p>读取格式化的数据，使用 DataInputStream ，它是一个面向字节的 I/O 类，并不是面向字符的，可以使用 InputStream 读取任何数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">formatMemoryInput</span><span class="params">(String path)</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span></span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path)).readLine().</span><br><span class="line">						getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">		<span class="keyword">while</span> (dataInputStream.available()!=<span class="number">0</span>)) &#123;</span><br><span class="line">			System.out.println((<span class="type">char</span>) dataInputStream.readByte());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🎶 可以使用 available() 方法查看还有多少可供读取的字符，读取的媒介类型不同时，此方法的工作方式是不同的。此方法想要实现的功能是：在没有阻塞的情况下所能读取的字节数。对于文件，这意味着整个文件，对于不同类型的流，可能就不是这样的，所以这个方法需要谨慎使用。</p><p>也可以通过捕获异常的方式来监测输入的末尾，但是使用异常进行流控制，被认为是对异常特性的错误使用</p><h3 id="基本的文件输出"><a class="header-anchor" href="#基本的文件输出">¶</a>基本的文件输出</h3><p>FileWriter 对象可以向文件写入数据，首先创建一个与指定文件连接的 FileWriter，实际上，通常会用 BufferedWriter 将其包装起来用以缓冲输出，「 缓冲往往能显著地增加 I/O 操作的性能 」，在本例中，为了提供格式化机制，它被装饰成 PrintWriter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">basicFileOut</span><span class="params">(String path, String outpath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path));</span><br><span class="line">   <span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(outpath)));</span><br><span class="line">   <span class="type">int</span> <span class="variable">lineCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">   String recv;</span><br><span class="line">   <span class="keyword">while</span> ((recv = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">      printWriter.println(lineCount + <span class="string">&quot;:&quot;</span> + recv);</span><br><span class="line">      lineCount++;</span><br><span class="line">   &#125;</span><br><span class="line">   bufferedReader.close();</span><br><span class="line">   printWriter.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不为所有的输出文件调用 close()，就会发现缓冲区内容不会被刷新清空，最终输出文件中的内容就不会完整。Java SE5 在 PrintWriter 中添加了一个辅助构造器，使得你不必在每次希望创建文本文件并向其中写入时，都去执行所有的装饰工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">basicFileOut</span><span class="params">(String path, String outpath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path));</span><br><span class="line">  <span class="comment">// 新的辅助构造器，只需要传入文件输出路径即可</span></span><br><span class="line">  <span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(outpath);</span><br><span class="line">  <span class="type">int</span> <span class="variable">lineCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  String received;</span><br><span class="line">  <span class="keyword">while</span> ((received = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    printWriter.println(lineCount + <span class="string">&quot;:&quot;</span> + received);</span><br><span class="line">    lineCount++;</span><br><span class="line">  &#125;</span><br><span class="line">  bufferedReader.close();</span><br><span class="line">  printWriter.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="存储和恢复数据"><a class="header-anchor" href="#存储和恢复数据">¶</a>存储和恢复数据</h3><p>PrintWriter 可以对数据进行格式化，但是为了输出可供另一个流恢复的数据，需要用 DataOutputStream 写入数据，并用 DataInputStream 恢复数据。这些流可以是任何形式，但在下面的示例中使用的是一个文件，并且对于读和写都进行了缓冲处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">storingAndRecoveringData</span><span class="params">(String inputPath,String outputPath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="type">DataOutputStream</span> <span class="variable">dataOutputStream</span> <span class="operator">=</span></span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(outputPath)));</span><br><span class="line">   dataOutputStream.writeDouble(<span class="number">3.1415926</span>);</span><br><span class="line">   dataOutputStream.writeUTF(<span class="string">&quot;That was pi&quot;</span>);</span><br><span class="line">   dataOutputStream.writeDouble(<span class="number">1.41413</span>);</span><br><span class="line">   dataOutputStream.writeUTF(<span class="string">&quot;square root of 2&quot;</span>);</span><br><span class="line">   dataOutputStream.close();</span><br><span class="line">   <span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(inputPath)));</span><br><span class="line">   System.out.println(dataInputStream.readDouble());</span><br><span class="line">   System.out.println(dataInputStream.readUTF());</span><br><span class="line">   System.out.println(dataInputStream.readDouble());</span><br><span class="line">   System.out.println(dataInputStream.readUTF());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们使用 DataOutputStream 写入数据，Java 保证可以使用 DataInputStream 准确地读取数据。无论读和写数据的平台多么的不同，只要两个平台上都有 Java，这种问题就不会再发生。</p><h3 id="标准的异常处理代码"><a class="header-anchor" href="#标准的异常处理代码">¶</a>标准的异常处理代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/Users/hmc/Desktop/test.txt&quot;</span>;</span><br><span class="line">  <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path);</span><br><span class="line">    fileOutputStream.write(<span class="string">&quot;hello java&quot;</span>.getBytes());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fileOutputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fileOutputStreamLearning</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="comment">//jdk8 新特性</span></span><br><span class="line">		<span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\JavaProject\\java-code\\.gitignore1&quot;</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">			fos.write(<span class="number">22</span>);<span class="comment">// 写入一个字符</span></span><br><span class="line">			fos.write(<span class="string">&quot;这就是我要写入的内容&quot;</span>.getBytes());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="标准-I-O"><a class="header-anchor" href="#标准-I-O">¶</a>标准 I/O</h2><p>标准 I/O 这个术语参考的是 Unix 中 「 程序所使用的单一信息流 」这个概念。程序是所有输入都可以来自于标准输入，它的所有输出也都可以发送到标准输出，以及所有的错误信息都可以发送到标准错误。</p><p>✨ 标准 I/O 的意义在于：可以很容易地把程序串联起来，一个程序的标准输出可以称为另一程序的标准输入</p><h3 id="从标准输入中读取"><a class="header-anchor" href="#从标准输入中读取">¶</a>从标准输入中读取</h3><p>按照标准 I/O，Java 提供了 <a target="_blank" rel="noopener" href="http://System.in">System.in</a>、System.out 和 System.err，其中<code>System.out</code>已经事先被包装成了 PrintStream 对象，System.err 同样也是 PrintStream，但 <a target="_blank" rel="noopener" href="http://System.in">System.in</a> 却是一个没有被包装过的未经加工的 InputStream。这意味着尽管我们可以立即使用 System.out 和 System.err，但是在读取 <a target="_blank" rel="noopener" href="http://System.in">System.in</a> 之前必须对其进行包装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">String s;</span><br><span class="line"><span class="keyword">while</span> ((s = in.readLine()) != <span class="literal">null</span> &amp;&amp; s.length() != <span class="number">0</span>) &#123;</span><br><span class="line">   System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将-System-out-转换成-PrintWriter"><a class="header-anchor" href="#将-System-out-转换成-PrintWriter">¶</a>将 System.out 转换成 PrintWriter</h3><p>System.out 是一个 PrintStream ，而 PrintWriter 是一个 OutputStream，PrintWriter 有一个可以接受 OutputStream 作为参数的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// true 表示 auto flush，以便开启自动清空功能，否则，你可能看不到输出</span></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(System.out, <span class="literal">true</span>);</span><br><span class="line">out.println(<span class="string">&quot;hello print writer&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="标准-I-O-重定向"><a class="header-anchor" href="#标准-I-O-重定向">¶</a>标准 I/O 重定向</h3><p>Java 的 System 类提供了一些简单的静态方法调用，以允许程序对标准输入、输出和错误 I/O 流进行重定向</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setIn(InputStream);</span><br><span class="line">setOut(PrintStream);</span><br><span class="line">setErr(PrintStream);</span><br></pre></td></tr></table></figure><p>🎶 重定向操作的是字节流，而不是字符流，因此我们使用的是 InputStream 和 OutputStream 而不是 Reader 和 Writer</p><h2 id="压缩"><a class="header-anchor" href="#压缩">¶</a>压缩</h2><p>Java IO 类库中的类支持读写压缩格式的数据流，因此可以使用这些流对其他的 I/O 类进行封装，以提供压缩功能。</p><p>✨ 这些类不是从 Reader 和 Writer 类派生而来的，而是属于 InputStream 和 OutputStream 继承层次结构的一部分。</p><table><thead><tr><th style="text-align:center">压缩类</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">CheckedInputStream</td><td style="text-align:center">GetCheckSum() 为任何 InputStream 产生校验和</td></tr><tr><td style="text-align:center">CheckOutputStream</td><td style="text-align:center">GetCheckSum() 为任何 OutputStream 产生校验和</td></tr><tr><td style="text-align:center">DeflateOutputStream</td><td style="text-align:center">压缩类的基类</td></tr><tr><td style="text-align:center">ZipOutputStream</td><td style="text-align:center">一个 DeflateOutputStream，用于将数据压缩成 ZIP 文件格式</td></tr><tr><td style="text-align:center">GZIPOutputStream</td><td style="text-align:center">一个 DeflateOutputStream，用于将数据压缩成 GZIP 文件格式</td></tr><tr><td style="text-align:center">InflaterInputStream</td><td style="text-align:center">解压缩类的基类</td></tr><tr><td style="text-align:center">ZipInputStream</td><td style="text-align:center">一个 InflaterInputStream，用于解压缩 Zip 文件格式的数据</td></tr><tr><td style="text-align:center">GZIPInputStream</td><td style="text-align:center">一个 InflaterInputStream，用于解压缩 GZip 文件格式的数据</td></tr></tbody></table><h2 id="文件字节流"><a class="header-anchor" href="#文件字节流">¶</a>文件字节流</h2><p>文件字节流用来向文件进行相关的读取与写出操作，具体有两个类：FileInputStream 以及 FileOutputStream</p><h3 id="FileInputStream"><a class="header-anchor" href="#FileInputStream">¶</a>FileInputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(File file)</span><span class="keyword">throws</span> FileNotFoundException;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(FileDescriptor fdObj)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(String name)</span><span class="keyword">throws</span> FileNotFoundException;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每次读取一个字节,并将字节的ASCII码值返回,如果读取到文件末尾,返回-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="comment">//返回值是实际读取的长度，如果没有数据读入，返回-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="comment">//返回读取的总长度，如果没有数据读入，返回-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b,<span class="type">int</span> off,<span class="type">int</span> len)</span><span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line"><span class="type">int</span> <span class="variable">bs</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((bs = fileInputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">  System.out.print((<span class="type">char</span>) bs);<span class="comment">//使用print不会手动给程序增加换行</span></span><br><span class="line">&#125;</span><br><span class="line">fileInputStream.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line"><span class="type">byte</span>[] by = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = fileInputStream1.read(by)) != -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(by, <span class="number">0</span>, len);</span><br><span class="line">  System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">fileInputStream1.close();</span><br></pre></td></tr></table></figure><h3 id="FileOutputStream"><a class="header-anchor" href="#FileOutputStream">¶</a>FileOutputStream</h3><p>创建对象就会强制生成新文件，清空源文件内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(File file)</span><span class="keyword">throws</span> FileNotFoundException;</span><br><span class="line"><span class="comment">//如果append为true,则进行文件的追加写入</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(File file,<span class="type">boolean</span> append)</span><span class="keyword">throws</span> FileNotFoundException;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(String name)</span><span class="keyword">throws</span> FileNotFoundException;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(String name,<span class="type">boolean</span> append)</span><span class="keyword">throws</span> FileNotFoundException;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span><span class="keyword">throws</span> IOException;<span class="comment">//写入b对应ASCII码表中的字符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b)</span><span class="keyword">throws</span> IOException;<span class="comment">//写一个字节数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b,<span class="type">int</span> off,<span class="type">int</span> len)</span><span class="keyword">throws</span> IOException;<span class="comment">//写一个数组的一部分</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span><span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\lifeInformation\\test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//源代码throws FileNotFoundException异常需要自己处理此异常</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">		<span class="comment">//会抛出IOException异常，IOException是FileNotFoundException异常的父类</span></span><br><span class="line">    fileOutputStream.write(<span class="string">&quot;hello world io&quot;</span>.getBytes());</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>❓为什么一定要关闭文件？</p><p>让流对象变成垃圾，这样就可以被垃圾回收器回收并通知系统去释放该文件相关的资源</p><h2 id="字节缓冲区流"><a class="header-anchor" href="#字节缓冲区流">¶</a>字节缓冲区流</h2><p>通过<code>FileInputStream</code>中<strong>字节数组读写数据</strong>的确比读取一个字节的方式快；然而如果拥有一个<strong>缓存区</strong>将比单纯的字节数组读写数据更快，Java 提供了带缓冲区的字节类，这种类被称为:<strong>缓冲区类</strong>，<span style="color:red;font-weight:700">专门对 FileInputStream 以及 FileOutputStream 包装</span>主要有如下两类:</p><p>缓冲区写数据流类（<code>BuffededOutputStream</code>）和缓冲区读数据流类（<code>BufferedInputStream</code>）</p><h3 id="BufferedOutputStream"><a class="header-anchor" href="#BufferedOutputStream">¶</a>BufferedOutputStream</h3><p>使用缓冲区，更加快速高效的写数据，由于 BufferedOutputStream 流是作用在 OutputStream 流之上的，所以<code>BufferedOutputStream</code>构造方法的参数就应该传入<code>OuputStream对象</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认的缓冲区大小，通常使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedOutputStream</span><span class="params">(OutputStream out)</span>;</span><br><span class="line"><span class="comment">//指定缓冲区的大小，一般用不上</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedOutputStream</span><span class="params">(OutputStream out,<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高效缓冲区类,每次写一个字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="comment">// 继承自FilterOutputStream方法,高效缓冲区类,每次写一个缓冲区数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="comment">// 将缓冲区字节数组某一区间上的内容写入流中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b,<span class="type">int</span> off,<span class="type">int</span> len)</span><span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bufferedOutputStream</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>((<span class="string">&quot;E:\\research_plan\\2020..17~\\test.txt&quot;</span>)));</span><br><span class="line">bufferedOutputStream.write(<span class="string">&quot;hello java bufferedOutputStream&quot;</span>.getBytes());</span><br><span class="line">bufferedOutputStream.close();</span><br></pre></td></tr></table></figure><h3 id="BufferedInputputStream"><a class="header-anchor" href="#BufferedInputputStream">¶</a>BufferedInputputStream</h3><p>使用缓冲区对流中的数据进行高效的读取，同缓冲区写数据流相同，基于字节输入流，所以构造参数需要字节输入流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream(InputStream in);</span><br><span class="line">BufferedInputStream(InputStream in, <span class="type">int</span> size);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b,<span class="type">int</span> off,<span class="type">int</span> len)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b)</span><span class="keyword">throws</span> IOException;<span class="comment">//继承自FilterInputStream方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mark</span><span class="params">(<span class="type">int</span> readlimit)</span>;<span class="comment">//设置mark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span><span class="keyword">throws</span> IOException;<span class="comment">//重置读取指针到mark处</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">markSupported</span><span class="params">()</span>;<span class="comment">//判断当前类是否支持mark()以及reset()方法</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\research_plan\\2020..17~\\test.txt&quot;</span>));</span><br><span class="line">  bufferedInputStream.mark(<span class="number">0</span>);</span><br><span class="line">  <span class="type">byte</span>[] by = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">  <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ((len = bufferedInputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print((<span class="type">char</span>) len);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line">  bufferedInputStream.reset();<span class="comment">//重置指针，从文件头部再一次读取文件内容</span></span><br><span class="line">  <span class="keyword">while</span> ((len = bufferedInputStream.read(by)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(by, <span class="number">0</span>, len));</span><br><span class="line">  &#125;</span><br><span class="line">  bufferedInputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🎶 Java 文件读取虽有多种方式，但是多种读取方式<strong>共享同个文件读取指针</strong>，意味着：<strong>前一种读取方式读完整个文件时，后一种方式将读取不到任何内容</strong>（此时文件指针已经移动到了文件尾部）。存在重复读取一个文件时，就需要重置文件指针，保证后一种读取方式能够正确读取文件内容。</p><p>🤔为什么缓冲区数据流的构造参数需要我们手动传入输入输出流，而不是和输入输出流一样，直接传入一个文件路径？</p><p>这是一种装饰器模式，如果使用文件路径，缓冲区流就使得 Java IO 系统更加复杂</p><h2 id="转换流"><a class="header-anchor" href="#转换流">¶</a>转换流</h2><p>将字节流转换为字符流,写入数据的<strong>编码</strong>以及读出数据的<strong>解码</strong>过程均是在<strong>转换流类中进行</strong>，其他的过程并不需要涉及这个步骤</p><h3 id="OutputStreamWriter"><a class="header-anchor" href="#OutputStreamWriter">¶</a>OutputStreamWriter</h3><p>此类继承自<code>java.io.Writer</code>一种输出转换字符流转换类，一个字符 = 两个字节。</p><ul><li><p>字符流数据不直接进入硬盘而是<strong>写入缓冲区</strong>，所以每次写完之后需要<code>flush()</code>或者<code>close()</code>。</p></li><li><p>与字节流不同，转换流每次<strong>写入的是什么最终在文件中就会保存什么</strong>，而不会出现字节流的情况:不论写什么最终都会<strong>转换为 char 类型的字符</strong>.比如写入<code>97</code>,最终在文件中保存的就是<code>a</code>.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采用默认编码把字节流的数据转换为字符流</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream out)</span>;</span><br><span class="line"><span class="comment">//根据指定编码把字节流转换为字符流</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream out,String charsetName)</span></span><br><span class="line">    <span class="keyword">throws</span> UnsupportedEncodingException;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----------------------------------------------------继承的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] cbuf)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="comment">//----------------------------------------------------重写的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str,<span class="type">int</span> off,<span class="type">int</span> len)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] cbuf,<span class="type">int</span> off,<span class="type">int</span> len)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span><span class="keyword">throws</span> IOException;<span class="comment">//写一个字符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span><span class="keyword">throws</span> IOException;<span class="comment">//刷新缓冲，将数据写入硬盘</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span><span class="keyword">throws</span> IOException;<span class="comment">//先刷新缓冲区，然后关闭文件</span></span><br></pre></td></tr></table></figure><p>每次使用一个<strong>字节输出流的类</strong>以及<strong>字符集</strong>初始化字符流对象即可实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">outputStreamWriter</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;testx.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">outputStreamWriter.write(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">outputStreamWriter.close();</span><br></pre></td></tr></table></figure><p>🆚flush()与 close()的区别？</p><ul><li>**close()**关闭流对象，但是先刷新一次缓冲区，关闭之后，流对象不可以继续使用</li><li>**flush()**仅仅刷新缓冲区，刷新之后，流对象还可以继续使用</li></ul><h3 id="FileWriter"><a class="header-anchor" href="#FileWriter">¶</a>FileWriter</h3><p>继承自<code>java.io.OutputStreamWriter</code>，由于常见的操作都是使用本地默认编码，所以不用指定编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(String fileName,<span class="type">boolean</span> append)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(String fileName)</span><span class="keyword">throws</span> IOException;<span class="comment">//直接指明写入文件的路径字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(File file,<span class="type">boolean</span> append)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(File file)</span><span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><h3 id="InputStreamReader"><a class="header-anchor" href="#InputStreamReader">¶</a>InputStreamReader</h3><p>是字节流变换为<strong>字符流</strong>的桥梁，<span style="color:red;font-weight:700">并不支持<code>mark()</code>以及<code>reset()</code></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader(InputStream in);</span><br><span class="line">InputStreamReader(InputStream in, String charsetName);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符流每次读入一个字符</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="comment">//字符流每次读入一个数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] cbuf,<span class="type">int</span> offset,<span class="type">int</span> length)</span><span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><p>每次<strong>读入一个字符</strong>的输入流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">outputStreamWriter</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;testx.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">outputStreamWriter.write(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">outputStreamWriter.close();</span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;testx.txt&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((ch = inputStreamReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.print((<span class="type">char</span>) ch);</span><br><span class="line">    &#125;</span><br><span class="line">inputStreamReader.close();</span><br></pre></td></tr></table></figure><p>每次<strong>读入一个数组</strong>的输入流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">outputStreamWriter</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;testx.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">outputStreamWriter.write(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">outputStreamWriter.close();</span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;testx.txt&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> cbuf.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = inputStreamReader.read(cbuf, offset, len)) != -<span class="number">1</span>) &#123;</span><br><span class="line">  System.out.print(cbuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FileReader"><a class="header-anchor" href="#FileReader">¶</a>FileReader</h3><p>FileOutputStream 流对应的字符流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(File file)</span><span class="keyword">throws</span> FileNotFoundException;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(String fileName)</span><span class="keyword">throws</span> FileNotFoundException;</span><br></pre></td></tr></table></figure><h2 id="字符缓冲区流"><a class="header-anchor" href="#字符缓冲区流">¶</a>字符缓冲区流</h2><p>字符流为了高效读写，同样提供了对应了字符缓冲流</p><ul><li>BufferedReader</li><li>BufferedWriter</li></ul><h3 id="BufferedWriter"><a class="header-anchor" href="#BufferedWriter">¶</a>BufferedWriter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Writer的具体子类FileWriter初始化字符缓冲输出流，缓冲区使用默认大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedWriter</span><span class="params">(Writer out)</span>;</span><br><span class="line"><span class="comment">//指定缓冲区大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedWriter</span><span class="params">(Writer out,<span class="type">int</span> sz)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String s,<span class="type">int</span> off,<span class="type">int</span> len)</span><span class="keyword">throws</span> IOException;<span class="comment">//写入特定长度的字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] cbuf,<span class="type">int</span> off,<span class="type">int</span> len)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="comment">//在当前行插入一个换行符，能够根据系统不同输入不同的字符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newLine</span><span class="params">()</span><span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><h3 id="BufferedReader"><a class="header-anchor" href="#BufferedReader">¶</a>BufferedReader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Reader的具体子类FileReader初始化字符缓冲流，缓冲区大小使用默认长度</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedReader</span><span class="params">(Reader in)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedReader</span><span class="params">(Reader in,aint sz)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span><span class="keyword">throws</span> IOException;<span class="comment">//每次读入一个字符</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] cbuf,<span class="type">int</span> off,<span class="type">int</span> len)</span><span class="keyword">throws</span> IOException;<span class="comment">//每次读入一个字符数组</span></span><br><span class="line"><span class="comment">//每次读一行,包含该行内容的字符串，不包含任何终止符.如果到达文件结尾返回null</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">readLine</span><span class="params">()</span><span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><h3 id="LineNumberReader"><a class="header-anchor" href="#LineNumberReader">¶</a>LineNumberReader</h3><p>继承自<code>java.io.BufferedReader</code>,具有字符缓冲区流两个所不具有的特定方法<code>打印行号</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LineNumberReader(Reader in);</span><br><span class="line">LineNumberReader(Reader in, <span class="type">int</span> sz);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLineNumber</span><span class="params">()</span>;<span class="comment">//获取当前读取文件的行号</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLineNumber</span><span class="params">(<span class="type">int</span> lineNumber)</span>;<span class="comment">//设置行号的其实记录值</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">bufferedWriter.write(<span class="string">&quot;这里似乎有点意思&quot;</span>);</span><br><span class="line">bufferedWriter.newLine();</span><br><span class="line">bufferedWriter.close();</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> cbuf.length;</span><br><span class="line"><span class="keyword">while</span> ((len = bufferedReader.read(cbuf, <span class="number">0</span>, len)) != -<span class="number">1</span>) &#123;</span><br><span class="line">	System.out.print(cbuf);</span><br><span class="line">&#125;</span><br><span class="line">bufferedReader.close();</span><br></pre></td></tr></table></figure><h2 id="数据输入输出流"><a class="header-anchor" href="#数据输入输出流">¶</a>数据输入输出流</h2><p>继承自<code>java.io.FilterInputStream</code>,可以对基本数据类型操作的 IO 类</p><h3 id="DataInputStream"><a class="header-anchor" href="#DataInputStream">¶</a>DataInputStream</h3><p>读取<code>DateOutputSream</code>写入文件中的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream(InputStream in);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">short</span> <span class="title function_">readShort</span><span class="params">()</span><span class="keyword">throws</span> IOException;<span class="comment">//读取一个short类型的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">readLong</span><span class="params">()</span><span class="keyword">throws</span> IOException;<span class="comment">//读取一个long类型的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">char</span> <span class="title function_">readChar</span><span class="params">()</span><span class="keyword">throws</span> IOException;<span class="comment">//读取一个char类型的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> xxx <span class="title function_">readXxx</span><span class="params">()</span><span class="keyword">throws</span> IOException;<span class="comment">//读取一个基本数据类型为xxx的数据</span></span><br></pre></td></tr></table></figure><p>🎶由于写入的数据并不是正规的字节或者字符数据，因此使用记事本打开是一堆乱码，只能通过相应的<code>DataInputStream</code>进行读取，并且写入的是什么类型读取时也应该调用相应类型的 API</p><h3 id="DatsOutputStream"><a class="header-anchor" href="#DatsOutputStream">¶</a>DatsOutputStream</h3><p>继承自<code>java.io.FilterOutputStream</code>，用于传递基本数据类型以及 String 对象供 DataInputStream 读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DataOutputStream</span><span class="params">(OutputStream out)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeByte</span><span class="params">(<span class="type">int</span> v)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeInt</span><span class="params">(<span class="type">int</span> v)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="comment">//向文件中写一个基本数据类型为xxx的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeXxx</span><span class="params">(<span class="type">int</span> v)</span><span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataOutputStream</span> <span class="variable">dataOutputStream</span> <span class="operator">=</span>	<span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;text.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">dataOutputStream.writeInt(<span class="number">3</span>);</span><br><span class="line">dataOutputStream.writeShort();</span><br><span class="line">dataOutputStream.writeChar(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">dataOutputStream.close();</span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;text.txt&quot;</span>));</span><br><span class="line">System.out.println(dataInputStream.readInt());</span><br><span class="line">System.out.println(dataInputStream.readShort());</span><br><span class="line">System.out.println(dataInputStream.readChar());</span><br><span class="line">dataInputStream.close();</span><br></pre></td></tr></table></figure><h2 id="内存操作流"><a class="header-anchor" href="#内存操作流">¶</a>内存操作流</h2><p>用于处理临时存储信息，<span style="color:red;font-weight:700">程序结束，数据就从内存中消失</span></p><table><thead><tr><th style="text-align:center">字节数组</th><th style="text-align:center">字符数组</th><th style="text-align:center">字符串</th></tr></thead><tbody><tr><td style="text-align:center">ByteArrayInputStream</td><td style="text-align:center">CharArrayReader</td><td style="text-align:center">StringReader</td></tr><tr><td style="text-align:center">ByteArrayOutputStream</td><td style="text-align:center">CharArrayWriter</td><td style="text-align:center">StringWriter</td></tr></tbody></table><h3 id="ByteArrayOutputStream"><a class="header-anchor" href="#ByteArrayOutputStream">¶</a>ByteArrayOutputStream</h3><ul><li>继承自<code>java.io.OutputStream</code>,属于字节流的范畴，写入的数据并不会保存到本地磁盘中，而是存在于内存缓冲区中.</li><li>此流并不需要显示调用 close()去关闭，并且手动调用 close()后仍然可以向其中写入数据</li><li>由于数据仅仅存在于内存缓冲区中，所以如果需要读取当前数据，需要将缓冲区中的数据保存到一个<code>byte[]</code>或者<code>String</code>中，而后使用<code>ByteArrayInputStream</code>流对这些数据进行读取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ByteArrayOutputStream</span><span class="params">()</span>;<span class="comment">//创建一个内存操作流，内存缓冲区容量大小随着输入数据自适应增长</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ByteArrayOutputStream</span><span class="params">(<span class="type">int</span> size)</span>;<span class="comment">//创建一个字节数组输出流，并且字节数组输出流的大小限定为size</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] toByteArray();<span class="comment">//将当前字节数组输出流中的内容返回，提供给输入流进行读取</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>;	<span class="comment">//将当前字节数组输出流中的内容转换成String类型返回</span></span><br><span class="line"><span class="comment">//将输出流中的内容按照特定的编码集返回</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">(String charsetName)</span><span class="keyword">throws</span> UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeTo</span><span class="params">(OutputStream out)</span><span class="keyword">throws</span> IOException;<span class="comment">//将当前字节输出流中的内容写入到OutputStream流中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span>;	<span class="comment">//写入一个字符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b,<span class="type">int</span> off,<span class="type">int</span> len)</span>;<span class="comment">//一次性写入一个数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;<span class="comment">//获取当前字节数组的长度，用于读取当前输出流内部数据时使用</span></span><br></pre></td></tr></table></figure><h3 id="ByteArrayInputStream"><a class="header-anchor" href="#ByteArrayInputStream">¶</a>ByteArrayInputStream</h3><p>继承自<code>java.io.InputStream</code>,属于字节流的范畴</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ByteArrayInputStream</span><span class="params">(<span class="type">byte</span>[] buf)</span>;	<span class="comment">//使用从输出流中传递出来的字节数组，查看当前内存缓冲区中的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ByteArrayInputStream</span><span class="params">(<span class="type">byte</span>[] buf,<span class="type">int</span> offset,<span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取方法和字节流的read方法相同</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b,<span class="type">int</span> off,<span class="type">int</span> len)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h2 id="打印流"><a class="header-anchor" href="#打印流">¶</a>打印流</h2><p>✨打印流是一种写数据的流，最终系统会进行读取，没有提供给用户对应的读数据接口；可以向此流中写入任意类型的数据，如果启动了自动刷新，能够自动刷新写入的内容；此流和其他的输出流相同是可以直接操作文本文件的</p><p>🤔 共有哪些流对象是可以直接操作文本文件的尼？</p><p>目前共有如下几种流可以直接作用于文件中：FileInputStream、FileOutputStream、FileReader、FileWriter、PrintStream（字节打印流）、PrintWriter（字符打印流）</p><p>打印字符流,继承自<code>java.io.Writer</code>可以直接将内容写入到一个文件中,但是其也拥有自己的特有方法:能够自动刷新,每写一次就自动刷新文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWriter</span><span class="params">(File file)</span>;</span><br><span class="line">PrintWriter(String fileName);</span><br><span class="line"><span class="comment">//---------------------------------------使用字节流</span></span><br><span class="line">PrintWriter(OutputStream out);</span><br><span class="line">PrintWriter(OutputStream out, <span class="type">boolean</span> autoFlush);<span class="comment">//启动自动刷新</span></span><br><span class="line"><span class="comment">//---------------------------------------使用字符流</span></span><br><span class="line">PrintWriter(Writer out);</span><br><span class="line">PrintWriter(Writer out, <span class="type">boolean</span> autoFlush)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">boolean</span> b)</span>;<span class="comment">//print重载了所有基本数据类型,但是不支持自动刷新</span></span><br><span class="line"><span class="comment">//重载了常用的基本数据类型,开启自动刷新时,会将内容自动自动保存至文件,每次会在行末尾增加一个换行符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">boolean</span> x)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] buf,<span class="type">int</span> off,<span class="type">int</span> len)</span>;<span class="comment">//继承自父类的传统写方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;<span class="comment">//如果未启动自动刷新,则依靠flush()或者close()将内容写入文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> PrintWriter <span class="title function_">format</span><span class="params">(String format,Object... args)</span>;</span><br><span class="line"><span class="keyword">public</span> PrintWriter <span class="title function_">printf</span><span class="params">(String format,Object... args)</span>;</span><br></pre></td></tr></table></figure><p>🎶如果启动了自动刷新,则 <code>println</code>, <code>printf</code>, or<code>format</code> methods 将会自动刷新.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">println();<span class="comment">//等价于</span></span><br><span class="line"><span class="comment">/**********************/</span></span><br><span class="line">bw.write();</span><br><span class="line">bw.newLine();</span><br><span class="line">bw.flush()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;text.txt&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">printWriter.println(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">printWriter.close();<span class="comment">//养成关闭文件的好习惯</span></span><br></pre></td></tr></table></figure><h2 id="标准输入输出流"><a class="header-anchor" href="#标准输入输出流">¶</a>标准输入输出流</h2><p>System 类中的两个成员变量:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> InputStream in;<span class="comment">//标准输入流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream out;<span class="comment">//标准输出流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream err;</span><br></pre></td></tr></table></figure><h3 id="键盘录入数据"><a class="header-anchor" href="#键盘录入数据">¶</a>键盘录入数据</h3><p>✨ 一个程序要想获取外部提供的输入数据，共有以下三种：</p><ul><li>通过 main 方法的 args 接受参数</li><li>使用 JDK5 以后的新特性 Scanner</li><li>使用字符缓冲流包装标准输入流(<a target="_blank" rel="noopener" href="http://System.in">System.in</a>)实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;使用Scanner进行数据的读取&quot;</span>);</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.println(x);</span><br><span class="line">System.out.println(<span class="string">&quot;使用bufferedreader进行字符串的读取&quot;</span>);</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">System.out.println(bufferedReader.readLine());</span><br><span class="line">System.out.println(<span class="string">&quot;使用bufferedreader进行int的读取&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(line);</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><p>使用字符流将数据写入到控制台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">bufferedWriter.write(<span class="string">&quot;使用bufferedreader进行字符串的读取\n&quot;</span>);</span><br><span class="line">bufferedWriter.flush();</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">System.out.println(bufferedReader.readLine());</span><br></pre></td></tr></table></figure><h2 id="合并流"><a class="header-anchor" href="#合并流">¶</a>合并流</h2><p>以前的文件流传输过程:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.txt---&gt; b.txt</span></span><br><span class="line"><span class="comment">//c.txt---&gt; b.txt</span></span><br><span class="line"><span class="comment">//需求</span></span><br><span class="line"><span class="comment">//a.txt+c.txt --&gt; b.txt</span></span><br></pre></td></tr></table></figure><h3 id="SequenceInputStream"><a class="header-anchor" href="#SequenceInputStream">¶</a>SequenceInputStream</h3><p>继承自<code>java.io.InputStream</code>,主要将多个文件合并处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SequenceInputStream</span><span class="params">(InputStream s1,InputStream s2)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SequenceInputStream</span><span class="params">(Enumeration&lt;? extends InputStream&gt; e)</span>;</span><br><span class="line"><span class="comment">//Enumeration 是vector中一个方法的返回值类型</span></span><br></pre></td></tr></table></figure><p>其中<code>Enumeration</code><e>是一个接口，只有两种方法</e></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">hasMoreElements</span><span class="params">()</span>;<span class="comment">//等同于iterator中的hasNext()</span></span><br><span class="line">E <span class="title function_">nextElement</span><span class="params">()</span>;<span class="comment">//等同于iterator中的next()方法</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Enumeration&lt;E&gt; e = v.elements(); e.hasMoreElements();)</span><br><span class="line">    System.out.println(e.nextElement());</span><br></pre></td></tr></table></figure><p>均继承自<code>InputStream</code>没有自己的特有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span>	<span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span>	<span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure><h2 id="序列化流"><a class="header-anchor" href="#序列化流">¶</a>序列化流</h2><ul><li>序列化流：<ul><li>将对象按照流一样的方式存入文件中或在网络中传输(对象–&gt;流)</li><li><code>ObjectOutputStream</code></li></ul></li><li>反序列化流:<ul><li>将文本文件中的流对象数据或者网络中的流对象数据还原成对象(流数据–&gt;对象)</li><li><code>ObjectInputStream</code></li></ul></li></ul><h3 id="ObjectIntputStream"><a class="header-anchor" href="#ObjectIntputStream">¶</a>ObjectIntputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectInputStream</span><span class="params">(InputStream in)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">ObjectInputStream</span><span class="params">()</span><span class="keyword">throws</span> IOException,SecurityException;</span><br></pre></td></tr></table></figure><p>Person 类实现了序列化接口，那么它本身也会拥有一个标记值，如果相应的类做出了更改，这个 ID 就会更改，如果更改之后没有进行序列化操作，继续进行反序列的操作将会出现异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从当前输入流自动读取一个对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">readObject</span><span class="params">()</span><span class="keyword">throws</span> IOException,ClassNotFoundException;</span><br></pre></td></tr></table></figure><h3 id="ObjdectOutputStream"><a class="header-anchor" href="#ObjdectOutputStream">¶</a>ObjdectOutputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">ObjectOutputStream</span><span class="params">()</span><span class="keyword">throws</span> IOException,SecurityException;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectOutputStream</span><span class="params">(OutputStream out)</span><span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><p><code>java.io.NotSerializableException</code>：未序列化异常，需要实现<code>Serializable</code>接口，以启用序列化功能。Serializable 接口没有任何方法，这种没有方法的接口为<code>标记接口</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化一个对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(Object obj)</span><span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><h3 id="ID"><a class="header-anchor" href="#ID">¶</a>ID</h3><p>❓ 在实际开发中，可能还需要使用以前写过的数据，不能重新写入，如何处理？</p><ul><li>将当前类的 ID 固定，由于每次会读取当前类中固定的 ID 值，所以对类的任何修改，均不会造成之后的访问失败</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;<span class="comment">//推荐使用IDE帮助生成随机的ID</span></span><br></pre></td></tr></table></figure><h3 id="序列化选择"><a class="header-anchor" href="#序列化选择">¶</a>序列化选择</h3><p>一个类中可能有多个成员变量，有些可能并不需要进行序列化，此使就需要使用<code>transient</code>关键字，声明不需要序列化的成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> age;<span class="comment">//序列化时并不会序列化此字段，反序列化时读取到的值就是默认值</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Properties"><a class="header-anchor" href="#Properties">¶</a>Properties</h2><p>属性集合类，是一个可以和 I/O 流结合使用的集合类，<code>properties</code>可保存在流中或从流中加载，属性列表中每个键及其对应的值都是一个字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Properties</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Properties</span><span class="params">(Properties defaults)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(String key,String value)</span>;</span><br><span class="line"><span class="comment">//------------------------------------------------继承自hashtable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">setProperty</span><span class="params">(String key,String value)</span>;<span class="comment">//添加元素</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getProperty</span><span class="params">(String key)</span>;<span class="comment">//获取元素</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">stringPropertyNames</span><span class="params">()</span>;<span class="comment">//获取所有的键的集合</span></span><br><span class="line"><span class="comment">//把文件中的数据读取到集合中，文件中的数据必须是键值对形式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(Reader reader)</span><span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="comment">//把集合中的数据存储到文件，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">store</span><span class="params">(OutputStream out,String comments)</span><span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><h2 id="附：-编码表"><a class="header-anchor" href="#附：-编码表">¶</a>附： 编码表</h2><table><thead><tr><th style="text-align:center">码表</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">ISO-8859-1</td><td style="text-align:center">拉丁码表,8 位表示一个数据</td></tr><tr><td style="text-align:center">GB23</td><td style="text-align:center">中国的中文编码表</td></tr><tr><td style="text-align:center">GBK23</td><td style="text-align:center">中国的中文编码表</td></tr><tr><td style="text-align:center">GBK</td><td style="text-align:center">中国的中文编码表升级,融合了更多的中文文字符号,java 默认中文码表</td></tr><tr><td style="text-align:center">GB18030</td><td style="text-align:center">GBK 的取代版本</td></tr><tr><td style="text-align:center">Unicode</td><td style="text-align:center">国际标准码,融合了多种文字,java 默认码表</td></tr><tr><td style="text-align:center">UTF-8</td><td style="text-align:center">最多用三个字节来表示一个字符,具有较好的兼容其他码表</td></tr></tbody></table><p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/Interview-Notebook/notes-Java%20IO.md">Java I/O</a><br><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-properties-class.html">Java Properties 类</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023008389">深入学习 JAVA -IO 流详解</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42476601/article/details/85698762">使用 StringWriter 和 StringReader 的好处</a></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/Java-IO/" rel="tag">Java IO</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/mysql-%E6%80%BB%E8%A7%88/" data-tooltip="MySQL 总览" aria-label="上一篇: MySQL 总览"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/" data-tooltip="用户空间与内核空间" aria-label="下一篇: 用户空间与内核空间"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/mysql-%E6%80%BB%E8%A7%88/" data-tooltip="MySQL 总览" aria-label="上一篇: MySQL 总览"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/" data-tooltip="用户空间与内核空间" aria-label="下一篇: 用户空间与内核空间"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>