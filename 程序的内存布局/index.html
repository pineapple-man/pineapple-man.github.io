<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>程序的内存布局 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="进程的内存布局"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n¶应用程序的内存空间\n每个进程所看到的内存其实是操作系统虚拟出来的，称为逻辑地址空间。这个逻辑地址最终要通过寻址过程翻译成实际的物理地址进行内存访问。这个物理地址可以是内存中的内核区地址、也可以是用户区、也可以是硬盘上的 Swap 区\n\n✨一般而言，应用程序使用的内存空间里有如下默认的区域：\n\n\n\n区域\n含义\n\n\n\n\n栈\n栈用于维护函数调用的上下文，没有栈，函数调用就无法实现，栈通常在用户空间的最高地址处分配，一般有数兆字节的大小\n\n\n堆\n堆用来容纳应用程序动态分配的内存区域，当程序使用 malloc 或者 new 分配内存的时候，得到的内存来自堆。堆通常存在于栈的下方（低地址方向），某些时候，堆也可能没有固定统一的存储区域，堆一般比栈大很多，可以有几十至数百兆字节的容量\n\n\n可执行文件映像\n存储着可执行文件在内存里的映像，由装载器在装载时将可执行文件的内存读取或映射到这里\n\n\n保留区\n保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称：例如大多数操作系统中，极小的地址通常都是不允许访问的，如 NULL，C 语言将无效指针赋值为 0 也是这个考虑\n\n\n动态链接库映射区\n动态链接库映射区用于映射装载的动态链接库。在 Linux 下，如果可执行文件依赖其它共享库，那么系统就会为它在从 0x40000000 开始的地址分配相应的空间，并将共享库载入该空间\n\n\n代码段\n存放程度运行的可执行指令集合\n\n\n初始化数据段\n也称为数据段，这里存放程序运行前已经完成初始化工作的字段\n\n\n未初始化数据段\n也称为 BSS 段，由内核进行最开始的默认初始化，存放的是程序中的全局变量和静态变量\n\n\n\n下图就是 Linux 下一个进程里典型的内存布局：\n\n🎶图中的箭头，标明了几个大小可变的尺寸增长的方向，当栈或堆现有的大小不够用的时候，它将按照图中的增长方向扩大自身的尺寸，直到预留的空间被用完为止。可以清晰地看出：栈式由高地址向低地址增长，堆是由低地址向高地址增长\n\n\n接下来简单介绍其中比较重要的几个组件\n¶代码段\n代码段中存放可执行的指令，存在程序内存的最底层，是为了保证不会因为堆栈溢出被覆盖（从上图可以看出）。\n通常来讲代码段是共享的，这样多次反复执行的指令只需要在内存中驻留一个副本即可，比如 C 编译器，文本编辑器等。代码段一般是只读的，程序执行时不能随意更改指令，也是为了进行隔离保护\n\n¶初始化数据段\n初始化数据段有时就称之为数据段。数据段是一个程序虚拟地址空间的一部分，包括全局变量和静态变量，这些变量在编程时就已经被初始化。数据段是可以修改的，不然程序运行时变量就无法改变了，这一点和代码段不同\n数据段可以细分为：初始化只读区和初始化读写区。这一点和编程中的一些特殊变量吻合。比如全局变量 int global n = 1 就被放在了初始化读写区，因为 global 是可以修改的。而 const int m = 2 就会被放在只读区\n\n¶未初始化数据段\n未初始化数据段有时称之为 BSS 段，BSS 是英文 Block Started by Symbol 的简称，BSS 段属于静态内存分配。存放在这里的数据都由内核进行零初始化。\n未初始化数据段（BSS）从初始化数据段的末尾开始存储，存放全部的全局变量和静态变量。比如 static int i; 或者全局 int j; 都会被放到 BSS 段\n\n¶栈\n栈是用来存储程序初期设定的变量的，这些变量在程序执行之前就要准备好。因此栈要放在程序内存的头部并且位置固定，否则程序就不知道该到那里去找这些变量。而程序的运行结果往往是不能预先确定的，所以把堆放在程序中内存的后部以便可以提供足够的内存保存运算结果。在经典的操作系统里，栈总是向下增长的\n在 i386 下，栈顶由称为 esp 的寄存器进行定位，压栈的操作使栈顶的地址减小，弹出的操作使栈顶地址增大，这里栈底的地址是 0xbffff，而 esp 寄存器标明了栈顶，地址为 0xbffff4，在栈上压入数据会导致 esp 减小，弹出数据使得 esp 增大\n\n\n👍栈在程序运行中具有举足轻重的地位，栈保存了一个函数调用所需要的维护信息，这常常被称为栈帧(Stack Frame)或活动记录(Activate Record)，栈帧一般包括如下几方面内容\n\n函数的返回地址和参数\n临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量\n保存的上下文：包括在函数调用前后需要保持不变的寄存器\n\n\n😣使用栈也会存在非常多缺点：\n\n不利于管理大内存（尤其在 16 位和 32 位时代）\n变量的生命周期难于控制（栈内的有效数据通常是连续存储的，所以 pop 时后申请的内存必须早于先申请的内存失效，否则将出现出栈再入栈的情况）\n\n\n📓栈不利于动态地管理并且有效地利用宝贵的内存资源，于时才有了堆，在堆上进行内存管理\n\n¶堆\n❓这里说的堆和数据结构中的堆有什么关系？\n在进程内存中，使用堆表示分配的一系列内存，而在数据结构中，堆则表示一种特定的数据结构，这两者没有必然的联系，内存中的堆更像是一种线性表结构\nSeveral authors began about 1975 to call the pool of available memory a “heap.” But in the present series of books, we will use that word only in its more traditional sense related to priority queues. (Fundamental Algorithms, 3rd ed., p. 435)\nStackOverflow 回答What is the origin of the term heap\" for the free store?\"\n❓为什么需要堆?\n光有栈，对于面向过程的程序设计还远远不够，因为栈上的数据在函数返回的时候就会被释放掉，所以无法将数据传递至函数外部；并且全局变量没有办法动态地产生，只能在编译的时候定义，很多情况下缺乏表现力，在这种情况下，堆（Heap）是一种唯一的选择\n\n堆是一款巨大的内存空间，常常占据整个虚拟空间的绝大部分，在这片空间里，程序可以请求一块连续的内存，并自由地使用，这块内存在程序主动放弃之前都活一直保持有效。\n下面是一个申请堆空间最简单的例子：\n123456int main()&#123;    char* p = (char*) malloc(1024);    free(p);    return 0;&#125;\n在第 3 行用 malloc 申请了 1024 个字节的空间之后，程序可以自由地使用这 233 个字节，直到程序用 free 函数释放它\n\n❓malloc到底是怎么实现的尼？\n\n\n一种做法是：把进程的内存管理交给操作系统内核去做。当然这是一种理论上可行的做法，但实际上这样做的性能比较差，原因在于每次程序申请或者释放堆空间都需要进行系统调用。系统调用的性能开销是很大的，当程序对堆的操作比较频繁时，这样做的结果是会严重影响程序的性能的\n\n\n比较好的做法就是：程序向操作系统申请一块适当大小的堆空间，然后由程序自己管理这块空间，而具体来讲，管理着堆空间分配的往往是程序的运行库\n\n\n\n相对于栈，堆内存面临着一个稍微复杂的行为模式：在任意时刻，程序可能发出请求，要么申请一段内存，要么释放一段已经申请过的内存，而且申请的大小从几个字节到数 GB 都是有可能的，我们不能假设程序会一次申请多少堆空间，因此，堆的管理显得较为复杂\n¶堆栈疑问\n本小节主要记录我对程序内存中堆栈存在的诸多问题\n❓为什么要将堆和栈区分出来？\n\n从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰，这种隔离、模块化的思想在软件设计的方方面面都有体现\n堆栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间\n栈是运行时需要的，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能不断增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可\n面向对象就是堆和栈的完美结合。面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑\n\n\n❓不能全用堆或者全用栈吗？\n  栈用先进后出的方式，读写速度高，这是针对它的长度固定的特征设计出来的。而堆为了保持可扩张的特性，也设计了类似于二叉树的索引方式，以便可以高速地寻址，并可以方便地释放内存空间\n其实栈只是一种数据结构，是一种限定仅在表尾进行插入和删除操作的线性表。现代 CPU 体系结构决定了栈是管理函数调用和局部变量的最佳数据结构，所以现代操作系统中常用栈管理函数的调用\n但是由于栈的缺点，就使得内存管理时我们不能单独使用栈（只使用栈不好管理内存）或者只使用堆（只使用堆不好进行方法调用管理），所以基于此，才分成了内存的堆栈管理，让专业的人去做专业的事\n\n❓在 Java 语言中，堆中存什么？栈中存什么？\n堆中存的是对象，栈中存的是基本数据类型和堆中对象的引用。一个对象的大小是不可估计的，或者说是可以动态变化的，但是在栈中，一个对象只对应了一个 4btye 的引用，当然在某些情况下，栈中也可以存复杂对象\n\n❓那么为什么在 Java 中不将所有的东西都放在堆中，而是一部分数据放在堆中？\n因为基本数据类型占用的空间一般是1~8个字节，需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义的（还会浪费空间，后面说明）。可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据。最常见的一个问题就是，Java 中参数传递时的问题。\n¶Linux 进程堆管理\nLinux 系统下，通过两个系统调用提供对堆空间进行分配：brk() 系统调用 和 mmap() 系统调用，这两种方式分配的都是虚拟内存，没有分配物理内存，在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系\n在标准 C 库中，提供了 malloc/free 函数分配释放内存，这两个函数底层是由 brk，mmap，munmap 这些系统调用实现的\n¶brk()系统调用\nC 语言形式声明：\n1int brk() &#123;void* end_data_segment;&#125;\nbrk() 的作用是设置进程数据段的结束地址，即它可以扩大或者缩小数据段（Linux 下数据段和 BBS 合并在一起统称数据段），如果将数据段的结束地址向高地址移动，那么扩大的那部分空间就可以被程序使用，把这块空间拿过来使用作为堆空间是最常见的做法\n¶mmap()系统调用\n和 Windows 系统下的 VirtualAlloc 相似，mmap() 的作用就是向操作系统申请一段虚拟地址空间，（堆和栈中间，称为文件映射区域的地方）这块虚拟地址空间可以映射到某个文件。\nglibc 的 malloc 函数是这样处理用户的空间请求的：对于小于 128KB 的请求来说，它会在现有的堆空间里面，按照堆分配算法为它分配一块空间并返回；对于大于 128KB 的请求来说，它会使用 mmap() 函数为它分配一块匿名空间，然后在这个匿名空间中为用户分配空间。\n下面就是 mmap() 系统调用原型：\n1void* mmap ( void* start ; size_t length ; int prot ; int flags ; int fd ; off_t offset ;)\nmmap 前两个参数分别用于指定需要申请的空间的起始地址和长度，如果起始地址设置 0，那么 Linux 系统会自动挑选合适的起始地址。prot/flags 参数：用于设置申请的空间的权限（可读，可写，可执行）以及映射类型（文件映射，匿名空间等）。最后两个参数用于文件映射时指定的文件描述符和文件偏移的\n¶堆分配算法\n本文简单介绍在 Linux 中的堆分配算法\n¶空闲链表法\n将堆中各个空闲的块按照链表的方式连接起来，当用户请求一块空间的时候，可以遍历整个列表，直到找到合适大小的块并且将它拆分；当用户释放空间的时候将它合并到空闲链表中。空闲链表是这样一种结构，在堆里的每一个空闲空间的开头(或结尾)有一个头 (header)，头结构里记录了上一个 (prev) 和下一个 (next) 空闲块的地址，也就是说，所有的空闲块形成了一个链表。如图所示\n\n\n¶位图法\n针对空闲链表的弊端，另一种分配方式显得更加稳健，这种方式称为位图（Bitmap）。\n位图的核心思路是将整个堆划分为大量的块(block)，每个块的大小相同，当用户请求内存的时候，总是分配整数个块的空间给用户，第一个块我们称为已分配区域的头(Head)，其余的称为己分配区域的主体(Body)，而我们可以使用一个整数数组来记录块的使用情况，由于每个块只有头/主体/空闲三种状态，仅仅需要两位即可表示一个块，因此称为位图\n\n¶对象池\n还有一种分配方法是对象池，也是将堆空间分成了大小相等的一些块，它认为某些场合每次分配的空间都相等，所以每次就直接返回一个块的大小，它的管理方法可以是链表也可以是位图。因为不用每次查找合适的大小的内存返回，所以效率很高。\n\n¶总结\n📓实际上很多现实应用中，堆的分配算法往往是采取多种算法复合而成的，比如对于 glibc 来说，它对于小于 64 字节的空间申请是采用类似于对象池的方法；而对于大于 512 字节的空间申请采用的是最佳适配算法；对于大于 64 字节而小于 512 字节的，它会根据情况采取上述方法中的最佳折中策略；对于大于 128KB 的申请，它会使用 mmap 机制直接向操作系统申请空间\n\n¶附录\n进程的内存结构（以 Java 为例）\n浅谈程序的内存布局\n进程结构和内存布局\n为什么要把堆和栈区分出来呢？\n为什么要有堆区和栈区呢？\n为什么要有堆内存和栈内存之分？\n内存为什么要分堆栈在编程里，要是全部只用堆或者全部只用栈，可行吗？\n","dateCreated":"2021-11-18T14:30:34+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2021-11-18T14:30:34+00:00","description":"本文讲解进程的内存布局","headline":"程序的内存布局","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/","keywords":"操作系统"}</script><meta name="description" content="本文讲解进程的内存布局"><meta property="og:type" content="blog"><meta property="og:title" content="程序的内存布局"><meta property="og:url" content="https://pineapple-man.github.io/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="本文讲解进程的内存布局"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/v2-d208651aa87138e6291d789b3a880444_720w.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/processMem.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/%E7%A8%8B%E5%BA%8F%E6%A0%88%E5%AE%9E%E4%BE%8B.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95.png"><meta property="article:published_time" content="2021-11-18T14:30:34.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.003Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="操作系统"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/v2-d208651aa87138e6291d789b3a880444_720w.jpg"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">程序的内存布局</h1><div class="post-meta"><time datetime="2021-11-18T14:30:34+00:00">11月 18, 2021 </time><span>发布在 </span><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 4.7k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 43 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-text">应用程序的内存空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="toc-text">代码段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="toc-text">初始化数据段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="toc-text">未初始化数据段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-text">堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E7%96%91%E9%97%AE"><span class="toc-text">堆栈疑问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E8%BF%9B%E7%A8%8B%E5%A0%86%E7%AE%A1%E7%90%86"><span class="toc-text">Linux 进程堆管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#brk-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">brk()系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">mmap()系统调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-text">堆分配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95"><span class="toc-text">空闲链表法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E5%9B%BE%E6%B3%95"><span class="toc-text">位图法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="toc-text">对象池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol><h2 id="应用程序的内存空间"><a class="header-anchor" href="#应用程序的内存空间">¶</a>应用程序的内存空间</h2><div class="alert success no-icon"><p>每个进程所看到的内存其实是操作系统虚拟出来的，称为逻辑地址空间。这个逻辑地址最终要通过寻址过程翻译成实际的物理地址进行内存访问。这个物理地址可以是内存中的内核区地址、也可以是用户区、也可以是硬盘上的 Swap 区</p></div><p>✨一般而言，应用程序使用的内存空间里有如下<strong>默认</strong>的区域：</p><table><thead><tr><th style="text-align:center">区域</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">栈</td><td style="text-align:center">栈用于维护函数调用的上下文，没有栈，函数调用就无法实现，栈通常在用户空间的最高地址处分配，一般有数兆字节的大小</td></tr><tr><td style="text-align:center">堆</td><td style="text-align:center">堆用来容纳应用程序动态分配的内存区域，当程序使用 <code>malloc</code> 或者 <code>new</code> 分配内存的时候，得到的内存来自堆。堆通常存在于栈的下方（低地址方向），某些时候，堆也可能没有固定统一的存储区域，堆一般比栈大很多，可以有几十至数百兆字节的容量</td></tr><tr><td style="text-align:center">可执行文件映像</td><td style="text-align:center">存储着可执行文件在内存里的映像，由装载器在装载时将可执行文件的内存读取或映射到这里</td></tr><tr><td style="text-align:center">保留区</td><td style="text-align:center">保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称：例如大多数操作系统中，<strong>极小的地址通常都是不允许访问的</strong>，如 <code>NULL</code>，C 语言将无效指针赋值为 0 也是这个考虑</td></tr><tr><td style="text-align:center">动态链接库映射区</td><td style="text-align:center">动态链接库映射区用于映射装载的动态链接库。在 Linux 下，如果可执行文件依赖其它共享库，那么系统就会为它在从 <code>0x40000000</code> 开始的地址分配相应的空间，并将共享库载入该空间</td></tr><tr><td style="text-align:center">代码段</td><td style="text-align:center">存放程度运行的可执行指令集合</td></tr><tr><td style="text-align:center">初始化数据段</td><td style="text-align:center">也称为数据段，这里存放程序运行前已经完成初始化工作的字段</td></tr><tr><td style="text-align:center">未初始化数据段</td><td style="text-align:center">也称为 <code>BSS</code> 段，由内核进行最开始的默认初始化，存放的是程序中的全局变量和静态变量</td></tr></tbody></table><p>下图就是 Linux 下一个进程里典型的内存布局：</p><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/v2-d208651aa87138e6291d789b3a880444_720w.jpg" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/v2-d208651aa87138e6291d789b3a880444_720w.jpg" alt=""></a></div><div class="alert info no-icon"><p>🎶图中的箭头，标明了几个大小可变的尺寸增长的方向，当栈或堆现有的大小不够用的时候，它将按照图中的增长方向扩大自身的尺寸，直到预留的空间被用完为止。可以清晰地看出：<strong>栈式由高地址向低地址增长，堆是由低地址向高地址增长</strong></p></div><div class="figure fig-100"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/processMem.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/processMem.png" alt=""></a></div><p>接下来简单介绍其中比较重要的几个组件</p><h3 id="代码段"><a class="header-anchor" href="#代码段">¶</a>代码段</h3><p>代码段中存放可执行的指令，存在程序内存的最底层，是为了保证不会因为堆栈溢出被覆盖（从上图可以看出）。</p><div class="alert success no-icon"><p>通常来讲代码段是共享的，这样多次反复执行的指令只需要在内存中驻留一个副本即可，比如 C 编译器，文本编辑器等。代码段一般是只读的，程序执行时不能随意更改指令，也是为了进行隔离保护</p></div><h3 id="初始化数据段"><a class="header-anchor" href="#初始化数据段">¶</a>初始化数据段</h3><p>初始化数据段有时就称之为数据段。数据段是一个程序虚拟地址空间的一部分，包括全局变量和静态变量，这些变量在编程时就已经被初始化。数据段是可以修改的，不然程序运行时变量就无法改变了，这一点和代码段不同</p><div class="alert warning no-icon"><p>数据段可以细分为：<strong>初始化只读区</strong>和<strong>初始化读写区</strong>。这一点和编程中的一些特殊变量吻合。比如全局变量 <code>int global n = 1</code> 就被放在了初始化读写区，因为 <code>global</code> 是可以修改的。而 <code>const int m = 2</code> 就会被放在只读区</p></div><h3 id="未初始化数据段"><a class="header-anchor" href="#未初始化数据段">¶</a>未初始化数据段</h3><p>未初始化数据段有时称之为 BSS 段，BSS 是英文 <code>Block Started by Symbol</code> 的简称，BSS 段属于静态内存分配。存放在这里的数据都由内核进行零初始化。</p><div class="alert warning no-icon"><p>未初始化数据段（BSS）从初始化数据段的末尾开始存储，存放全部的全局变量和静态变量。比如 static int i; 或者全局 int j; 都会被放到 BSS 段</p></div><h3 id="栈"><a class="header-anchor" href="#栈">¶</a>栈</h3><p>栈是用来存储程序初期设定的变量的，这些变量在程序执行之前就要准备好。因此栈要放在程序内存的头部并且位置固定，否则程序就不知道该到那里去找这些变量。而程序的运行结果往往是不能预先确定的，所以把堆放在程序中内存的后部以便可以提供足够的内存保存运算结果。在经典的操作系统里，栈总是向下增长的</p><div class="alert warning no-icon"><p>在 i386 下，栈顶由称为 esp 的寄存器进行定位，压栈的操作使栈顶的地址减小，弹出的操作使栈顶地址增大，这里栈底的地址是 <code>0xbffff</code>，而 esp 寄存器标明了栈顶，地址为 <code>0xbffff4</code>，在栈上压入数据会导致 esp 减小，弹出数据使得 esp 增大</p></div><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/程序栈实例.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/程序栈实例.png" alt=""></a></div><p>👍栈在程序运行中具有举足轻重的地位，栈保存了一个函数调用所需要的维护信息，这常常被称为栈帧(Stack Frame)或活动记录(Activate Record)，栈帧一般包括如下几方面内容</p><div class="alert success no-icon"><ul><li>函数的返回地址和参数</li><li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量</li><li>保存的上下文：包括在函数调用前后需要保持不变的寄存器</li></ul></div><p>😣使用栈也会存在非常多缺点：</p><div class="alert success no-icon"><ul><li>不利于管理大内存（尤其在 16 位和 32 位时代）</li><li>变量的生命周期难于控制（栈内的有效数据通常是连续存储的，所以 pop 时后申请的内存必须早于先申请的内存失效，否则将出现出栈再入栈的情况）</li></ul></div><div class="alert info no-icon"><p>📓栈不利于动态地管理并且有效地利用宝贵的内存资源，于时才有了堆，在堆上进行内存管理</p></div><h3 id="堆"><a class="header-anchor" href="#堆">¶</a>堆</h3><p>❓这里说的堆和数据结构中的堆有什么关系？</p><p>在进程内存中，使用堆表示分配的一系列内存，而在数据结构中，堆则表示一种特定的数据结构，这两者没有必然的联系，内存中的堆更像是一种线性表结构</p><blockquote><p>Several authors began about 1975 to call the pool of available memory a “heap.” But in the present series of books, we will use that word only in its more traditional sense related to priority queues. (Fundamental Algorithms, 3rd ed., p. 435)</p><footer><strong>StackOverflow 回答</strong><cite><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/660855/what-is-the-origin-of-the-term-heap-for-the-free-store">What is the origin of the term heap" for the free store?"</a></cite></footer></blockquote><p>❓为什么需要堆?</p><div class="alert success no-icon"><p>光有栈，对于面向过程的程序设计还远远不够，因为栈上的数据在函数返回的时候就会被释放掉，所以无法将数据传递至函数外部；并且全局变量没有办法动态地产生，只能在编译的时候定义，很多情况下缺乏表现力，在这种情况下，堆（Heap）是一种唯一的选择</p></div><p>堆是一款巨大的内存空间，常常占据整个虚拟空间的绝大部分，在这片空间里，程序可以请求一块连续的内存，并自由地使用，这块内存在程序主动放弃之前都活一直保持有效。</p><div class="alert warning no-icon"><p>下面是一个申请堆空间最简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* p = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第 3 行用 <code>malloc</code> 申请了 1024 个字节的空间之后，程序可以自由地使用这 233 个字节，直到程序用 free 函数释放它</p></div><p>❓<code>malloc</code>到底是怎么实现的尼？</p><div class="alert success no-icon"><ul><li><p>一种做法是：把进程的内存管理交给操作系统内核去做。当然这是一种理论上可行的做法，但实际上这样做的性能比较差，原因在于每次程序申请或者释放堆空间都需要进行系统调用。系统调用的性能开销是很大的，当程序对堆的操作比较频繁时，这样做的结果是会严重影响程序的性能的</p></li><li><p><strong>比较好的做法就是：程序向操作系统申请一块适当大小的堆空间，然后由程序自己管理这块空间，而具体来讲，管理着堆空间分配的往往是程序的运行库</strong></p></li></ul></div><p>相对于栈，堆内存面临着一个稍微复杂的行为模式：在任意时刻，程序可能发出请求，要么申请一段内存，要么释放一段已经申请过的内存，而且申请的大小从几个字节到数 GB 都是有可能的，我们不能假设程序会一次申请多少堆空间，因此，堆的管理显得较为复杂</p><h3 id="堆栈疑问"><a class="header-anchor" href="#堆栈疑问">¶</a>堆栈疑问</h3><p>本小节主要记录我对程序内存中堆栈存在的诸多问题<br>❓为什么要将堆和栈区分出来？</p><div class="alert success no-icon"><ul><li>从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰，这种隔离、模块化的思想在软件设计的方方面面都有体现</li><li>堆栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间</li><li>栈是运行时需要的，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能不断增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可</li><li>面向对象就是堆和栈的完美结合。面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑</li></ul></div><p>❓不能全用堆或者全用栈吗？</p><div class="alert success no-icon"><p>栈用先进后出的方式，读写速度高，这是针对它的长度固定的特征设计出来的。而堆为了保持可扩张的特性，也设计了类似于二叉树的索引方式，以便可以高速地寻址，并可以方便地释放内存空间</p><p>其实栈只是一种数据结构，是一种限定仅在表尾进行插入和删除操作的线性表。现代 CPU 体系结构决定了栈是管理函数调用和局部变量的最佳数据结构，所以现代操作系统中常用栈管理函数的调用</p><p>但是由于栈的缺点，就使得内存管理时我们不能单独使用栈（只使用栈不好管理内存）或者只使用堆（只使用堆不好进行方法调用管理），所以基于此，才分成了内存的堆栈管理，让专业的人去做专业的事</p></div><p>❓在 Java 语言中，堆中存什么？栈中存什么？</p><div class="alert success no-icon"><p>堆中存的是对象，栈中存的是基本数据类型和堆中对象的引用。一个对象的大小是不可估计的，或者说是可以动态变化的，但是在栈中，一个对象只对应了一个 4btye 的引用，当然在某些情况下，栈中也可以存复杂对象</p></div><p>❓那么为什么在 Java 中不将所有的东西都放在堆中，而是一部分数据放在堆中？</p><p>因为基本数据类型占用的空间一般是<code>1~8</code>个字节，需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义的（还会浪费空间，后面说明）。可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据。最常见的一个问题就是，Java 中参数传递时的问题。</p><h2 id="Linux-进程堆管理"><a class="header-anchor" href="#Linux-进程堆管理">¶</a>Linux 进程堆管理</h2><p>Linux 系统下，通过两个系统调用提供对堆空间进行分配：<code>brk()</code> 系统调用 和 <code>mmap()</code> 系统调用，这两种方式分配的都是<strong>虚拟内存</strong>，没有分配物理内存，在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系</p><p>在标准 C 库中，提供了 <code>malloc/free</code> 函数分配释放内存，这两个函数底层是由 <code>brk</code>，<code>mmap</code>，<code>munmap</code> 这些系统调用实现的</p><h3 id="brk-系统调用"><a class="header-anchor" href="#brk-系统调用">¶</a><code>brk()</code>系统调用</h3><p>C 语言形式声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">brk</span><span class="params">()</span> </span>&#123;<span class="type">void</span>* end_data_segment;&#125;</span><br></pre></td></tr></table></figure><p><code>brk()</code> 的作用是设置进程数据段的结束地址，即它可以扩大或者缩小数据段（Linux 下数据段和 BBS 合并在一起统称数据段），如果将数据段的结束地址向高地址移动，那么扩大的那部分空间就可以被程序使用，把这块空间拿过来使用作为堆空间是最常见的做法</p><h3 id="mmap-系统调用"><a class="header-anchor" href="#mmap-系统调用">¶</a><code>mmap()</code>系统调用</h3><p>和 Windows 系统下的 VirtualAlloc 相似，<code>mmap()</code> 的作用就是向操作系统申请一段虚拟地址空间，（堆和栈中间，称为文件映射区域的地方）这块虚拟地址空间可以映射到某个文件。</p><p>glibc 的 malloc 函数是这样处理用户的空间请求的：对于小于 128KB 的请求来说，它会在现有的堆空间里面，按照堆分配算法为它分配一块空间并返回；对于大于 128KB 的请求来说，它会使用 mmap() 函数为它分配一块匿名空间，然后在这个匿名空间中为用户分配空间。</p><p>下面就是 <code>mmap()</code> 系统调用原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mmap</span> <span class="params">( <span class="type">void</span>* start ; <span class="type">size_t</span> length ; <span class="type">int</span> prot ; <span class="type">int</span> flags ; <span class="type">int</span> fd ; <span class="type">off_t</span> offset ;)</span></span></span><br></pre></td></tr></table></figure><p>mmap 前两个参数分别用于指定需要申请的空间的起始地址和长度，如果起始地址设置 0，那么 Linux 系统会自动挑选合适的起始地址。<code>prot/flags</code> 参数：用于设置申请的空间的权限（可读，可写，可执行）以及映射类型（文件映射，匿名空间等）。最后两个参数用于文件映射时指定的文件描述符和文件偏移的</p><h2 id="堆分配算法"><a class="header-anchor" href="#堆分配算法">¶</a>堆分配算法</h2><p>本文简单介绍在 Linux 中的堆分配算法</p><h3 id="空闲链表法"><a class="header-anchor" href="#空闲链表法">¶</a>空闲链表法</h3><div class="alert success no-icon"><p>将堆中各个空闲的块按照链表的方式连接起来，当用户请求一块空间的时候，可以遍历整个列表，直到找到合适大小的块并且将它拆分；当用户释放空间的时候将它合并到空闲链表中。空闲链表是这样一种结构，在堆里的每一个空闲空间的开头(或结尾)有一个头 (header)，头结构里记录了上一个 (prev) 和下一个 (next) 空闲块的地址，也就是说，所有的空闲块形成了一个链表。如图所示</p></div><div class="figure fig-100 center"><a class="fancybox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/空闲链表法.png" data-caption="" data-fancybox="default"><img class="fig-img" src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/空闲链表法.png" alt=""></a></div><h3 id="位图法"><a class="header-anchor" href="#位图法">¶</a>位图法</h3><p>针对空闲链表的弊端，另一种分配方式显得更加稳健，这种方式称为<strong>位图</strong>（<code>Bitmap</code>）。</p><div class="alert success no-icon"><p>位图的核心思路是将整个堆划分为大量的块(block)，每个块的大小相同，当用户请求内存的时候，总是分配整数个块的空间给用户，第一个块我们称为已分配区域的头(Head)，其余的称为己分配区域的主体(Body)，而我们可以使用一个整数数组来记录块的使用情况，由于每个块只有头/主体/空闲三种状态，仅仅需要两位即可表示一个块，因此称为位图</p></div><h3 id="对象池"><a class="header-anchor" href="#对象池">¶</a>对象池</h3><div class="alert success no-icon"><p>还有一种分配方法是<strong>对象池</strong>，也是将堆空间分成了大小相等的一些块，它认为某些场合每次分配的空间都相等，所以每次就直接返回一个块的大小，它的管理方法可以是链表也可以是位图。因为不用每次查找合适的大小的内存返回，所以效率很高。</p></div><h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3><div class="alert info no-icon"><p>📓实际上很多现实应用中，堆的分配算法往往是采取多种算法复合而成的，比如对于 glibc 来说，它对于小于 64 字节的空间申请是采用类似于对象池的方法；而对于大于 512 字节的空间申请采用的是最佳适配算法；对于大于 64 字节而小于 512 字节的，它会根据情况采取上述方法中的最佳折中策略；对于大于 128KB 的申请，它会使用 mmap 机制直接向操作系统申请空间</p></div><h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2><p><a target="_blank" rel="noopener" href="https://fengyuanblog.github.io/2019/09/27/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84(%E4%BB%A5Java%E4%B8%BA%E4%BE%8B)/#%E4%B8%80%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">进程的内存结构（以 Java 为例）</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/77122692">浅谈程序的内存布局</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jingyg/p/5069964.html">进程结构和内存布局</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/05b4830a0010">为什么要把堆和栈区分出来呢？</a><br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/49927441">为什么要有堆区和栈区呢？</a><br><a target="_blank" rel="noopener" href="http://bbs.itheima.com/thread-101682-1-1.html">为什么要有堆内存和栈内存之分？</a><br><a target="_blank" rel="noopener" href="https://wukong.toutiao.com/answer/6814034541213122828/">内存为什么要分堆栈在编程里，要是全部只用堆或者全部只用栈，可行吗？</a></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/eureka-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-tooltip="Eureka 学习笔记" aria-label="上一篇: Eureka 学习笔记"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/" data-tooltip="虚拟化技术概述" aria-label="下一篇: 虚拟化技术概述"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/eureka-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-tooltip="Eureka 学习笔记" aria-label="上一篇: Eureka 学习笔记"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/" data-tooltip="虚拟化技术概述" aria-label="下一篇: 虚拟化技术概述"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>