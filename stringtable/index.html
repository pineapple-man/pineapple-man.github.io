<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>StringTable - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="StringTable"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n¶String 基本特性\n✨ String类具有如下基本特性：\n\nString 表示字符串，使用一对&quot;&quot;引起来表示\n声明为final，不可被继承\nString 实现了 Serializable 接口支持序列化\nString 实现了 Comparable 接口支持比较大小\nString 在 JDK8 及以前内部定义了final char[] value用于存储字符串数据；JDK9 时改为byte[]\n\n\nString：代表不可变的字符序列，简称：不可变性\n\n当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的 value 进行赋值\n当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值\n当调用 string 的 replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值\n\n\n12345678910111213141516public class StringTest &#123;   String str = new String(&quot;good&quot;);   char[] ch = &#123;&#x27;t&#x27;, &#x27;e&#x27;, &#x27;s&#x27;, &#x27;t&#x27;&#125;;   public void change(String str, char ch[]) &#123;      str = &quot;test ok&quot;;      ch[0] = &#x27;b&#x27;;   &#125;   public static void main(String[] args) &#123;      StringTest stringTest = new StringTest();      stringTest.change(stringTest.str, stringTest.ch);      System.out.println(stringTest.str);//good      System.out.println(stringTest.ch);//best   &#125;&#125;\n🎶 String 传参数时可以当作基本数据类型使用，对基本数据类型的包装类因此也会被当作基本数据类型使用\n\n通过字面量的方式（区别于 new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。字符串常量池保证不会存储相同内容的字符串\nString 的 String Pool 是一个固定大小的 Hashtable，默认值大小长度是 1009。如果放进 String Pool 的 String 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降，使用-XX:StringTablesize可设置 StringTable 的长度\n\n在 jdk6 中 StringTable 是固定的，就是 1009 的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTablesize 设置没有要求\n在 jdk7 中，StringTable 的长度默认值是 60013，StringTablesize 设置没有要求\n在 JDK8 中，设置 StringTable 长度的话，1009 是可以设置的最小值\n\n\n¶String 存储结构变更\n在 JDK 9 及以后，将底层的char[]转变为byte[]\n¶Motivation\nThe current implementation of the String class stores characters in a char array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused.\nJSR官方文档\n目前 String 类的实现将字符存储在一个char数组中，每个字符使用两个字节（16 位），从许多不同的应用中收集到的数据表明，字符串是堆使用的主要组成部分，此外，大多数字符串对象只包含 Latin-1 字符，这些字符只需要一个字节的存储空间，因此这些字符串对象的内部字符数组中有一半空间是浪费的\n¶Description\nWe propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field. The new String class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.\nString-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM’s intrinsic string operations.\nThis is purely an implementation change, with no changes to existing public interfaces. There are no plans to add any new public APIs or other interfaces.\nThe prototyping work done to date confirms the expected reduction in memory footprint, substantial reductions of GC activity, and minor performance regressions in some corner cases.\nJSR官方文档\n我们建议将 String 类的内部表示方法从UTF-16字符数组改为字节数组加编码标志域（编码标志将表明使用的是哪种编码）\n新的 String 类将根据字符串的内容，以ISO-8859-1/Latin-1（每个字符一个字节）或UTF-16（每个字符两个字节）的方式存储字符编码。\n与字符串相关的类，如AbstractStringBuilder、StringBuilder和StringBuffer将被更新以使用相同的表示方法，HotSpot VM 的内在字符串操作也是如此.\n这纯粹是一个实现上的变化，对现有的公共接口没有变化。目前没有计划增加任何新的公共 API 或其他接口,迄今为止所做的原型设计工作证实了内存占用的预期减少，GC 活动的大幅减少，以及在某些角落情况下的轻微性能倒退\n📓String 不再用char[] 存储改成了byte[] 加上编码标记，节约了一些空间\n12345public final class String implements java.io.Serializable,                        Comparable&lt;String&gt;, CharSequence &#123;    @Stable    private final byte[] value;&#125;\n¶String 的内存分配\n在 Java 语言中有 8 种基本数据类型和一种比较特殊的类型 String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念.常量池就类似一个 Java 系统级别提供的缓存，8 种基本数据类型的常量池都是系统协调的\n✨String 类型的常量池比较特殊，它的主要使用方法有两种：\n\n直接使用双引号声明的String对象会直接存储再常量池种\n如果不是用双引号声明的String对象，可以使用String提供的intern()方法\n\n\n¶String table 位置\nJdk6 及以前，字符串常量池存放在永久代\n\nJava 7 中 Oracle 的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到 Java 堆内\n\n所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了\n字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在 Java 7 中使用String.intern()\n\n\n\n🤔 StringTable 位置为什么要调整\nSynopsis: In JDK 7, interned strings are no longer allocated in the permanent generation of the Java heap, but are instead allocated in the main part of the Java heap (known as the young and old generations), along with the other objects created by the application. This change will result in more data residing in the main Java heap, and less data in the permanent generation, and thus may require heap sizes to be adjusted. Most applications will see only relatively small differences in heap usage due to this change, but larger applications that load many classes or make heavy use of the String.intern() method will see more significant differences.\nJSR官方文档\n简介：在 JDK 7 中，内部字符串不再分配在 Java 堆的永久代中，而是分配在 Java 堆的主要部分，与应用程序创建的其他对象一起。这种变化将导致更多的数据驻留在主 Java 堆中，而更少的数据在永久代中，因此可能需要调整堆的大小。大多数应用程序将看到由于这一变化而导致的堆使用的相对较小的差异，但加载许多类或大量使用 String.intern()方法的大型应用程序将看到更明显的差异\n¶字符串拼接操作\n\n常量与常量的拼接结果在常量池，原理是编译期优化\n常量池中不会存在相同内容的变量\n只要其中有一个是变量，结果就在堆中。变量拼接的原理是 StringBuilder\n如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址\n\n编译器优化的例子：\n12345678public static void test1() &#123;   // 都是常量，前端编译期会进行代码优化   // 通过idea直接看对应的反编译的class文件，会显示 String s1 = &quot;abc&quot;; 说明做了代码优化   String s1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;   String s2 = &quot;abc&quot;;   // true，有上述可知，s1和s2实际上指向字符串常量池中的同一个值   System.out.println(s1 == s2);&#125;\n变量与常量间的拼接操作\n123456789101112131415161718192021public static void test5() &#123;    String s1 = &quot;javaEE&quot;;    String s2 = &quot;hadoop&quot;;    String s3 = &quot;javaEEhadoop&quot;;    String s4 = &quot;javaEE&quot; + &quot;hadoop&quot;;    String s5 = s1 + &quot;hadoop&quot;;    String s6 = &quot;javaEE&quot; + s2;    String s7 = s1 + s2;    System.out.println(s3 == s4); // true 编译期优化    System.out.println(s3 == s5); // false s1是变量，不能编译期优化    System.out.println(s3 == s6); // false s2是变量，不能编译期优化    System.out.println(s3 == s7); // false s1、s2都是变量    System.out.println(s5 == s6); // false s5、s6 不同的对象实例    System.out.println(s5 == s7); // false s5、s7 不同的对象实例    System.out.println(s6 == s7); // false s6、s7 不同的对象实例    String s8 = s6.intern();    System.out.println(s3 == s8); // true intern之后，s8和s3一样，指向字符串常量池中的&quot;javaEEhadoop&quot;&#125;\n\n不实用 final 修饰，即为变量，如 s3 的求解，会通过 new StringBuilder 进行拼接\n使用final关键字修饰，最终变量退化为常量，会在编译器进行代码优化，在实际开发中，能够使用 final 的地方尽量使用\n\n123456789101112public void test6()&#123;    String s0 = &quot;beijing&quot;;    String s1 = &quot;bei&quot;;    String s2 = &quot;jing&quot;;    String s3 = s1 + s2;    System.out.println(s0 == s3); // false s3指向对象实例，s0指向字符串常量池中的&quot;beijing&quot;    String s7 = &quot;shanxi&quot;;    final String s4 = &quot;shan&quot;;    final String s5 = &quot;xi&quot;;    String s6 = s4 + s5;    System.out.println(s6 == s7); // true s4和s5是final修饰的，编译期就能确定s6的值了&#125;\n在大量的实验验证下，通过 StringBuilder 的 append 方式的速度，要比直接对 String 使用+拼接的方式快大约 8000 倍，比 StringBuffer 的 append 方法快 4 倍左右，在实际开发中，对于需要多次或大量拼接的操作，在不考虑线程安全问题时，我们就应该尽可能使用 StringBuilder 进行 append 操作。并且如果提前知道需要拼接 String 的个数，就应该直接使用带参构造器指定 capacity，以减少扩容次数\n¶inter()的使用\n当调用 intern 方法时，如果池子里已经包含了一个与这个 Strin·g 对象相等的字符串，正如 equals(Object)方法所确定的，那么池子里的字符串会被返回。否则，这个 String 对象被添加到池中，并返回这个 String 对象的引用\n由此可见，对于任何两个字符串 s 和 t，当且仅当 s.equals(t)为真时，s.intern() == t.intern()为真，所有字面字符串和以字符串为值的常量表达式都是interned，返回一个与此字符串内容相同的字符串，但保证是来自一个唯一的字符串池\n¶G1 的 String 去重操作\n123//需要s1、s2jString s1 = new String(&quot;hello&quot;);String s2 = new String(&quot;hello&quot;);\nstring 池子的操作，String s = new string(“hello world”)有几个对象生成，生成对象的 s 存放在哪里\n¶附录\nnew String(“123”) 创建了几个对象？\nString s=new String(“abc”)创建了几个对象?\n面试题之 String str = new String(“abc”); 创建了几个对象\n官方表名更改 String 源码原因\nJava 函数传参(String 的不可变性)\nStringTable 调整官方说明\nStringBuffer 和 StringBuilder 的区别\nString a=&quot;123&quot;创建对象个数问题\n","dateCreated":"2022-03-31T16:42:29+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2022-03-31T16:42:29+00:00","description":"字符串是一个特殊的结构，那么在 JVM 底层中，字符串到底是如何存储的？","headline":"StringTable","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/stringtable/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/stringtable/","keywords":"JVM"}</script><meta name="description" content="字符串是一个特殊的结构，那么在 JVM 底层中，字符串到底是如何存储的？"><meta property="og:type" content="blog"><meta property="og:title" content="StringTable"><meta property="og:url" content="https://pineapple-man.github.io/stringtable/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="字符串是一个特殊的结构，那么在 JVM 底层中，字符串到底是如何存储的？"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/imgjvm-stringtabl-jdk6.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/imgjvm-stringtable-jdk7.png"><meta property="article:published_time" content="2022-03-31T16:42:29.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.011Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="JVM"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/imgjvm-stringtabl-jdk6.png"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">StringTable</h1><div class="post-meta"><time datetime="2022-03-31T16:42:29+00:00">3月 31, 2022 </time><span>发布在 </span><a class="category-link" href="/categories/Java/">Java</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 2.9k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 30 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-text">String 基本特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%98%E6%9B%B4"><span class="toc-text">String 存储结构变更</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Motivation"><span class="toc-text">Motivation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Description"><span class="toc-text">Description</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">String 的内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-table-%E4%BD%8D%E7%BD%AE"><span class="toc-text">String table 位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">字符串拼接操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inter-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">inter()的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G1-%E7%9A%84-String-%E5%8E%BB%E9%87%8D%E6%93%8D%E4%BD%9C"><span class="toc-text">G1 的 String 去重操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol><h2 id="String-基本特性"><a class="header-anchor" href="#String-基本特性">¶</a>String 基本特性</h2><p>✨ <code>String</code>类具有如下基本特性：</p><div class="alert success no-icon"><ul><li>String 表示字符串，使用一对<code>&quot;&quot;</code>引起来表示</li><li>声明为<code>final</code>，不可被继承</li><li>String 实现了 Serializable 接口支持序列化</li><li>String 实现了 Comparable 接口支持比较大小</li><li>String 在 JDK8 及以前内部定义了<code>final char[] value</code>用于存储字符串数据；JDK9 时改为<code>byte[]</code></li></ul></div><p>String：代表不可变的字符序列，简称：<strong>不可变性</strong></p><div class="alert success no-icon"><ul><li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的 value 进行赋值</li><li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值</li><li>当调用 string 的 replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值</li></ul></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">   <span class="type">char</span>[] ch = &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> &#123;</span><br><span class="line">      str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">      ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">StringTest</span> <span class="variable">stringTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTest</span>();</span><br><span class="line">      stringTest.change(stringTest.str, stringTest.ch);</span><br><span class="line">      System.out.println(stringTest.str);<span class="comment">//good</span></span><br><span class="line">      System.out.println(stringTest.ch);<span class="comment">//best</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="alert info no-icon"><p>🎶 String 传参数时可以当作基本数据类型使用，对基本数据类型的包装类因此也会被当作基本数据类型使用</p></div><p>通过字面量的方式（区别于 new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。字符串常量池保证不会存储相同内容的字符串</p><p>String 的 String Pool 是一个固定大小的 Hashtable，默认值大小长度是 1009。如果放进 String Pool 的 String 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用<code>String.intern</code>时性能会大幅下降，使用<code>-XX:StringTablesize</code>可设置 StringTable 的长度</p><div class="alert success no-icon"><ul><li>在 jdk6 中 StringTable 是固定的，就是 1009 的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTablesize 设置没有要求</li><li>在 jdk7 中，StringTable 的长度默认值是 60013，StringTablesize 设置没有要求</li><li>在 JDK8 中，设置 StringTable 长度的话，1009 是可以设置的最小值</li></ul></div><h2 id="String-存储结构变更"><a class="header-anchor" href="#String-存储结构变更">¶</a>String 存储结构变更</h2><p>在 JDK 9 及以后，将底层的<code>char[]</code>转变为<code>byte[]</code></p><h3 id="Motivation"><a class="header-anchor" href="#Motivation">¶</a>Motivation</h3><blockquote><p>The current implementation of the <code>String</code> class stores characters in a <code>char</code> array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most <code>String</code> objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal <code>char</code> arrays of such <code>String</code> objects is going unused.</p><footer><strong>JSR官方文档</strong></footer></blockquote><p>目前 String 类的实现将字符存储在一个<code>char</code>数组中，<strong>每个字符使用两个字节</strong>（16 位），从许多不同的应用中收集到的数据表明，<strong>字符串是堆使用的主要组成部分</strong>，此外，<strong>大多数字符串对象只包含 Latin-1 字符</strong>，这些字符<strong>只需要一个字节的存储空间</strong>，因此这些字符串对象的内部字符数组中<strong>有一半空间是浪费的</strong></p><h3 id="Description"><a class="header-anchor" href="#Description">¶</a>Description</h3><blockquote><p>We propose to change the internal representation of the <code>String</code> class from a UTF-16 <code>char</code> array to a <code>byte</code> array plus an encoding-flag field. The new <code>String</code> class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.</p><p>String-related classes such as <code>AbstractStringBuilder</code>, <code>StringBuilder</code>, and <code>StringBuffer</code> will be updated to use the same representation, as will the HotSpot VM’s intrinsic string operations.</p><p>This is purely an implementation change, with no changes to existing public interfaces. There are no plans to add any new public APIs or other interfaces.</p><p>The prototyping work done to date confirms the expected reduction in memory footprint, substantial reductions of GC activity, and minor performance regressions in some corner cases.</p><footer><strong>JSR官方文档</strong></footer></blockquote><p>我们建议将 String 类的内部表示方法从<code>UTF-16</code><strong>字符数组</strong>改为<strong>字节数组加编码标志域</strong>（编码标志将表明使用的是哪种编码）</p><p>新的 String 类将根据字符串的内容，以<code>ISO-8859-1/Latin-1</code>（每个字符一个字节）或<code>UTF-16</code>（每个字符两个字节）的方式存储字符编码。</p><p>与字符串相关的类，如<code>AbstractStringBuilder</code>、<code>StringBuilder</code>和<code>StringBuffer</code>将被更新以使用相同的表示方法，HotSpot VM 的内在字符串操作也是如此.</p><p>这纯粹是一个实现上的变化，对现有的公共接口没有变化。目前没有计划增加任何新的公共 API 或其他接口,迄今为止所做的原型设计工作证实了内存占用的预期减少，GC 活动的大幅减少，以及在某些角落情况下的轻微性能倒退</p><p>📓String 不再用<code>char[]</code> 存储改成了<code>byte[]</code>加上编码标记，节约了一些空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,</span><br><span class="line">                        Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String-的内存分配"><a class="header-anchor" href="#String-的内存分配">¶</a>String 的内存分配</h2><p>在 Java 语言中有 8 种基本数据类型和一种比较特殊的类型 String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念.常量池就类似一个 Java 系统级别提供的缓存，8 种基本数据类型的常量池都是系统协调的</p><p>✨String 类型的常量池比较特殊，它的主要使用方法有两种：</p><div class="alert success no-icon"><ul><li>直接使用双引号声明的<code>String</code>对象会直接存储再常量池种</li><li>如果不是用双引号声明的<code>String</code>对象，可以使用<code>String</code>提供的<code>intern()</code>方法</li></ul></div><h2 id="String-table-位置"><a class="header-anchor" href="#String-table-位置">¶</a>String table 位置</h2><p>Jdk6 及以前，字符串常量池存放在永久代</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/imgjvm-stringtabl-jdk6.png" alt=""></p><p>Java 7 中 Oracle 的工程师对字符串池的逻辑做了很大的改变，即<strong>将字符串常量池的位置调整到 Java 堆</strong>内</p><div class="alert success no-icon"><ul><li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了</li><li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在 Java 7 中使用<code>String.intern()</code></li></ul></div><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/imgjvm-stringtable-jdk7.png" alt=""></p><p>🤔 StringTable 位置为什么要调整</p><blockquote><p><strong>Synopsis:</strong> In JDK 7, interned strings are no longer allocated in the permanent generation of the Java heap, but are instead allocated in the main part of the Java heap (known as the young and old generations), along with the other objects created by the application. This change will result in more data residing in the main Java heap, and less data in the permanent generation, and thus may require heap sizes to be adjusted. Most applications will see only relatively small differences in heap usage due to this change, but larger applications that load many classes or make heavy use of the <code>String.intern()</code> method will see more significant differences.</p><footer><strong>JSR官方文档</strong></footer></blockquote><p>简介：在 JDK 7 中，内部字符串不再分配在 Java 堆的永久代中，而是分配在 Java 堆的主要部分，与应用程序创建的其他对象一起。这种变化将导致更多的数据驻留在主 Java 堆中，而更少的数据在永久代中，因此可能需要调整堆的大小。大多数应用程序将看到由于这一变化而导致的堆使用的相对较小的差异，<strong>但加载许多类或大量使用 String.intern()方法的大型应用程序将看到更明显的差异</strong></p><h2 id="字符串拼接操作"><a class="header-anchor" href="#字符串拼接操作">¶</a>字符串拼接操作</h2><ul><li>常量与常量的拼接结果在常量池，原理是编译期优化</li><li>常量池中不会存在相同内容的变量</li><li>只要其中有一个是变量，结果就在堆中。变量拼接的原理是 StringBuilder</li><li>如果拼接的结果调用<code>intern()</code>方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li></ul><p>编译器优化的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 都是常量，前端编译期会进行代码优化</span></span><br><span class="line">   <span class="comment">// 通过idea直接看对应的反编译的class文件，会显示 String s1 = &quot;abc&quot;; 说明做了代码优化</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">   <span class="comment">// true，有上述可知，s1和s2实际上指向字符串常量池中的同一个值</span></span><br><span class="line">   System.out.println(s1 == s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量与常量间的拼接操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">// true 编译期优化</span></span><br><span class="line">    System.out.println(s3 == s5); <span class="comment">// false s1是变量，不能编译期优化</span></span><br><span class="line">    System.out.println(s3 == s6); <span class="comment">// false s2是变量，不能编译期优化</span></span><br><span class="line">    System.out.println(s3 == s7); <span class="comment">// false s1、s2都是变量</span></span><br><span class="line">    System.out.println(s5 == s6); <span class="comment">// false s5、s6 不同的对象实例</span></span><br><span class="line">    System.out.println(s5 == s7); <span class="comment">// false s5、s7 不同的对象实例</span></span><br><span class="line">    System.out.println(s6 == s7); <span class="comment">// false s6、s7 不同的对象实例</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();</span><br><span class="line">    System.out.println(s3 == s8); <span class="comment">// true intern之后，s8和s3一样，指向字符串常量池中的&quot;javaEEhadoop&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不实用 final 修饰，即为变量，如 s3 的求解，会通过 new StringBuilder 进行拼接</li><li>使用<code>final</code>关键字修饰，最终变量退化为常量，会在编译器进行代码优化，在实际开发中，能够使用 final 的地方尽量使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="string">&quot;beijing&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;bei&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;jing&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    System.out.println(s0 == s3); <span class="comment">// false s3指向对象实例，s0指向字符串常量池中的&quot;beijing&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="string">&quot;shanxi&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;shan&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;xi&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s4 + s5;</span><br><span class="line">    System.out.println(s6 == s7); <span class="comment">// true s4和s5是final修饰的，编译期就能确定s6的值了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在大量的实验验证下，通过 StringBuilder 的 append 方式的速度，要比直接对 String 使用<code>+</code>拼接的方式快大约 8000 倍，比 StringBuffer 的 append 方法快 4 倍左右，在实际开发中，对于需要多次或大量拼接的操作，在不考虑线程安全问题时，我们就应该尽可能使用 StringBuilder 进行 append 操作。并且如果提前知道需要拼接 String 的个数，就应该直接使用带参构造器指定 capacity，以减少扩容次数</p><h2 id="inter-的使用"><a class="header-anchor" href="#inter-的使用">¶</a>inter()的使用</h2><p>当调用 intern 方法时，如果池子里已经包含了一个与这个 Strin·g 对象相等的字符串，正如 equals(Object)方法所确定的，那么池子里的字符串会被返回。否则，这个 String 对象被添加到池中，并返回这个 String 对象的引用</p><p>由此可见，对于任何两个字符串 s 和 t，当且仅当 s.equals(t)为真时，s.intern() == t.intern()为真，所有字面字符串和以字符串为值的常量表达式都是<code>interned</code>，返回一个与此字符串内容相同的字符串，但保证是来自一个唯一的字符串池</p><h2 id="G1-的-String-去重操作"><a class="header-anchor" href="#G1-的-String-去重操作">¶</a>G1 的 String 去重操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要s1、s2j</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>string 池子的操作，String s = new string(“hello world”)有几个对象生成，生成对象的 s 存放在哪里</p><h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/niceyoo/p/11100090.html">new String(“123”) 创建了几个对象？</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ydpvictor/archive/2012/09/09/2677260.html">String s=new String(“abc”)创建了几个对象?</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/limingchuan123456789/article/details/14150327">面试题之 String str = new String(“abc”); 创建了几个对象</a><br><a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/254">官方表名更改 String 源码原因</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32483145/article/details/81130562">Java 函数传参(String 的不可变性)</a><br><a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes">StringTable 调整官方说明</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/mad1989/article/details/26389541">StringBuffer 和 StringBuilder 的区别</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_27969827/article/details/79219708">String a=&quot;123&quot;创建对象个数问题</a></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/JVM/" rel="tag">JVM</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/happens-before-%E5%8E%9F%E5%88%99/" data-tooltip="Happens-Before 原则" aria-label="上一篇: Happens-Before 原则"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/c%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/" data-tooltip="C语言预处理命令" aria-label="下一篇: C语言预处理命令"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/happens-before-%E5%8E%9F%E5%88%99/" data-tooltip="Happens-Before 原则" aria-label="上一篇: Happens-Before 原则"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/c%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/" data-tooltip="C语言预处理命令" aria-label="下一篇: C语言预处理命令"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>