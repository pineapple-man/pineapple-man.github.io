<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>MySQL(四)简单查询语句流程 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="mysql"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n\n本文主要记录 MySQL 中的各种组件并介绍，一条简单的查询语句，究竟在 MySQL 中执行了哪些步骤\n\n¶逻辑架构\n下面给出的是 MySQL 的基本架构示意图，从中可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程\n\n大体而言，MySQL 可以分为 Server 层和存储引擎层两个部分：\n\n\nServer 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等\n\n\n存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎\n\n\n在执行 create table 健表的时候，如果不指定引擎类型，默认使用的是 InnoDB，也可以显示指定存储引擎的类型来选择别的引擎，比如在create table语句中使用 engine=memory，来指定使用内存引擎创建表。值得注意的是，不同存储引擎的表数据存取方式不同，支持的功能也不同。如此分隔的两部分设计，可以使得在更换底层存储引擎的实现时，上层的 Server 层是不感知的\n¶连接器\n使用 MySQL 的第一步，就是先连接到这个数据库上，此时 工作的组件就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。\n\n1mysql -h$ip -P$port -u$user -p\n连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，此时用的就是你输入的用户名和密码\n\n如果用户名或密码不对，你就会收到一个 Access denied for user 的错误，然后客户端程序结束执行\n如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限\n\n通过以上连接器的流程，一旦一个用户成功建立连接之后，即使随后管理员账号对这个用户的权限做了修改，也不会影响已经存在的连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。\n\n连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。下图是show processlist的结果，其中的Command列显示为Sleep的这一行，就表示现在系统里面有一个空闲连接\n\n客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。\n如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了\n数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个\n建立连接的过程通常是比较复杂的，所以最好在使用中尽量减少建立连接的动作，推荐尽量使用长连接；这也并不代表全部使用长连接，如果对于每一个请求都使用长连接，最终会出现 MySQL 占用内存飞速增加的情况。这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象中的。这些资源只有在连接断开时才会释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），最终表现的结果就是：MySQL 异常重启了\n\n❓ 如何解决 MySQL 长连接问题？\n\n定期断开长连接，使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连\n如果使用的是 MySQL 5.7 及以上版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态\n\n\n¶查询缓存\n连接建立完成后，就可以通过 mysql 客户端执行 select 语句，此时的执行逻辑就会来到第二步：查询缓存\n\nMySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。\n\n如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端;\n如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。\n\n\n❓ 但是大多数情况下，并不会建议使用查询缓存，并且在最新版中直接将查询缓存的整块功能删掉了，究竟是为什么？\n查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。\n\n¶分析器\n如果没有命中查询缓存，就要开始真正执行语句了。执行语句之前需要对 SQL 语句做解析\n\n分析器先会做「 词法分析 」，用户输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。随后，MySQL 将用户输入的 select 这个关键字识别出来，明白这是一个查询语句。接下来，它也要把字符串 T 识别成 表名T，把字符串 ID 识别成 列ID。\n做完以上识别以后，就要做「 语法分析 」。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。如果输入语句不对，就会收到 You have an error in your SQL syntax的错误提醒，比如下面这个语句select少打了开头的字母s。\n123mysql&gt; elect * from t where ID=1;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;elect * from t where ID=1&#x27; at line 1\n¶优化器\n经过分析器，MySQL 就知道用户要执行什么操作了。在开始执行之前，还要先经过优化器的处理。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：\n1mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;\n根据执行结果，有两种不同的执行的方式：\n\n既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20；\n也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10\n\n\n这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。\n¶执行器\nMySQL 通过分析器知道了要执行的语句，通过优化器知道了如何高效的执行对应的操作，于是就进入了执行器阶段，开始真正执行语句。\n\n开始执行的时候，首先先判断一下当前用户对表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示(在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)\n123mysql&gt; select * from T where ID=10;ERROR 1142 (42000): SELECT command denied to user &#x27;b&#x27;@&#x27;localhost&#x27; for table &#x27;T&#x27;\n如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。\n⛵ 比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：\n\n调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则执行步骤 2 ，如果是则将这行存在结果集中；\n调用引擎接口取「 下一行 」，重复相同的判断逻辑，直到取到这个表的最后一行;\n执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端\n\n\n通过以上三个步骤，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。第一次调用的是「 取满足条件的第一行 」这个接口，之后循环取「 满足条件的下一行 」这个接口，这些接口都是引擎中已经定义好的\n在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。然而并不能准确表示执行引擎扫描了多少行。这是因为，在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。\n¶总结\n以上就是 MySQL 的逻辑架构，希望通过本文你对一个 SQL 语句完整执行流程的各个阶段有了一个初步的印象，官网中给出 MySQL 的逻辑架构如下：\n\n","dateCreated":"2022-01-30T09:18:46+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2022-01-30T09:18:46+00:00","description":"本文主要记录 MySQL 中的各种组件，以及一条简单的查询语句，究竟在 MySQL 中执行了哪些步骤","headline":"MySQL(四)简单查询语句流程","image":["https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/mysql-%E5%9B%9B-%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%B5%81%E7%A8%8B/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/mysql-%E5%9B%9B-%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%B5%81%E7%A8%8B/","keywords":"MySQL","thumbnailUrl":"https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql.jpg"}</script><meta name="description" content="本文主要记录 MySQL 中的各种组件，以及一条简单的查询语句，究竟在 MySQL 中执行了哪些步骤"><meta property="og:type" content="blog"><meta property="og:title" content="MySQL(四)简单查询语句流程"><meta property="og:url" content="https://pineapple-man.github.io/mysql-%E5%9B%9B-%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%B5%81%E7%A8%8B/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="本文主要记录 MySQL 中的各种组件，以及一条简单的查询语句，究竟在 MySQL 中执行了哪些步骤"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql-showProcesslist.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E8%AF%A6%E7%BB%86.jpg"><meta property="article:published_time" content="2022-01-30T09:18:46.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.007Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="MySQL"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.png"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql.jpg"><meta class="swiftype" name="image" data-type="enum" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql.jpg"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">MySQL(四)简单查询语句流程</h1><div class="post-meta"><time datetime="2022-01-30T09:18:46+00:00">1月 30, 2022 </time><span>发布在 </span><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 2.9k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 27 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="toc-text">逻辑架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%99%A8"><span class="toc-text">连接器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-text">查询缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-text">分析器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-text">优化器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-text">执行器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol><blockquote><p>本文主要记录 MySQL 中的各种组件并介绍，一条简单的查询语句，究竟在 MySQL 中执行了哪些步骤</p></blockquote><h2 id="逻辑架构"><a class="header-anchor" href="#逻辑架构">¶</a>逻辑架构</h2><p>下面给出的是 MySQL 的基本架构示意图，从中可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程<br><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.png" alt=""></p><p>大体而言，MySQL 可以分为 Server 层和<strong>存储引擎层</strong>两个部分：</p><ul><li><p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等</p></li><li><p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎</p></li></ul><p>在执行 <code>create table</code> 健表的时候，如果不指定引擎类型，默认使用的是 <code>InnoDB</code>，也可以显示指定存储引擎的类型来选择别的引擎，比如在<code>create table</code>语句中使用 <code>engine=memory</code>，来指定使用内存引擎创建表。值得注意的是，不同存储引擎的表数据存取方式不同，支持的功能也不同。如此分隔的两部分设计，可以使得在更换底层存储引擎的实现时，上层的 Server 层是不感知的</p><h2 id="连接器"><a class="header-anchor" href="#连接器">¶</a>连接器</h2><div class="alert success no-icon"><p>使用 MySQL 的第一步，就是先连接到这个数据库上，此时 工作的组件就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。</p></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h$ip <span class="operator">-</span>P$port <span class="operator">-</span>u$<span class="keyword">user</span> <span class="operator">-</span>p</span><br></pre></td></tr></table></figure><p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，此时用的就是你输入的用户名和密码</p><ul><li>如果用户名或密码不对，你就会收到一个 <code>Access denied for user</code> 的错误，然后客户端程序结束执行</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限</li></ul><div class="alert info no-icon"><p>通过以上连接器的流程，一旦一个用户成功建立连接之后，即使随后管理员账号对这个用户的权限做了修改，也不会影响已经存在的连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p></div><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 <code>show processlist</code> 命令中看到它。下图是<code>show processlist</code>的结果，其中的<code>Command</code>列显示为<code>Sleep</code>的这一行，就表示现在系统里面有一个空闲连接</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql-showProcesslist.png" alt=""></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。</p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了</p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个</p><div class="alert info no-icon"><p>建立连接的过程通常是比较复杂的，所以最好在使用中尽量减少建立连接的动作，推荐尽量使用长连接；这也并不代表全部使用长连接，如果对于每一个请求都使用长连接，最终会出现 MySQL 占用内存飞速增加的情况。这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象中的。这些资源只有在连接断开时才会释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），最终表现的结果就是：MySQL 异常重启了</p></div><p>❓ 如何解决 MySQL 长连接问题？</p><div class="alert success no-icon"><ol><li>定期断开长连接，使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连</li><li>如果使用的是 MySQL 5.7 及以上版本，可以在每次执行一个比较大的操作后，通过执行 <code>mysql_reset_connection</code> 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态</li></ol></div><h2 id="查询缓存"><a class="header-anchor" href="#查询缓存">¶</a>查询缓存</h2><div class="alert success no-icon"><p>连接建立完成后，就可以通过 mysql 客户端执行 <code>select</code> 语句，此时的执行逻辑就会来到第二步：查询缓存</p></div><p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。</p><div class="alert success no-icon"><ul><li>如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端;</li><li>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。</li></ul></div><p>❓ 但是大多数情况下，并不会建议使用查询缓存，并且在最新版中直接将查询缓存的整块功能删掉了，究竟是为什么？</p><div class="alert success no-icon"><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p></div><h2 id="分析器"><a class="header-anchor" href="#分析器">¶</a>分析器</h2><div class="alert success no-icon"><p>如果没有命中查询缓存，就要开始真正执行语句了。执行语句之前需要对 SQL 语句做解析</p></div><p>分析器先会做「 词法分析 」，用户输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。随后，MySQL 将用户输入的 <code>select</code> 这个关键字识别出来，明白这是一个查询语句。接下来，它也要把字符串 <code>T</code> 识别成 <code>表名T</code>，把字符串 <code>ID</code> 识别成 <code>列ID</code>。</p><p>做完以上识别以后，就要做「 语法分析 」。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。如果输入语句不对，就会收到 <code>You have an error in your SQL syntax</code>的错误提醒，比如下面这个语句<code>select</code>少打了开头的字母<code>s</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> elect <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ERROR <span class="number">1064</span> (<span class="number">42000</span>): You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;elect * from t where ID=1&#x27;</span> <span class="keyword">at</span> line <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="优化器"><a class="header-anchor" href="#优化器">¶</a>优化器</h2><p>经过分析器，MySQL 就知道用户要执行什么操作了。在开始执行之前，还要先经过优化器的处理。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID)  <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>根据执行结果，有两种不同的执行的方式：</p><div class="alert warning no-icon"><ul><li>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20；</li><li>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10</li></ul></div><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p><h2 id="执行器"><a class="header-anchor" href="#执行器">¶</a>执行器</h2><div class="alert success no-icon"><p>MySQL 通过分析器知道了要执行的语句，通过优化器知道了如何高效的执行对应的操作，于是就进入了执行器阶段，开始真正执行语句。</p></div><p>开始执行的时候，首先先判断一下当前用户对表 <code>T</code> 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示(在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ERROR <span class="number">1142</span> (<span class="number">42000</span>): <span class="keyword">SELECT</span> command denied <span class="keyword">to</span> <span class="keyword">user</span> <span class="string">&#x27;b&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">for</span> <span class="keyword">table</span> <span class="string">&#x27;T&#x27;</span></span><br></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>⛵ 比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p><div class="alert success no-icon"><ol><li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则执行步骤 2 ，如果是则将这行存在结果集中；</li><li>调用引擎接口取「 下一行 」，重复相同的判断逻辑，直到取到这个表的最后一行;</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端</li></ol></div><p>通过以上三个步骤，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。第一次调用的是「 取满足条件的第一行 」这个接口，之后循环取「 满足条件的下一行 」这个接口，这些接口都是引擎中已经定义好的</p><p>在数据库的慢查询日志中看到一个 <code>rows_examined</code> 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。然而并不能准确表示执行引擎扫描了多少行。这是因为，在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。</p><h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2><p>以上就是 MySQL 的逻辑架构，希望通过本文你对一个 SQL 语句完整执行流程的各个阶段有了一个初步的印象，官网中给出 MySQL 的逻辑架构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/mysql/mysql-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E8%AF%A6%E7%BB%86.jpg" alt=""></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/MySQL/" rel="tag">MySQL</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/spring-boot-starter/" data-tooltip="spring boot Starter" aria-label="上一篇: spring boot Starter"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/mysql-%E4%B8%89-ddl%E3%80%81dml/" data-tooltip="MySQL(三)DDL、DML" aria-label="下一篇: MySQL(三)DDL、DML"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/spring-boot-starter/" data-tooltip="spring boot Starter" aria-label="上一篇: spring boot Starter"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/mysql-%E4%B8%89-ddl%E3%80%81dml/" data-tooltip="MySQL(三)DDL、DML" aria-label="下一篇: MySQL(三)DDL、DML"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>