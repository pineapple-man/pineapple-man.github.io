<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>Java 泛型从入门到入土 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="泛型"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n¶泛型\n❓ 什么是泛型？\n泛型，指的是一种 「 参数化类型 」，目的是避免强类型语言带来的类型限制，具体的例子如下：\n\n下面是一段使用 python 代码求解两数和的代码\n12def sum(a,b):  return a+b\npython 本身是一种弱类型语言，这就代表着实现的功能与具体的参数类型无关，上面方法中的 a,b 可以是整数也可以是浮点数，但是这并不影响这个方法所要实现的功能。所以，弱类型语言的好处之一就体现出来了，并不会对具体的类型进行编程，而是对具体的功能进行编程。\n然而 Java 是一种强类型语言，这也就使得必须确定每一个方法的参数类型，返回类型，有可能对于两数相加这个功能，具有很多种函数写法。对于简单的相同的功能，却要编码多遍往往是不可忍受的，所以 Java 就引入泛型机制，期望削弱方法对类型的依赖，使开发人员更多的面向功能而不是面向具体实现。\n✨ 类型参数化的含义\n\n类型明确的工作推迟到创建对象或者调用方法时,才去明确的特殊类型.之后将类型作为一种参数传递给集合，这也是一种代码层面上的复用\n泛型中的类型在使用时指定，不需要强制类型转换，保证了程序中的类型安全，类型相关的问题，编译器会进行检查\n\n\n👍使用泛型的优点\n\n把运行时期的问题提前到了编译期间\n避免了强制类型转换\n优化了程序设计,明确每种集合元素类型\n\n\n对于类型参数，程序员可能想要内置（plug in）所有的类，在没有过多的限制以及混乱的错误消息的状态下，做所有的事情。一个泛型程序员的任务就是预测出所用类的未来可能有的所有用途\n¶泛型类\n首先会介绍常用的一个泛型类Collection及其子类，随后会介绍如何自定义一个泛型类\n¶泛型类的使用\n一个泛型类（generic class) 就是具有一个或多个类型变量的类\n1234ArrayList&lt;type&gt;//type只能是引用类型,即只能是类//泛型前后类型必须一致,即必须写相同的类,就是父子类之间也不允许ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();Collection&lt;Object&gt; c = new Collection&lt;String&gt;();//会报错,因为泛型前后类型不一致\n类型变量必须使用大写字母的形势，并且命名较短\n\n\n\n\n类型变量\n含义\n\n\n\n\nE\n元素（Element），多用于 java 集合框架\n\n\nK\n关键字（Key）\n\n\nN\n数字（Number）\n\n\nT（U、S）\n类型（Type）\n\n\nV\n值（Value）\n\n\n\n1234567891011ArrayList&lt;String &gt; arrayList = new ArrayList&lt;String &gt;();arrayList.add(&quot;hello&quot;);arrayList.add(&quot;world&quot;);arrayList.add(&quot;java&quot;);Iterator&lt;String&gt; it = arrayList.iterator();while (it.hasNext())&#123;\tString s = it.next();\tSystem.out.println(s);&#125;//JDK7新特性,泛型推断ArrayList&lt;String &gt; arrayList2 = new ArrayList&lt;&gt;();\n¶自定义泛型类\n1234567891011121314151617public class GenericClass&lt;T&gt; &#123;    private T data;    public T getData() &#123;        return data;    &#125;    public void setData(T data) &#123;        this.data = data;    &#125;    public static void main(String[] args) &#123;        GenericClass&lt;String&gt; genericClass=new GenericClass&lt;&gt;();        genericClass.setData(&quot;Generic Class&quot;);        System.out.println(genericClass.getData());    &#125;&#125;\n¶泛型接口\n定义一个泛型接口与定义一个泛型类十分相似，具体的代码如下：\n123interface Inter&lt;T&gt;&#123;    public abstract void show(T t);&#125;\n✨ 将泛型定义在接口上,实现类在实现泛型接口的时候具有以下两种\n\n已经知道该泛型的明确类型(不常用)\n并不知道泛型的明确类型(常用)\n\n\n123456789101112131415161718192021222324//方式一:已经知道该泛型的明确类型class InterImple implements Inter&lt;String&gt;&#123;  //不常用    @Override    public void show(String str) &#123;        System.out.println(&quot;from normal imple&quot;+str);    &#125;&#125;//方式二:并不知道泛型的明确类型class InterImple2&lt;T&gt; implements Inter&lt;T&gt;&#123;    //此时泛型接口的使用与泛型类相同    @Override    public void show(T t) &#123;        System.out.println(t);    &#125;&#125;public static void main(String[] args) &#123;\tInter&lt;String&gt; inter = new InterImple2&lt;String&gt;();\tinter.show(&quot;String&quot;);\tInter&lt;Integer&gt; inter2 = new InterImple2&lt;Integer&gt;();\tinter2.show(123);\tInter&lt;Boolean&gt; inter3 = new InterImple2&lt;Boolean&gt;();\tinter3.show(true);&#125;\n¶泛型方法\n✨ 使用泛型方法具有如下特点：\n\n泛型方法可以定义在普通类中，也可以定义在泛型类中\n不用因为相同的功能而重载多个类\n\n\n声明一个泛型方法具有如下格式：\n1public &lt;T&gt; T show(T t);//public 后的&lt;T&gt;声明使用泛型\n下面是一个具体的例子\n123456789101112131415class ObjectTool&#123;    //将泛型定义在方法上    public &lt;T&gt; void show(T t)&#123;        System.out.println(t);    &#125;&#125;//show方法可以接受任何一种参数public static void main(String[] args) &#123;\tObjectTool objectTool = new ObjectTool();\tobjectTool.&lt;String&gt;show(&quot;this is string type&quot;);\t//不知道形式参数类型,泛型参数可以不用明确指定,编译器会自动识别\tobjectTool.show(&quot;hello world&quot;);\tobjectTool.&lt;Integer&gt;show(100);\tobjectTool.show(true);&#125;\n¶类型变量的限定（泛型边界）\n在泛型类或方法需要对类型变量加以约束，这就需要使用类型变量的限定符，一个类型变量或通配符可以有多个限定， 例如：T extends Comparable &amp; Serializable等\n\n在 Java 中存在两种方式对类型变量进行限定：\n\n对类的限定：public class TypeLimitForClass&lt;T extends List &amp; Serializable&gt;{}\n对方法的限定：public static &lt;T extends Comparable&lt;T&gt;&gt; T getMin(T a, T b) {}\n\n\n12345678/*** 限定类型使用extends关键字指定* 可以使类，接口，类放在前面接口放在后面用&amp;符号分割* 例如：&lt;T extends ArrayList &amp; Comparable&lt;T&gt; &amp; Serializable&gt;*/public static &lt;T extends Comparable&lt;T&gt;&gt; T getMin(T a, T b) &#123;\treturn (a.compareTo(b) &lt; 0) ? a : b;&#125;\n123456789101112public class TypeLimitForClass&lt;T extends List &amp; Serializable&gt; &#123;\tprivate T data;\tpublic T getData() &#123;\t\treturn data;\t&#125;\tpublic void setData(T data) &#123;\t\tthis.data = data;\t&#125;\tpublic static &lt;T extends Comparable&lt;T&gt;&gt; T getMinListSize(T a, T b) &#123;\t\treturn (a.compareTo(b) &lt; 0) ? a : b;\t&#125;&#125;\n¶泛型通配符\n主要介绍?,? extends E,? super E这三种泛型通配符\n123class Animal&#123;&#125;class Dog extends Animal&#123;&#125;class Cat extends Animal&#123;&#125;\n¶?\n任意的引用类型都可以\n123Collection&lt;?&gt; c1 = new ArrayList&lt;Animal&gt;();Collection&lt;?&gt; c2 = new ArrayList&lt;Dog&gt;();Collection&lt;?&gt; c3 = new ArrayList&lt;Cat&gt;();\n¶? extends E\n向下限定,E 及其子类\n123Collection&lt;? extends Animal&gt; c4 = new ArrayList&lt;Animal&gt;();Collection&lt;? extends Animal&gt; c5 = new ArrayList&lt;Dog&gt;();Collection&lt;? extends Animal&gt; c6 = new ArrayList&lt;Object&gt;();//出错,只能是子类\n¶? super E\n向上限定\n12Collection&lt;? super Animal&gt; c7 = new ArrayList&lt;Object&gt;();Collection&lt;? super Animal&gt; c8 = new ArrayList&lt;Dog&gt;();//出错,只能是父类\n¶泛型的约束和局限性\n✨ 使用泛型的特点(约束性和局限性)\n\n不能实例化泛型类\n静态变量或方法不能引用泛型类型变量，但是静态泛型方法是可以的\n基本类型无法作为泛型类型\n无法使用 instanceof 关键字或==判断泛型类的类型\n泛型类的原生类型与所传递的泛型无关，无论传递什么类型，原生类是一样的\n泛型数组可以声明但无法实例化\n泛型类不能继承 Exception 或者 Throwable\n不能捕获泛型类型限定的异常但可以将泛型限定的异常抛出\n\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class GenericRestrict1&lt;T&gt; &#123;    static class NormalClass &#123;    &#125;    private T data;    /**     * 不能实例化泛型类     * Type parameter &#x27;T&#x27; cannot be instantiated directly     */    public void setData() &#123;        //this.data = new T();    &#125;    /**     * 静态变量或方法不能引用泛型类型变量   private static T result;   private static T getResult() &#123;       return result;   &#125;     */    /**     * 静态泛型方法是可以的     */    private static &lt;K&gt; K getKey(K k) &#123;        return k;    &#125;    public static void main(String[] args) &#123;        NormalClass normalClassA = new NormalClass();        NormalClass normalClassB = new NormalClass();        /**         * 基本类型无法作为泛型类型       GenericRestrict1&lt;int&gt; genericRestrictInt = new GenericRestrict1&lt;&gt;();         */        GenericRestrict1&lt;Integer&gt; genericRestrictInteger = new GenericRestrict1&lt;&gt;();        GenericRestrict1&lt;String&gt; genericRestrictString = new GenericRestrict1&lt;&gt;();        /**         * 无法使用instanceof关键字判断泛型类的类型         * Illegal generic type for instanceof       if(genericRestrictInteger instanceof GenericRestrict1&lt;Integer&gt;)&#123;           return;       &#125;         */        /**         * 无法使用“==”判断两个泛型类的实例         * Operator &#x27;==&#x27; cannot be applied to this two instance       if (genericRestrictInteger == genericRestrictString) &#123;           return;       &#125;         */        /**         * 泛型类的原生类型与所传递的泛型无关，无论传递什么类型，原生类是一样的         */        System.out.println(normalClassA == normalClassB);//false        System.out.println(genericRestrictInteger == genericRestrictInteger);//        System.out.println(genericRestrictInteger.getClass() == genericRestrictString.getClass()); //true        System.out.println(genericRestrictInteger.getClass());//restrict.GenericRestrict1        System.out.println(genericRestrictString.getClass());//restrict.GenericRestrict1        /**         * 泛型数组可以声明但无法实例化         * Generic array creation         */        GenericRestrict1&lt;String&gt;[] genericRestrict1s;//        genericRestrict1s = new GenericRestrict1&lt;String&gt;[10];        genericRestrict1s = new GenericRestrict1[10];        genericRestrict1s[0]=genericRestrictString;    &#125;&#125;\n1234567891011121314151617181920212223242526272829303132333435363738public class GenericRestrict2 &#123;    private class MyException extends Exception &#123;    &#125;    /**     * 泛型类不能继承Exception或者Throwable     * Generic class may not extend &#x27;java.lang.Throwable&#x27;\t private class MyGenericException&lt;T&gt; extends Exception &#123;\t &#125;\t private class MyGenericThrowable&lt;T&gt; extends Throwable &#123;   &#125;     */    /**     * 不能捕获泛型类型限定的异常     * Cannot catch type parameters    public &lt;T extends Exception&gt; void getException(T t) &#123;       try &#123;       &#125; catch (T e) &#123;       &#125;    &#125;     */    /**     *可以将泛型限定的异常抛出     */    public &lt;T extends Throwable&gt; void getException(T t) throws T &#123;        try &#123;        &#125; catch (Exception e) &#123;            throw t;        &#125;    &#125;&#125;\n¶泛型类型继承规则\n✨泛型类间的继承特点\n\n泛型参数是继承关系的泛型类之间是没有继承关系的\n泛型类可以继承其它泛型类;如: public class ArrayList extends AbstractList\n泛型类的继承关系在使用中同样会受到泛型类型的影响\n\n\n¶获取泛型的参数类型\n❓ Type 是什么？\nType即，java.lang.reflect.Type, 是 Java 中所有类型的公共高级接口, 代表了 Java 中的所有类型。\nType 体系中类型的包括：数组类型(GenericArrayType)、参数化类型(ParameterizedType)、类型变量(TypeVariable)、通配符类型(WildcardType)、原始类型(Class)、基本类型(Class), 以上这些类型都实现 Type 接口\n\n\n\n\n泛型类型\n常用类\n\n\n\n\n参数化类型\n泛型 List、Map\n\n\n数组类型\n并不是平时使用的 String[]、byte[]，而是带有泛型的数组 T[]\n\n\n通配符类型\n指的是&lt;?&gt;, &lt;? extends T&gt;等等\n\n\n原始类型\n用户自定义的类、枚举、数组、注解等类型\n\n\n基本类型\njava 的基本类型，即 int,float,double 等\n\n\n\n12345678910public interface ParameterizedType extends Type &#123;    // 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer]    Type[] getActualTypeArguments();    //返回当前class或interface声明的类型, 如List&lt;?&gt;返回List    Type getRawType();    //返回所属类型. 如,当前类型为O&lt;T&gt;.I&lt;S&gt;, 则返回O&lt;T&gt;. 顶级类型将返回null    Type getOwnerType();&#125;\n¶泛型代码和虚拟机\n虚拟机没有泛型类型对象，所有对象都属于普通类。Java 泛型是 Java1.5 之后才引入的，为了向下兼容。Java 采用了 C++完全不同的实现思想。Java 中的泛型更多的看起来像是编译期用的，Java 中泛型在运行期是不可见的，会被擦除为它的上级类型。如果是没有限定的泛型参数类型，就会被替换为 Object\n无论何时定义一个泛型类型， 都自动提供了一个相应的原始类型 （ raw type ）。原始类型的名字就是删去类型参数后的泛型类型名。擦除（erased）类型变量，并替换为限定类型（无限定的变量用 Object）\n1234567891011121314151617181920212223242526public class Pair&lt;T&gt;&#123;\tprivate T first;\tprivate T second;\tpublic Pair() &#123; first = null ; second = null ; &#125;\tpublic PairfT first, T second) &#123; this,first = first; this.second = second; &#125;\tpublic T getFirstO &#123; return first; &#125;\tpublic T getSecondO &#123; return second; &#125;\tpublic void setFirst(T newValue) &#123; first = newValue; &#125;\tpublic void setSecond(T newValue) &#123; second = newValue; &#125;&#125;//T 是无限定变量，直接使用Object替换public class Pair&#123;\tprivate Object first;\tprivate Object second;\tpublic Pair(Object first, Object second)\t&#123;\t\tthis,first = first;\t\tthis.second = second;    &#125;\tpublic Object getFirstO &#123; return first; &#125;\tpublic Object getSecondO &#123; return second; &#125;\tpublic void setFirst(Object newValue) &#123; first = newValue; &#125;\tpublic void setSecond(Object newValue) &#123; second = newValue; &#125;&#125;\n🎶 C++ 中每个模板的实例化产生不同的类型，这一现象称为模板代码膨账，Java 不存在这个问题的困扰\n❓ 为什么需要有如此麻烦的泛型擦出机制？\n擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入到 Java 语言\n\n❓ 泛型类型参数将擦除到它的第一个边界（它可能会有多个边界），那么class Interval&lt;T extends Serializable &amp; Comparable&gt;会切换那个边界？\n上述泛型的定义，原始类型用 Serializable 替换 T，而编译器在必要时要向 Comparable 插入强制类型转换。为了提高效率，应该将标签接口（即没有方法的接口）放在边界列表的末尾\n\n¶总结\n✨ Java 具有如下泛型特点\n\n在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型.传入不同泛型实参的泛型类在内存上仅存在一个,即还是原来的最基本的类型，在逻辑上我们可以理解成多个不同的泛型类型；\nJava 泛型只是作用于代码编译阶段,在编译过程中,对于正确检验泛型结果后,会将泛型的相关信息擦出,也就是说,成功编译过后的 class 文件中是不包含任何泛型信息的,泛型信息不会进入到运行时阶段。\n\n\n🎶Java 泛型转换的事实\n\n虚拟机中没有泛型，只有普通的类和方法\n所有的类型参数都用它们的限定类型替换\n桥方法被合成来保持多态\n为保持类型安全性，必要时插入强制类型转换\n\n\n¶附录\nJava 泛型详解\n","dateCreated":"2022-02-01T01:00:14+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2022-02-01T01:00:14+00:00","description":"泛型是如今高级语言都支持的特性，Java 最初并不支持泛型，那么最后 Java 是如何优雅的增加这个功能？","headline":"Java 泛型从入门到入土","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/java-%E6%B3%9B%E5%9E%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/java-%E6%B3%9B%E5%9E%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/","keywords":"JDK"}</script><meta name="description" content="泛型是如今高级语言都支持的特性，Java 最初并不支持泛型，那么最后 Java 是如何优雅的增加这个功能？"><meta property="og:type" content="blog"><meta property="og:title" content="Java 泛型从入门到入土"><meta property="og:url" content="https://pineapple-man.github.io/java-%E6%B3%9B%E5%9E%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="泛型是如今高级语言都支持的特性，Java 最初并不支持泛型，那么最后 Java 是如何优雅的增加这个功能？"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-02-01T01:00:14.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.011Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="JDK"><meta name="twitter:card" content="summary"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">Java 泛型从入门到入土</h1><div class="post-meta"><time datetime="2022-02-01T01:00:14+00:00">2月 01, 2022 </time><span>发布在 </span><a class="category-link" href="/categories/Java/">Java</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 3.5k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 37 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-text">泛型类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">泛型类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-text">自定义泛型类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E9%99%90%E5%AE%9A%EF%BC%88%E6%B3%9B%E5%9E%8B%E8%BE%B9%E7%95%8C%EF%BC%89"><span class="toc-text">类型变量的限定（泛型边界）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">泛型通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extends-E"><span class="toc-text">? extends E</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super-E"><span class="toc-text">? super E</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">泛型的约束和局限性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E7%BB%A7%E6%89%BF%E8%A7%84%E5%88%99"><span class="toc-text">泛型类型继承规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">获取泛型的参数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E4%BB%A3%E7%A0%81%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-text">泛型代码和虚拟机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol><h2 id="泛型"><a class="header-anchor" href="#泛型">¶</a>泛型</h2><p>❓ 什么是泛型？</p><div class="alert success no-icon"><p>泛型，指的是一种 「 参数化类型 」，目的是避免强类型语言带来的类型限制，具体的例子如下：</p></div><p>下面是一段使用 <code>python</code> 代码求解两数和的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">a,b</span>):</span><br><span class="line">  <span class="keyword">return</span> a+b</span><br></pre></td></tr></table></figure><p>python 本身是一种弱类型语言，这就代表着实现的功能与具体的参数类型无关，上面方法中的 a,b 可以是整数也可以是浮点数，但是这并不影响这个方法所要实现的功能。所以，弱类型语言的好处之一就体现出来了，并不会对具体的类型进行编程，而是对具体的功能进行编程。</p><p>然而 Java 是一种强类型语言，这也就使得必须确定每一个方法的参数类型，返回类型，有可能对于两数相加这个功能，具有很多种函数写法。对于简单的相同的功能，却要编码多遍往往是不可忍受的，所以 Java 就引入泛型机制，期望削弱方法对类型的依赖，使开发人员更多的面向功能而不是面向具体实现。</p><p>✨ <strong>类型参数化</strong>的含义</p><div class="alert success no-icon"><ul><li>类型明确的工作推迟到创建对象或者调用方法时,才去明确的特殊类型.之后将类型作为一种参数传递给集合，这也是一种代码层面上的复用</li><li>泛型中的类型在使用时指定，不需要强制类型转换，保证了程序中的类型安全，类型相关的问题，编译器会进行检查</li></ul></div><p>👍使用泛型的优点</p><div class="alert success no-icon"><ol><li>把运行时期的问题提前到了编译期间</li><li>避免了强制类型转换</li><li>优化了程序设计,明确每种集合元素类型</li></ol></div><p>对于类型参数，程序员可能想要内置（plug in）所有的类，在没有过多的限制以及混乱的错误消息的状态下，做所有的事情。一个泛型程序员的任务就是预测出所用类的未来可能有的所有用途</p><h2 id="泛型类"><a class="header-anchor" href="#泛型类">¶</a>泛型类</h2><p>首先会介绍常用的一个泛型类<code>Collection</code>及其子类，随后会介绍如何自定义一个泛型类</p><h3 id="泛型类的使用"><a class="header-anchor" href="#泛型类的使用">¶</a>泛型类的使用</h3><p>一个泛型类（generic class) 就是具有一个或多个类型变量的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;type&gt;<span class="comment">//type只能是引用类型,即只能是类</span></span><br><span class="line"><span class="comment">//泛型前后类型必须一致,即必须写相同的类,就是父子类之间也不允许</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">Collection&lt;Object&gt; c = <span class="keyword">new</span> <span class="title class_">Collection</span>&lt;String&gt;();<span class="comment">//会报错,因为泛型前后类型不一致</span></span><br></pre></td></tr></table></figure><div class="alert info no-icon"><p>类型变量必须使用大写字母的形势，并且命名较短</p></div><table><thead><tr><th style="text-align:center">类型变量</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">E</td><td style="text-align:center">元素（Element），多用于 java 集合框架</td></tr><tr><td style="text-align:center">K</td><td style="text-align:center">关键字（Key）</td></tr><tr><td style="text-align:center">N</td><td style="text-align:center">数字（Number）</td></tr><tr><td style="text-align:center">T（U、S）</td><td style="text-align:center">类型（Type）</td></tr><tr><td style="text-align:center">V</td><td style="text-align:center">值（Value）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String &gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String &gt;();</span><br><span class="line">arrayList.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">Iterator&lt;String&gt; it = arrayList.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JDK7新特性,泛型推断</span></span><br><span class="line">ArrayList&lt;String &gt; arrayList2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="自定义泛型类"><a class="header-anchor" href="#自定义泛型类">¶</a>自定义泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericClass</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        GenericClass&lt;String&gt; genericClass=<span class="keyword">new</span> <span class="title class_">GenericClass</span>&lt;&gt;();</span><br><span class="line">        genericClass.setData(<span class="string">&quot;Generic Class&quot;</span>);</span><br><span class="line">        System.out.println(genericClass.getData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型接口"><a class="header-anchor" href="#泛型接口">¶</a>泛型接口</h2><p>定义一个泛型接口与定义一个泛型类十分相似，具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✨ 将泛型定义在接口上,实现类在实现泛型接口的时候具有以下两种</p><div class="alert success no-icon"><ol><li>已经知道该泛型的明确类型(<strong>不常用</strong>)</li><li>并不知道泛型的明确类型(<strong>常用</strong>)</li></ol></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一:已经知道该泛型的明确类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterImple</span> <span class="keyword">implements</span> <span class="title class_">Inter</span>&lt;String&gt;&#123;</span><br><span class="line">  <span class="comment">//不常用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;from normal imple&quot;</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式二:并不知道泛型的明确类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterImple2</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Inter</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="comment">//此时泛型接口的使用与泛型类相同</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	Inter&lt;String&gt; inter = <span class="keyword">new</span> <span class="title class_">InterImple2</span>&lt;String&gt;();</span><br><span class="line">	inter.show(<span class="string">&quot;String&quot;</span>);</span><br><span class="line">	Inter&lt;Integer&gt; inter2 = <span class="keyword">new</span> <span class="title class_">InterImple2</span>&lt;Integer&gt;();</span><br><span class="line">	inter2.show(<span class="number">123</span>);</span><br><span class="line">	Inter&lt;Boolean&gt; inter3 = <span class="keyword">new</span> <span class="title class_">InterImple2</span>&lt;Boolean&gt;();</span><br><span class="line">	inter3.show(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型方法"><a class="header-anchor" href="#泛型方法">¶</a>泛型方法</h2><p>✨ 使用泛型方法具有如下特点：</p><div class="alert success no-icon"><ul><li>泛型方法可以定义在普通类中，也可以定义在泛型类中</li><li>不用因为相同的功能而重载多个类</li></ul></div><p>声明一个泛型方法具有如下格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">show</span><span class="params">(T t)</span>;<span class="comment">//public 后的&lt;T&gt;声明使用泛型</span></span><br></pre></td></tr></table></figure><p>下面是一个具体的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectTool</span>&#123;</span><br><span class="line">    <span class="comment">//将泛型定义在方法上</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//show方法可以接受任何一种参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">ObjectTool</span> <span class="variable">objectTool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectTool</span>();</span><br><span class="line">	objectTool.&lt;String&gt;show(<span class="string">&quot;this is string type&quot;</span>);</span><br><span class="line">	<span class="comment">//不知道形式参数类型,泛型参数可以不用明确指定,编译器会自动识别</span></span><br><span class="line">	objectTool.show(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	objectTool.&lt;Integer&gt;show(<span class="number">100</span>);</span><br><span class="line">	objectTool.show(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型变量的限定（泛型边界）"><a class="header-anchor" href="#类型变量的限定（泛型边界）">¶</a>类型变量的限定（泛型边界）</h2><div class="alert success no-icon"><p>在泛型类或方法需要对类型变量加以约束，这就需要使用类型变量的限定符，一个类型变量或通配符可以有多个限定， 例如：<code>T extends Comparable &amp; Serializable</code>等</p></div><p>在 Java 中存在两种方式对类型变量进行限定：</p><div class="alert success no-icon"><ul><li>对类的限定：<code>public class TypeLimitForClass&lt;T extends List &amp; Serializable&gt;{}</code></li><li>对方法的限定：<code>public static &lt;T extends Comparable&lt;T&gt;&gt; T getMin(T a, T b) {}</code></li></ul></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 限定类型使用extends关键字指定</span></span><br><span class="line"><span class="comment">* 可以使类，接口，类放在前面接口放在后面用&amp;符号分割</span></span><br><span class="line"><span class="comment">* 例如：&lt;T extends ArrayList &amp; Comparable&lt;T&gt; &amp; Serializable&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">getMin</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (a.compareTo(b) &lt; <span class="number">0</span>) ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeLimitForClass</span>&lt;T <span class="keyword">extends</span> <span class="title class_">List</span> &amp; Serializable&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> T data;</span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T data)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">getMinListSize</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (a.compareTo(b) &lt; <span class="number">0</span>) ? a : b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型通配符"><a class="header-anchor" href="#泛型通配符">¶</a>泛型通配符</h2><p>主要介绍<code>?</code>,<code>? extends E</code>,<code>? super E</code>这三种泛型通配符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3><a class="header-anchor" href="#">¶</a><code>?</code></h3><p>任意的引用类型都可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;?&gt; c1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line">Collection&lt;?&gt; c2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Dog&gt;();</span><br><span class="line">Collection&lt;?&gt; c3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Cat&gt;();</span><br></pre></td></tr></table></figure><h3 id="extends-E"><a class="header-anchor" href="#extends-E">¶</a><code>? extends E</code></h3><p>向下限定,E 及其子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;? <span class="keyword">extends</span> <span class="title class_">Animal</span>&gt; c4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line">Collection&lt;? <span class="keyword">extends</span> <span class="title class_">Animal</span>&gt; c5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Dog&gt;();</span><br><span class="line">Collection&lt;? <span class="keyword">extends</span> <span class="title class_">Animal</span>&gt; c6 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();<span class="comment">//出错,只能是子类</span></span><br></pre></td></tr></table></figure><h3 id="super-E"><a class="header-anchor" href="#super-E">¶</a><code>? super E</code></h3><p>向上限定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;? <span class="built_in">super</span> Animal&gt; c7 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">Collection&lt;? <span class="built_in">super</span> Animal&gt; c8 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Dog&gt;();<span class="comment">//出错,只能是父类</span></span><br></pre></td></tr></table></figure><h2 id="泛型的约束和局限性"><a class="header-anchor" href="#泛型的约束和局限性">¶</a>泛型的约束和局限性</h2><p>✨ 使用泛型的特点(约束性和局限性)</p><div class="alert success no-icon"><ol><li>不能实例化泛型类</li><li>静态变量或方法不能引用泛型类型变量，但是静态泛型方法是可以的</li><li>基本类型无法作为泛型类型</li><li>无法使用 instanceof 关键字或==判断泛型类的类型</li><li>泛型类的原生类型与所传递的泛型无关，无论传递什么类型，原生类是一样的</li><li>泛型数组可以声明但无法实例化</li><li>泛型类不能继承 Exception 或者 Throwable</li><li>不能捕获泛型类型限定的异常但可以将泛型限定的异常抛出</li></ol></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericRestrict1</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NormalClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不能实例化泛型类</span></span><br><span class="line"><span class="comment">     * Type parameter &#x27;T&#x27; cannot be instantiated directly</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//this.data = new T();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态变量或方法不能引用泛型类型变量</span></span><br><span class="line"><span class="comment">   private static T result;</span></span><br><span class="line"><span class="comment">   private static T getResult() &#123;</span></span><br><span class="line"><span class="comment">       return result;</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态泛型方法是可以的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;K&gt; K <span class="title function_">getKey</span><span class="params">(K k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NormalClass</span> <span class="variable">normalClassA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NormalClass</span>();</span><br><span class="line">        <span class="type">NormalClass</span> <span class="variable">normalClassB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NormalClass</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 基本类型无法作为泛型类型</span></span><br><span class="line"><span class="comment">       GenericRestrict1&lt;int&gt; genericRestrictInt = new GenericRestrict1&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        GenericRestrict1&lt;Integer&gt; genericRestrictInteger = <span class="keyword">new</span> <span class="title class_">GenericRestrict1</span>&lt;&gt;();</span><br><span class="line">        GenericRestrict1&lt;String&gt; genericRestrictString = <span class="keyword">new</span> <span class="title class_">GenericRestrict1</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 无法使用instanceof关键字判断泛型类的类型</span></span><br><span class="line"><span class="comment">         * Illegal generic type for instanceof</span></span><br><span class="line"><span class="comment">       if(genericRestrictInteger instanceof GenericRestrict1&lt;Integer&gt;)&#123;</span></span><br><span class="line"><span class="comment">           return;</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 无法使用“==”判断两个泛型类的实例</span></span><br><span class="line"><span class="comment">         * Operator &#x27;==&#x27; cannot be applied to this two instance</span></span><br><span class="line"><span class="comment">       if (genericRestrictInteger == genericRestrictString) &#123;</span></span><br><span class="line"><span class="comment">           return;</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 泛型类的原生类型与所传递的泛型无关，无论传递什么类型，原生类是一样的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(normalClassA == normalClassB);<span class="comment">//false</span></span><br><span class="line">        System.out.println(genericRestrictInteger == genericRestrictInteger);<span class="comment">//</span></span><br><span class="line">        System.out.println(genericRestrictInteger.getClass() == genericRestrictString.getClass()); <span class="comment">//true</span></span><br><span class="line">        System.out.println(genericRestrictInteger.getClass());<span class="comment">//restrict.GenericRestrict1</span></span><br><span class="line">        System.out.println(genericRestrictString.getClass());<span class="comment">//restrict.GenericRestrict1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 泛型数组可以声明但无法实例化</span></span><br><span class="line"><span class="comment">         * Generic array creation</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        GenericRestrict1&lt;String&gt;[] genericRestrict1s;</span><br><span class="line"><span class="comment">//        genericRestrict1s = new GenericRestrict1&lt;String&gt;[10];</span></span><br><span class="line">        genericRestrict1s = <span class="keyword">new</span> <span class="title class_">GenericRestrict1</span>[<span class="number">10</span>];</span><br><span class="line">        genericRestrict1s[<span class="number">0</span>]=genericRestrictString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericRestrict2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型类不能继承Exception或者Throwable</span></span><br><span class="line"><span class="comment">     * Generic class may not extend &#x27;java.lang.Throwable&#x27;</span></span><br><span class="line"><span class="comment">	 private class MyGenericException&lt;T&gt; extends Exception &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 &#125;</span></span><br><span class="line"><span class="comment">	 private class MyGenericThrowable&lt;T&gt; extends Throwable &#123;</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不能捕获泛型类型限定的异常</span></span><br><span class="line"><span class="comment">     * Cannot catch type parameters</span></span><br><span class="line"><span class="comment">    public &lt;T extends Exception&gt; void getException(T t) &#123;</span></span><br><span class="line"><span class="comment">       try &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       &#125; catch (T e) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *可以将泛型限定的异常抛出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">getException</span><span class="params">(T t)</span> <span class="keyword">throws</span> T &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型类型继承规则"><a class="header-anchor" href="#泛型类型继承规则">¶</a>泛型类型继承规则</h2><p>✨泛型类间的继承特点</p><div class="alert success no-icon"><ol><li>泛型参数是继承关系的泛型类之间是没有继承关系的</li><li>泛型类可以继承其它泛型类;如: public class ArrayList<e>extends AbstractList<e></e></e></li><li>泛型类的继承关系在使用中同样会受到泛型类型的影响</li></ol></div><h2 id="获取泛型的参数类型"><a class="header-anchor" href="#获取泛型的参数类型">¶</a>获取泛型的参数类型</h2><p>❓ <code>Type</code> 是什么？</p><div class="alert success no-icon"><p><code>Type</code>即，java.lang.reflect.Type, 是 Java 中所有类型的公共高级接口, 代表了 Java 中的所有类型。</p><p>Type 体系中类型的包括：数组类型(GenericArrayType)、参数化类型(ParameterizedType)、类型变量(TypeVariable)、通配符类型(WildcardType)、原始类型(Class)、基本类型(Class), 以上这些类型都实现 Type 接口</p></div><table><thead><tr><th style="text-align:center">泛型类型</th><th style="text-align:center">常用类</th></tr></thead><tbody><tr><td style="text-align:center">参数化类型</td><td style="text-align:center">泛型 List、Map</td></tr><tr><td style="text-align:center">数组类型</td><td style="text-align:center">并不是平时使用的 String[]、byte[]，而是带有泛型的数组 T[]</td></tr><tr><td style="text-align:center">通配符类型</td><td style="text-align:center">指的是&lt;?&gt;, &lt;? extends T&gt;等等</td></tr><tr><td style="text-align:center">原始类型</td><td style="text-align:center">用户自定义的类、枚举、数组、注解等类型</td></tr><tr><td style="text-align:center">基本类型</td><td style="text-align:center">java 的基本类型，即 int,float,double 等</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ParameterizedType</span> <span class="keyword">extends</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="comment">// 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer]</span></span><br><span class="line">    Type[] getActualTypeArguments();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前class或interface声明的类型, 如List&lt;?&gt;返回List</span></span><br><span class="line">    Type <span class="title function_">getRawType</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回所属类型. 如,当前类型为O&lt;T&gt;.I&lt;S&gt;, 则返回O&lt;T&gt;. 顶级类型将返回null</span></span><br><span class="line">    Type <span class="title function_">getOwnerType</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型代码和虚拟机"><a class="header-anchor" href="#泛型代码和虚拟机">¶</a>泛型代码和虚拟机</h2><p>虚拟机没有泛型类型对象，所有对象都属于普通类。Java 泛型是 Java1.5 之后才引入的，为了向下兼容。Java 采用了 C++完全不同的实现思想。Java 中的泛型更多的看起来像是编译期用的，Java 中泛型在运行期是不可见的，会被擦除为它的上级类型。如果是没有限定的泛型参数类型，就会被替换为 Object</p><p>无论何时定义一个泛型类型， 都自动提供了一个相应的原始类型 （ raw type ）。原始类型的名字就是删去类型参数后的泛型类型名。擦除（erased）类型变量，并替换为限定类型（无限定的变量用 Object）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> T first;</span><br><span class="line">	<span class="keyword">private</span> T second;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span> &#123; first = <span class="literal">null</span> ; second = <span class="literal">null</span> ; &#125;</span><br><span class="line">	<span class="keyword">public</span> PairfT first, T second) &#123; <span class="built_in">this</span>,first = first; <span class="built_in">this</span>.second = second; &#125;</span><br><span class="line">	<span class="keyword">public</span> T getFirstO &#123; <span class="keyword">return</span> first; &#125;</span><br><span class="line">	<span class="keyword">public</span> T getSecondO &#123; <span class="keyword">return</span> second; &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(T newValue)</span> &#123; first = newValue; &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(T newValue)</span> &#123; second = newValue; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//T 是无限定变量，直接使用Object替换</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> Object first;</span><br><span class="line">	<span class="keyword">private</span> Object second;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(Object first, Object second)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>,first = first;</span><br><span class="line">		<span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> Object getFirstO &#123; <span class="keyword">return</span> first; &#125;</span><br><span class="line">	<span class="keyword">public</span> Object getSecondO &#123; <span class="keyword">return</span> second; &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(Object newValue)</span> &#123; first = newValue; &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(Object newValue)</span> &#123; second = newValue; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🎶 C++ 中每个模板的实例化产生不同的类型，这一现象称为<strong>模板代码膨账</strong>，Java 不存在这个问题的困扰</p><p>❓ 为什么需要有如此麻烦的泛型擦出机制？</p><div class="alert success no-icon"><p>擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入到 Java 语言</p></div><p>❓ 泛型类型参数将擦除到它的第一个边界（它可能会有多个边界），那么<code>class Interval&lt;T extends Serializable &amp; Comparable&gt;</code>会切换那个边界？</p><div class="alert success no-icon"><p>上述泛型的定义，原始类型用 Serializable 替换 T，而编译器在必要时要向 Comparable 插入强制类型转换。为了提高效率，应该将标签接口（即没有方法的接口）放在边界列表的末尾</p></div><h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2><p>✨ Java 具有如下泛型特点</p><div class="alert success no-icon"><ul><li>在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型.传入不同泛型实参的泛型类在内存上仅存在一个,即还是原来的最基本的类型，在逻辑上我们可以理解成多个不同的泛型类型；</li><li>Java 泛型<strong>只是作用于代码编译阶段</strong>,在编译过程中,对于正确检验泛型结果后,会将泛型的相关信息擦出,也就是说,成功编译过后的 class 文件中是不包含任何泛型信息的,<strong>泛型信息不会进入到运行时阶段。</strong></li></ul></div><p>🎶Java 泛型转换的事实</p><div class="alert success no-icon"><ul><li>虚拟机中没有泛型，只有普通的类和方法</li><li>所有的类型参数都用它们的限定类型替换</li><li>桥方法被合成来保持多态</li><li>为保持类型安全性，必要时插入强制类型转换</li></ul></div><h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/986f732ed2f1">Java 泛型详解</a></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/JDK/" rel="tag">JDK</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E5%B8%B8%E8%A7%81%E9%AB%98%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/" data-tooltip="常见高并发性能指标" aria-label="上一篇: 常见高并发性能指标"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/mysql-%E4%BA%94-%E7%AE%80%E5%8D%95%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%B5%81%E7%A8%8B/" data-tooltip="MySQL(五)简单更新语句流程" aria-label="下一篇: MySQL(五)简单更新语句流程"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/%E5%B8%B8%E8%A7%81%E9%AB%98%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/" data-tooltip="常见高并发性能指标" aria-label="上一篇: 常见高并发性能指标"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/mysql-%E4%BA%94-%E7%AE%80%E5%8D%95%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%B5%81%E7%A8%8B/" data-tooltip="MySQL(五)简单更新语句流程" aria-label="下一篇: MySQL(五)简单更新语句流程"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>