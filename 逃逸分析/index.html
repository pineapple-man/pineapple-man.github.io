<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="pineapple-man"><title>逃逸分析 - pineapple-man</title><meta name="author" content="pineapple-man"><meta name="keywords" content="逃逸分析"><link rel="icon" href="https://pineapple-man.github.io/assets/images/logo.svg"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png"},"articleBody":"\n¶概述\n❓什么是逃逸分析\n\n在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法——分析在程序的哪些地方可以访问到指针\n逃逸分析可以确定某个指针可以存储的所有地方，以及确定能否保证指针的生命周期只在当前进程或线程中\n简单点理解，逃逸分析（Escape analysis）就是确定变量范围的一种分析技术\n\n\nIf a subroutine allocates an object and returns a pointer to it, the object can be accessed from undetermined places in the program – the pointer has “escaped”. Pointers can also escape if they are stored in global variables or other data structures that, in turn, escape the current procedure. ——wiki\n如果子程序创建并返回一个对象指针，在程序运行阶段，谁会使用这个对象指针是不确定的，此时就称这个不确定调用者的对象指针发生了逃逸，同样的，如果将指针存储在全局变量或者其他类型的数据结构时，由于全局变量可以在当前子程序之外访问，此时的指针也发生了逃逸\n\n¶逃逸分析算法\nJava Hotspot 编译器实现下面论文中描述的逃逸算法：\n\n[Choi99] Jong-Deok Choi, Manish Gupta, Mauricio Seffano,Vugranam C. Sreedhar, Sam Midkiff,“Escape Analysis for Java”, Procedings of ACM SIGPLAN OOPSLA Conference, November 1, 1999\n\n📓算法是上下文相关和流敏感的，并且模拟了对象任意层次的嵌套关系，所以分析精度较高，只是运行时间和内存消耗相对较大，如果对逃逸分析等底层原理非常感兴趣，建议读一读\n¶对象的逃逸状态\n✨从逃逸分析的角度来看，一个对象的逃逸与否存在以下三种状态：全局逃逸（Global Escape）、参数逃逸（Arg Escape）和没有逃逸\n1️⃣全局逃逸，即一个对象的作用范围逃出了当前方法或者当前线程，存在以下几种场景：\n\n对象是一个静态变量\n对象是一个已经发生逃逸的对象\n对象作为当前方法的返回值\n\n2️⃣参数逃逸，即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调用方法的字节码确定的\n3️⃣没有逃逸，即方法中的对象没有发生逃逸\n¶逃逸分析的作用\n编译器可以使用逃逸分析的结果作为优化的基础：\n\n将堆分配转化为栈上分配。如果某个对象在子程序中被分配，并且指向该对象的指针永远不会逃逸，该对象就可以在分配在栈上，而不是在堆上。在有垃圾收集的语言中，这种优化可以降低垃圾收集器运行的频率\n同步消除。如果发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步\n分离对象或标量替换。如果某个对象的访问方式不要求该对象是一个连续的内存结构，那么对象的部分（或全部）可以不存储在内存，而是存储在 CPU 寄存器中\n\n¶栈上分配\nJIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了\n¶同步消除\n🎶线程同步的代价是相当高的，同步的后果是降低并发性和性能，所以如果能够尽可能减少线程间同步的发生就会提高系统的吸能\n在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除\n123456public void f() &#123;    Object obj = new Object();    synchronized(obj) &#123;        System.out.println(obj);    &#125;&#125;\n代码中对 obj 这个对象加锁，但是 obj 对象的生命周期只在 f()方法中，并不会被其他线程所访问到，所以在 JIT 编译阶段就会被优化掉，优化成：\n1234public void f() &#123;    Object obj = new Object(); System.out.println(obj);&#125;\n¶标量替换\n标量（scalar）是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java 中的对象就是聚合量，因为他可以分解成其他聚合量和标量\n在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过 JIT 优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换\n1234567891011public static void main(String args[]) &#123;    alloc();&#125;private static void alloc() &#123;    Point point = new Point(1,2);    System.out.println(&quot;point.x&quot; + point.x + &quot;;point.y&quot; + point.y);&#125;class Point &#123;    private int x;    private int y;&#125;\n以上代码，经过标量替换后，就会变成\n12345private static void alloc() &#123;    int x = 1;    int y = 2;    System.out.println(&quot;point.x = &quot; + x + &quot;; point.y=&quot; + y);&#125;\n🤔标量替换有什么好处尼？\n\n可以大大减少堆内存的占用，避免造成 GC 压力\n因为一旦不需要创建对象了，那么就不再需要分配堆内存了，所以标量替换为栈上分配提供了很好的基础\n\n¶实际问题\nJava 的堆分配、内置线程和 Sun HotSpot 动态编译器的结合创建了一个关于逃逸分析优化的候选平台。\n1234567891011121314151617class Main &#123;  public static void main(String[] args) &#123;    example();  &#125;  public static void example() &#123;    Foo foo = new Foo(); //alloc    Bar bar = new Bar(); //alloc    bar.setFoo(foo);  &#125;&#125;class Foo &#123;&#125;class Bar &#123;  private Foo foo;  public void setFoo(Foo foo) &#123;    this.foo = foo;  &#125;&#125;\n在这个示例中，创建了两个对象(用 alloc 注释)，其中一个作为方法的参数。方法 setFoo()接收到 foo 参数后，保存 Foo 对象的引用。如果 Bar 对象保存在堆中，那么 Foo 的引用将逃逸。但在这种情况下，编译器可以使用逃逸分析确定Bar 对象本身并没有逃逸 example()的调用。这意味着 Foo 引用无法逃逸。因此，编译器可以安全地在栈上分配两个对象\n¶HotSpot 逃逸分析\nJava Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上\n✨逃逸分析的基本行为就是分析对象动态作用域：\n\n当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸\n当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中\n\n123456public void my_method() &#123;    V v = new V();    // use v    // ....    v = null;&#125;\n没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除\n123456public static StringBuffer createStringBuffer(String s1, String s2) &#123;    StringBuffer sb = new StringBuffer();    sb.append(s1);    sb.append(s2);    return sb;&#125;\n上述方法如果想要StringBuffer sb不发生逃逸，可以这样写\n123456public static String createStringBuffer(String s1, String s2) &#123;    StringBuffer sb = new StringBuffer();    sb.append(s1);    sb.append(s2);    return sb.toString();&#125;\n在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析，如果使用的是较早的版本，开发人员则可以通过：\n\n选项-XX:+DoEscapeAnalysis显式开启逃逸分析\n通过选项-XX:+PrintEscapeAnalysis查看逃逸分析的筛选结果\n\n📓开发中能使用局部变量的，就不要使用在方法外定义\n¶逃逸分析总结\n逃逸分析的论文在 1999 年就已经发表了，但直到 JDK1.6 才有实现，而且这项技术到如今也并不是十分成熟\n🤔逃逸分析这么强大，为什么没有全面普及？\n\n根本原因就是无法保证逃逸分析的性能消耗一定能高于分析的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程\n一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了\n虽然这项技术并不十分成熟，但是它是即时编译器优化技术中一个十分重要的手段\n虽然通过逃逸分析，JVM 会在栈上分配那些不会逃逸的对象，在理论上是可行的，但取决于 JVM 设计者的选择，HotSpot JVM 中并没有这么做，在 HotSpot 虚拟机中可以明确所有的对象实例都是创建在堆上\nintern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上\n\n¶JVM 逃逸分析参数\n\n\n\n参数\n含义\n\n\n\n\n-XX:+EliminateAllocations\n开启标量替换（默认打开），允许将对象打散分配到栈上\n\n\n-XX:+PrintEliminateAllocations\n显示标量替换详情\n\n\n-XX:+DoEscapeAnalysis\n启用逃逸分析\n\n\n\n¶附录\n面试 Java 逃逸分析\nJVM 之逃逸分析\nwiki\n深入理解 Java 中的逃逸分析\n对象和数组并不是都在堆上分配内存的\n","dateCreated":"2021-10-24T06:08:24+00:00","dateModified":"2023-06-07T02:13:34+00:00","datePublished":"2021-10-24T06:08:24+00:00","description":"本文主要讲解什么是逃逸分析，以及在HotSpot中与逃逸分析相关的内容","headline":"逃逸分析","image":["https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/escape.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://pineapple-man.github.io/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"},"publisher":{"@type":"Organization","name":"pineapple-man","sameAs":["https://github.com/pineapple-man","mailto://mingchaohu720@gmail.com"],"image":"logo.png","logo":{"@type":"ImageObject","url":"logo.png"}},"url":"https://pineapple-man.github.io/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/","keywords":"JVM","thumbnailUrl":"https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/escape.jpg"}</script><meta name="description" content="本文主要讲解什么是逃逸分析，以及在HotSpot中与逃逸分析相关的内容"><meta property="og:type" content="blog"><meta property="og:title" content="逃逸分析"><meta property="og:url" content="https://pineapple-man.github.io/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"><meta property="og:site_name" content="pineapple-man"><meta property="og:description" content="本文主要讲解什么是逃逸分析，以及在HotSpot中与逃逸分析相关的内容"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-10-24T06:08:24.000Z"><meta property="article:modified_time" content="2023-06-07T02:13:34.011Z"><meta property="article:author" content="pineapple-man"><meta property="article:tag" content="JVM"><meta name="twitter:card" content="summary"><meta property="og:image" content="https://pineapple-man.github.io/assets/images/logo.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/escape.jpg"><meta class="swiftype" name="image" data-type="enum" content="https://cdn.jsdelivr.net/gh/pineapple-man/blogImage@main/image/escape.jpg"><link rel="stylesheet" href="/assets/css/style-oth3meuzcjopbgwqbdvoxqknhcm0sy9wkullcc94zhkkop3pmfrpl5t4fzzz.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-210516333-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-210516333-1")</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"></head><body><div id="blog"><header id="header" data-behavior="5"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/" aria-label="">pineapple-man</a></div><a class="header-right-picture" href="#about" aria-label="打开链接: /#about"><img class="header-picture" src="/assets/images/logo.png" alt="作者的图片"></a></header><nav id="sidebar" data-behavior="5"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about" aria-label="阅读有关作者的更多信息"><img class="sidebar-profile-picture" src="/assets/images/logo.png" alt="作者的图片"></a><h4 class="sidebar-profile-name">pineapple-man</h4><h5 class="sidebar-profile-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/" rel="noopener" title="首页"><i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories" rel="noopener" title="分类"><i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags" rel="noopener" title="标签"><i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives" rel="noopener" title="归档"><i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about" rel="noopener" title="关于"><i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/pineapple-man" target="_blank" rel="noopener" title="GitHub"><i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto://mingchaohu720@gmail.com" target="_blank" rel="noopener" title="邮箱"><i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul></div></nav><div id="main" data-behavior="5" class="hasCoverMetaIn"><article class="post"><div class="post-header main-content-wrap text-center"><h1 class="post-title">逃逸分析</h1><div class="post-meta"><time datetime="2021-10-24T06:08:24+00:00">10月 24, 2021 </time><span>发布在 </span><a class="category-link" href="/categories/Java/">Java</a> <i class="fas fa-book-open"></i> 本文共<span class="post-count"> 2.6k </span>字 <i class="far fa-clock"></i> 阅读预计<span class="post-count"> 25 </span>分钟</div></div><div class="post-content markdown"><div class="main-content-wrap"><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-text">逃逸分析算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%80%83%E9%80%B8%E7%8A%B6%E6%80%81"><span class="toc-text">对象的逃逸状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">逃逸分析的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D"><span class="toc-text">栈上分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%B6%88%E9%99%A4"><span class="toc-text">同步消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="toc-text">标量替换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98"><span class="toc-text">实际问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HotSpot-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-text">HotSpot 逃逸分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93"><span class="toc-text">逃逸分析总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E5%8F%82%E6%95%B0"><span class="toc-text">JVM 逃逸分析参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol><h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><p>❓什么是逃逸分析</p><ul><li>在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法——<strong>分析在程序的哪些地方可以访问到指针</strong></li><li>逃逸分析可以确定某个指针可以存储的所有地方，以及确定能否保证指针的生命周期只在当前进程或线程中</li><li>简单点理解，逃逸分析（Escape analysis）就是确定变量范围的一种分析技术</li></ul><blockquote><p>If a subroutine allocates an object and returns a pointer to it, the object can be accessed from undetermined places in the program – the pointer has “escaped”. Pointers can also escape if they are stored in global variables or other data structures that, in turn, escape the current procedure. ——wiki</p><p>如果子程序创建并返回一个对象指针，在程序运行阶段，谁会使用这个对象指针是不确定的，此时就称这个不确定调用者的对象指针发生了<strong>逃逸</strong>，同样的，如果将指针存储在全局变量或者其他类型的数据结构时，由于全局变量可以在当前子程序之外访问，此时的指针也发生了逃逸</p></blockquote><h2 id="逃逸分析算法"><a class="header-anchor" href="#逃逸分析算法">¶</a>逃逸分析算法</h2><p>Java Hotspot 编译器实现下面论文中描述的逃逸算法：</p><blockquote><p>[Choi99] Jong-Deok Choi, Manish Gupta, Mauricio Seffano,Vugranam C. Sreedhar, Sam Midkiff,“Escape Analysis for Java”, Procedings of ACM SIGPLAN OOPSLA Conference, November 1, 1999</p></blockquote><p>📓算法是上下文相关和流敏感的，并且模拟了对象任意层次的嵌套关系，所以分析精度较高，只是<strong>运行时间和内存消耗相对较大</strong>，如果对逃逸分析等底层原理非常感兴趣，建议读一读</p><h2 id="对象的逃逸状态"><a class="header-anchor" href="#对象的逃逸状态">¶</a>对象的逃逸状态</h2><p>✨从逃逸分析的角度来看，一个对象的逃逸与否存在以下三种状态：全局逃逸（Global Escape）、参数逃逸（Arg Escape）和没有逃逸</p><p>1️⃣全局逃逸，即一个对象的作用范围逃出了当前方法或者当前线程，存在以下几种场景：</p><ul><li>对象是一个静态变量</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul><p>2️⃣参数逃逸，即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调用方法的字节码确定的</p><p>3️⃣没有逃逸，即方法中的对象没有发生逃逸</p><h2 id="逃逸分析的作用"><a class="header-anchor" href="#逃逸分析的作用">¶</a>逃逸分析的作用</h2><p>编译器可以使用逃逸分析的结果作为优化的基础：</p><ul><li>将堆分配转化为<strong>栈上分配</strong>。如果某个对象在子程序中被分配，并且指向该对象的指针永远不会逃逸，该对象就可以在分配在栈上，而不是在堆上。在有垃圾收集的语言中，这种优化可以降低垃圾收集器运行的频率</li><li><strong>同步消除</strong>。如果发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步</li><li>分离对象或<strong>标量替换</strong>。如果某个对象的访问方式不要求该对象是一个连续的内存结构，那么对象的部分（或全部）可以不存储在内存，而是存储在 CPU 寄存器中</li></ul><h3 id="栈上分配"><a class="header-anchor" href="#栈上分配">¶</a>栈上分配</h3><p>JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了</p><h3 id="同步消除"><a class="header-anchor" href="#同步消除">¶</a>同步消除</h3><p>🎶线程同步的代价是相当高的，同步的后果是降低并发性和性能，所以如果能够尽可能减少线程间同步的发生就会提高系统的吸能</p><p>在动态编译同步块的时候，JIT 编译器可以<strong>借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</strong>。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫<strong>锁消除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中对 obj 这个对象加锁，但是 obj 对象的生命周期只在 f()方法中，并不会被其他线程所访问到，所以在 JIT 编译阶段就会被优化掉，优化成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标量替换"><a class="header-anchor" href="#标量替换">¶</a>标量替换</h3><p><strong>标量（scalar）是指一个无法再分解成更小的数据的数据</strong>。Java 中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），<strong>Java 中的对象就是聚合量</strong>，因为他可以分解成其他聚合量和标量</p><p>在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过 JIT 优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x&quot;</span> + point.x + <span class="string">&quot;;point.y&quot;</span> + point.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，经过标量替换后，就会变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x = &quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🤔标量替换有什么好处尼？</p><ul><li>可以大大减少堆内存的占用，避免造成 GC 压力</li><li>因为一旦不需要创建对象了，那么就不再需要分配堆内存了，所以标量替换为栈上分配提供了很好的基础</li></ul><h2 id="实际问题"><a class="header-anchor" href="#实际问题">¶</a>实际问题</h2><p>Java 的堆分配、内置线程和 Sun HotSpot 动态编译器的结合创建了一个关于逃逸分析优化的候选平台。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    example();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">example</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Foo</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foo</span>(); <span class="comment">//alloc</span></span><br><span class="line">    <span class="type">Bar</span> <span class="variable">bar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bar</span>(); <span class="comment">//alloc</span></span><br><span class="line">    bar.setFoo(foo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Foo foo;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFoo</span><span class="params">(Foo foo)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.foo = foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，创建了两个对象(用 alloc 注释)，其中一个作为方法的参数。方法 setFoo()接收到 foo 参数后，保存 Foo 对象的引用。如果 Bar 对象保存在堆中，那么 Foo 的引用将逃逸。但在这种情况下，编译器可以使用逃逸分析确定<strong>Bar 对象本身并没有逃逸 example()的调用</strong>。这意味着 Foo 引用无法逃逸。因此，<strong>编译器可以安全地在栈上分配两个对象</strong></p><h2 id="HotSpot-逃逸分析"><a class="header-anchor" href="#HotSpot-逃逸分析">¶</a>HotSpot 逃逸分析</h2><p>Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上</p><p>✨逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">my_method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">V</span>();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    v = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法如果想要<code>StringBuffer sb</code>不发生逃逸，可以这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析，如果使用的是较早的版本，开发人员则可以通过：</p><ul><li>选项<code>-XX:+DoEscapeAnalysis</code>显式开启逃逸分析</li><li>通过选项<code>-XX:+PrintEscapeAnalysis</code>查看逃逸分析的筛选结果</li></ul><p>📓开发中能使用局部变量的，就不要使用在方法外定义</p><h2 id="逃逸分析总结"><a class="header-anchor" href="#逃逸分析总结">¶</a>逃逸分析总结</h2><p>逃逸分析的论文在 1999 年就已经发表了，但直到 JDK1.6 才有实现，而且这项技术到如今也并不是十分成熟</p><p>🤔逃逸分析这么强大，为什么没有全面普及？</p><ul><li>根本原因就是<strong>无法保证逃逸分析的性能消耗一定能高于分析的消耗</strong>。虽然经过逃逸分析可以做<strong>标量替换</strong>、<strong>栈上分配</strong>、和<strong>锁消除</strong>。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程</li><li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了</li><li>虽然这项技术并不十分成熟，但是<strong>它是即时编译器优化技术中一个十分重要的手段</strong></li><li>虽然通过逃逸分析，JVM 会在栈上分配那些不会逃逸的对象，在理论上是可行的，但取决于 JVM 设计者的选择，HotSpot JVM 中并没有这么做，在 <strong>HotSpot 虚拟机中可以明确所有的对象实例都是创建在堆上</strong></li><li>intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：<strong>对象实例都是分配在堆上</strong></li></ul><h2 id="JVM-逃逸分析参数"><a class="header-anchor" href="#JVM-逃逸分析参数">¶</a>JVM 逃逸分析参数</h2><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>-XX:+EliminateAllocations</code></td><td style="text-align:center">开启标量替换（默认打开），允许将对象打散分配到栈上</td></tr><tr><td style="text-align:center"><code>-XX:+PrintEliminateAllocations</code></td><td style="text-align:center">显示标量替换详情</td></tr><tr><td style="text-align:center"><code>-XX:+DoEscapeAnalysis</code></td><td style="text-align:center">启用逃逸分析</td></tr></tbody></table><h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/javastack/p/11023044.html">面试 Java 逃逸分析</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59215831">JVM 之逃逸分析</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Escape_analysis">wiki</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903639308304397">深入理解 Java 中的逃逸分析</a><br><a target="_blank" rel="noopener" href="https://www.hollischuang.com/archives/2398">对象和数组并不是都在堆上分配内存的</a></p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-none-link" href="/tags/JVM/" rel="tag">JVM</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/cookie-%E4%BB%8B%E7%BB%8D/" data-tooltip="cookie 介绍" aria-label="上一篇: cookie 介绍"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/java-web-%E4%B8%8E-tomcat-%E5%85%A5%E9%97%A8/" data-tooltip="Java Web 与 Tomcat 入门" aria-label="下一篇: Java Web 与 Tomcat 入门"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></article><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2023 pineapple-man. All Rights Reserved.</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><br>Total <span id="busuanzi_value_site_pv"></span> views. 您是pineapple-man的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><i class="fas fa-book-open"></i> <span class="post-count">博客字数统计：370.7k</span><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="5"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/cookie-%E4%BB%8B%E7%BB%8D/" data-tooltip="cookie 介绍" aria-label="上一篇: cookie 介绍"><i class="fa fa-angle-left" aria-hidden="true"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/java-web-%E4%B8%8E-tomcat-%E5%85%A5%E9%97%A8/" data-tooltip="Java Web 与 Tomcat 入门" aria-label="下一篇: Java Web 与 Tomcat 入门"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right" aria-hidden="true"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen"><i class="fa fa-share-alt" aria-hidden="true"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录"><i class="fa fa-list" aria-hidden="true"></i></a></li></ul></div></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-times"></i></div><img id="about-card-picture" src="/assets/images/logo.png" alt="作者的图片"><h4 id="about-card-name">pineapple-man</h4><div id="about-card-bio"><p>做一个菠萝：站得笔直，头戴王冠，内心甜美</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>刚毕业就失业</p></div><div id="about-card-location"><i class="fa fa-map-marker-alt"></i><br>西安</div></div></div><div id="cover" style="background-image:url(/assets/images/cover-v1.2.0.jpg)"></div><script src="/assets/js/script-kcoiyt1nxfue7qgcpkrcixymglcc3cuxeg98fy01hqww4nblnhd2ees6j6yc.min.js"></script></body></html>